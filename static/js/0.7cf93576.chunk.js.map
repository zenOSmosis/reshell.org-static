{"version":3,"sources":["components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","components/Window/classes/WindowController.js","components/Cover/Cover.jsx","components/Cover/index.jsx","hooks/useServiceClass.js","hooks/useForceUpdate.js","services/ScreenService.js","services/UIParadigmService.js","utils/getElSize.js","core/providers/UIServicesProvider/index.jsx","utils/getElPosition.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/UIServicesProvider.jsx","services/DesktopService.js","hooks/useLocationAppRegistrationID.js","hooks/useAnimation.js","hooks/usePreload.js","services/AppOrchestrationService/classes/AppRegistration.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","core/providers/AppOrchestrationProvider/AppOrchestrationProvider.jsx","core/providers/AppOrchestrationProvider/index.js","core/providers/DesktopServiceProvider/hooks/useActiveWindowController.js","core/providers/DesktopServiceProvider/DesktopServiceProvider.jsx","core/providers/DesktopServiceProvider/index.jsx","components/Animation/index.jsx","components/Animation/Animation.jsx","utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/StackingContext/index.jsx","components/StackingContext/StackingContext.jsx","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","core/providers/AppOrchestrationProvider/useAppRuntimesAutoStart.js","components/Animation/Animation.module.css","components/Center/Center.module.css"],"names":["Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","classNames","styles","ref","Full","render","this","props","StackingContext","Component","EVT_RENDER_PROFILED","EVT_RESIZED","EVT_MOVED","WindowController","initialState","onBringToTop","DEFAULT_STATE","isMaximized","isMinimized","PhantomState","mergeOptions","_appRuntime","_elWindow","_elWindowManager","_handleBringToTop","_emitDebouncedResized","debounce","bind","_emitDebouncedMoved","_centerHandler","_scatterHandler","a","clear","getIsDestroying","destroy","__INTERNAL__setCenterHandler","centerHandler","getIsMaximized","getIsMinimized","restore","sleep","__INTERNAL__setScatterHandler","scatterHandler","bringToTop","captureRenderProfile","arrRenderProfile","emit","__INTERNAL__attachWindowElement","el","__INTERNAL__attachWindowManagerElement","setAppRuntime","appRuntime","setTitle","getTitle","getAppRuntime","getAppRegistration","runtime","getRegistration","setSize","width","height","elWindow","requestSkippableAnimationFrame","undefined","style","_uuid","getSize","getElSize","log","warn","getWindowManagerSize","elWindowManager","setPosition","x","y","left","right","top","bottom","getPosition","getElPosition","getIsBorderDisabled","setState","partialNextState","TypeError","setIsMaximized","maximize","getState","setIsMinimized","minimize","React","forwardRef","Cover","forwardedRef","isVisible","useServiceClass","ServiceClass","subscribeToUpdates","useServicesContext","startServiceClass","serviceInstance","useMemo","serviceState","setServiceState","useEffect","_handleServiceUpdate","on","EVT_UPDATED","unmount","off","useForceUpdate","refIsUnmount","useRef","current","setAlt","useCallback","alt","ScreenService","args","screenWidth","screenHeight","_handleViewportResize","_detectScreenResolution","window","addEventListener","registerCleanupHandler","removeEventListener","getScreenResolution","innerWidth","innerHeight","UIServiceCore","DESKTOP_PARADIGM","MOBILE_PARADIGM","UIParadigmService","_screenService","uiParadigm","isAutoSet","_handleUIParadigmAutoDetect","_detectUIParadigm","proxyOn","setStaticUIParadigm","Error","getIsAutoSet","getUIParadigm","offsetWidth","offsetHeight","UIServicesProvider","offsetLeft","offsetTop","useContext","UIServicesContext","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","Provider","value","services","getChildren","DesktopService","_uiParadigmService","isProfiling","activeWindowController","isUIParadigmAutoSet","_handleWindowControllerDestruct","setActiveWindowController","prevActiveWindowController","getActiveWindowController","proxyOff","EVT_DESTROYED","proxyOnce","setIsProfiling","getIsProfiling","staticUIParadigm","useLocationAppRegistrationID","location","useLocation","appRegistrationID","setAppRegistrationID","pathname","substring","useAnimation","domElement","animationName","animationDuration","animationDelay","onAnimationEnd","animationEngine","isDisabled","shouldRun","console","refOnAnimationEnd","classes","classList","visibility","BASE","contains","add","usePreload","resources","isPreloaded","_setIsPreloaded","progress","_setProgress","refResources","length","preload","Preload","onprogress","evt","oncomplete","fetch","_registrations","AppRegistration","appDescriptor","_appDescriptor","id","getAppDescriptor","getID","title","getMenu","menu","getIsPinned","Boolean","isPinned","getIsPinnedToDock","isPinnedToDock","getIsAutoStart","isAutoStart","updateAppDescriptor","appDescriptorOrID","PhantomCore","AppRegistrationCollection","addChild","appRegistration","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","sort","b","aTitle","bTitle","reverse","PhantomCollection","AppRuntime","_appRegistration","data","_windowController","__INTERNAL__setWindowController","windowController","getWindowController","getRegistrationID","getEnvironment","process","AppRuntimeCollection","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","_DesktopService","getActiveAppRegistration","getActiveAppRuntime","getAppRegistrationTitleWithDescriptorID","appDescriptorID","find","predicate","addOrUpdateAppRegistration","_launchAppRegistration","activateAppRegistration","getRunningAppRegistrations","includes","filter","forEach","activateAppRegistrationID","getAppRegistrationWithID","registration","Set","map","getIsAppRegistrationRunningWithID","getAppRuntimesWithRegistrationID","AppOrchestrationContext","AppOrchestrationProvider","appOrchestrationService","runningAppRegistrations","appRegistrations","appRuntimes","useAppRuntimesAutoStart","INITIAL_DOCUMENT_TITLE","document","DesktopServiceContext","DesktopServiceProvider","desktopService","desktopState","useActiveWindowController","forceDesktopUpdate","_handleUpdate","updatedState","Animation","preloadResources","tag","inline","disabled","_setDomElement","View","getIsElOverflown","element","innerOffsetHeight","innerOffsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","isDetecting","refPrevIsOverflown","getIsOverflown","setIsOverflown","uuid","uuidv4","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","ResizeObserver","observe","unobserve","install","isAccelerated","onMount","refOnMount","refEl","module","exports","refHasBegunAutoStart","locationAppRegistrationID","locationAppRegistration"],"mappings":"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","file":"static/js/0.7cf93576.chunk.js","sourcesContent":["import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import { PhantomState, EVT_UPDATED, EVT_DESTROYED, sleep } from \"phantom-core\";\nimport { debounce } from \"debounce\";\n\nimport getElPosition from \"@utils/getElPosition\";\nimport getElSize from \"@utils/getElSize\";\n\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// @see https://reactjs.org/docs/profiler.html\nexport const EVT_RENDER_PROFILED = \"render-profile\";\n\nexport const EVT_RESIZED = \"resized\";\nexport const EVT_MOVED = \"moved\";\n\n// Number of milliseconds to wait after a restore operation before running a\n// positioning effect such as scattering or centering. This is necessary in\n// order to allow all restore calculations (along with their CSS transitions,\n// etc.) to occur before trying to run the position effect calculations.\nconst POST_RESTORE_POSITION_EFFECT_TIMEOUT = 1000;\n\n// TODO: Implement ability to take snapshot (i.e. save to png, etc) for window previewing\n\n// TODO: Move into core directory?\n// TODO: Document\nexport default class WindowController extends PhantomState {\n  // TODO: Document\n  constructor(initialState = {}, { onBringToTop }) {\n    const DEFAULT_STATE = {\n      isMaximized: false,\n      isMinimized: false,\n    };\n\n    super(PhantomState.mergeOptions({ ...DEFAULT_STATE, ...initialState }));\n\n    this._appRuntime = null;\n\n    this._elWindow = null;\n    this._elWindowManager = null;\n\n    this._handleBringToTop = onBringToTop;\n\n    this._emitDebouncedResized = debounce(\n      this._emitDebouncedResized.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    this._emitDebouncedMoved = debounce(\n      this._emitDebouncedMoved.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    // TODO: Retain last size / moved and enable reverting back to previous settings\n    // TODO: Enable percentage calculation and adjust when resizing viewport (this should prevent windows from being able to leave the viewport)\n\n    // TODO: Ensure these are unbound when controller is destructed (related issue: https://github.com/zenOSmosis/phantom-core/issues/68)\n    // (For manually triggering Chrome's built-in Garbage Collector, see: https://github.com/facebook/react/issues/22471)\n    this._centerHandler = null;\n    this._scatterHandler = null;\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    return super.destroy(async () => {\n      // Clear any currently scheduled resize executions\n      this._emitDebouncedResized.clear();\n\n      // TODO: Determine if in dirty state, prior to closing\n      // if (\n      // window.confirm(`Are you sure you wish to close \"${this.getTitle()}\"?`)\n      // ) {\n\n      if (this._appRuntime && !this._appRuntime.getIsDestroying()) {\n        await this._appRuntime.destroy();\n      }\n\n      this._appRuntime = null;\n      this._elWindow = null;\n      this._elWindowManager = null;\n    });\n\n    //}\n  }\n\n  // TODO: Document\n  __INTERNAL__setCenterHandler(centerHandler) {\n    this._centerHandler = centerHandler;\n  }\n\n  // TODO: Document\n  async center() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not center correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._centerHandler();\n    }\n  }\n\n  // TODO: Document\n  __INTERNAL__setScatterHandler(scatterHandler) {\n    this._scatterHandler = scatterHandler;\n  }\n\n  // TODO: Document\n  async scatter() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not scatter correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._scatterHandler();\n    }\n  }\n\n  // TODO: Document\n  bringToTop() {\n    this._handleBringToTop(this);\n  }\n\n  // TODO: Document\n  /*\n  __INTERNAL__setIsActive(isActive) {\n    if (isActive !== this.getIsActive()) {\n      this.setState({ isActive });\n    }\n  }\n  */\n\n  // TODO: Document\n  /*\n  getIsActive() {\n    return this.getState().isActive;\n  }\n  */\n\n  // TODO: Document\n  // @see https://reactjs.org/docs/profiler.html\n  captureRenderProfile(arrRenderProfile) {\n    this.emit(EVT_RENDER_PROFILED, arrRenderProfile);\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowElement(el) {\n    this._elWindow = el;\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowManagerElement(el) {\n    this._elWindowManager = el;\n  }\n\n  /**\n   * Associates an AppRuntime instance with this window controller.\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  setAppRuntime(appRuntime) {\n    // TODO: Ensure appRuntime is an AppRuntime instance\n\n    this._appRuntime = appRuntime;\n\n    // TODO: Refactor title to app runtime passing (ensure it can work both ways)\n    this._appRuntime.setTitle(this.getTitle());\n  }\n\n  /**\n   * Retrieves the associated AppRuntime for this window controller.\n   *\n   * @return {AppRuntime | void}\n   */\n  getAppRuntime() {\n    return this._appRuntime;\n  }\n\n  // TODO: Document\n  getAppRegistration() {\n    const runtime = this.getAppRuntime();\n\n    if (runtime) {\n      return runtime.getRegistration();\n    }\n  }\n\n  // TODO: Document\n  setSize({ width, height }) {\n    // IMPORTANT!: Do not update state on each iteration (if at all) because that would cause excessive re-rendering\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      // FIXME: (jh) Can these be applied as a single reflow?\n      // @see https://www.sitepoint.com/10-ways-minimize-reflows-improve-performance/\n\n      requestSkippableAnimationFrame(() => {\n        if (width !== undefined) {\n          elWindow.style.width = `${width}px`;\n        }\n        if (height !== undefined) {\n          elWindow.style.height = `${height}px`;\n        }\n\n        // Emit debounced EVT_RESIZED event\n        this._emitDebouncedResized();\n      }, `${this._uuid}-size`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedResized() {\n    this.emit(EVT_RESIZED);\n  }\n\n  /**\n   * Retrieves the window's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getSize() {\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      return getElSize(elWindow);\n    } else {\n      this.log.warn(\"Unable to acquire elWindow\");\n    }\n  }\n\n  /**\n   * Retrieves the window manager's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getWindowManagerSize() {\n    const elWindowManager = this._elWindowManager;\n    if (elWindowManager) {\n      return getElSize(elWindowManager);\n    } else {\n      this.log.warn(\"Unable to acquire elWindowManager\");\n    }\n  }\n\n  // TODO: Document\n  setPosition({ x, y }) {\n    // Fixes issue where restoring using widow title bar (i.e. double-click or\n    // using window control button) would make window go to upper-left of\n    // screen\n    if (this.getIsMaximized()) {\n      return;\n    }\n\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      /**\n       * FIXME: (jh) While using translate would be better here, it is buggier\n       * to use with some of the window animations (open / minimize / restore)\n       *\n       * However, if able to tie directly into matrix operations provided by\n       * accelerated StackingContext, it might improve acceleration even\n       * further\n       *\n       * Additional reading:\n       *    - [will-change] https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\n       *    - [animating the box model]: https://whistlr.info/2021/box-model-animation\n       */\n\n      requestSkippableAnimationFrame(() => {\n        if (x !== undefined) {\n          elWindow.style.left = `${x}px`;\n\n          // Delete opposing right style\n          delete elWindow.style.right;\n        }\n        if (y !== undefined) {\n          elWindow.style.top = `${y}px`;\n\n          // Delete opposing bottom style\n          delete elWindow.style.bottom;\n        }\n\n        // IMPORTANT!: Do not update state on each iteration (if at all)\n        // because that would cause excessive re-rendering\n        this._emitDebouncedMoved();\n      }, `${this._uuid}-position`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedMoved() {\n    this.emit(EVT_MOVED);\n  }\n\n  /**\n   * Retrieves the window's upper-left-hand corner position relative to its\n   * parent (the window manager).\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n   *\n   * @param {HTMLElement} el\n   * @return {{x: number, y: number}}\n   */\n  getPosition() {\n    const elWindow = this._elWindow;\n\n    if (elWindow) {\n      return getElPosition(elWindow);\n    }\n  }\n\n  // TODO: Document\n  getIsBorderDisabled() {\n    return this.getIsMaximized() || this.getIsMinimized();\n  }\n\n  /**\n   * Sets a partial next state for this window controller.\n   *\n   * TODO: States are currently deep-merged but may become shallow merged\n   * instead.\n   *\n   * @param {Object} partialNextState\n   * @emits EVT_UPDATED\n   * @return {void}\n   */\n  setState(partialNextState) {\n    if (typeof partialNextState !== \"object\") {\n      throw new TypeError(\"partialNextState is not an object\");\n    }\n\n    // Reset polar-opposite states\n    if (partialNextState.isMaximized) {\n      partialNextState.isMinimized = false;\n    } else if (partialNextState.isMinimized) {\n      partialNextState.isMaximized = false;\n    }\n\n    return super.setState(partialNextState);\n  }\n\n  /**\n   * @param {boolean} isMaximized\n   * @return {void}\n   */\n  setIsMaximized(isMaximized) {\n    return this.setState({ isMaximized });\n  }\n\n  // TODO: Document\n  maximize() {\n    return this.setIsMaximized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is maximized.\n   *\n   * @returns {boolean}\n   */\n  getIsMaximized() {\n    return this.getState().isMaximized;\n  }\n\n  /**\n   * Sets whether or not the window is minimized.\n   *\n   * @param {boolean} isMinimized\n   * @return {void}\n   */\n  setIsMinimized(isMinimized) {\n    return this.setState({ isMinimized });\n  }\n\n  // TODO: Document\n  minimize() {\n    return this.setIsMinimized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is minimized.\n   *\n   * @return {boolean}\n   */\n  getIsMinimized() {\n    return this.getState().isMinimized;\n  }\n\n  // TODO: Document\n  restore() {\n    // IMPORTANT: The maximized / minimized states need to be set at the same\n    // time here; don't call the individual methods directly\n    this.setState({\n      isMaximized: false,\n      isMinimized: false,\n    });\n  }\n}\n","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n * @property {boolean} subscribeToUpdates? [default = true] If true, will re-\n * render the hook when the service emits EVT_UPDATED.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(\n  ServiceClass,\n  subscribeToUpdates = true\n) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    if (subscribeToUpdates) {\n      const _handleServiceUpdate = () => {\n        // IMPORTANT: Must set shallow clone of state or attached components may\n        // not update\n        setServiceState({ ...serviceInstance.getState() });\n      };\n\n      // Capture initial state\n      _handleServiceUpdate();\n\n      serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n      return function unmount() {\n        serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n      };\n    }\n  }, [serviceInstance, subscribeToUpdates]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nexport { EVT_UPDATED };\n\n/**\n * UI service class for screen resolution detection.\n */\nexport default class ScreenService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Screen Service\");\n\n    this.setState({\n      screenWidth: null,\n      screenHeight: null,\n    });\n\n    // Monitor resolution changes\n    (() => {\n      // FIXME: (jh) Debounce?\n      const _handleViewportResize = () => {\n        const { width: screenWidth, height: screenHeight } =\n          this._detectScreenResolution();\n\n        this.setState({\n          screenWidth,\n          screenHeight,\n        });\n      };\n\n      // TODO: Use common handler instead\n      window.addEventListener(\"resize\", _handleViewportResize);\n\n      this.registerCleanupHandler(() => {\n        window.removeEventListener(\"resize\", _handleViewportResize);\n      });\n\n      // Capture initial size\n      _handleViewportResize();\n    })();\n  }\n\n  /**\n   * @return {{width: number, height: number}}\n   */\n  getScreenResolution() {\n    const { screenWidth: width, screenHeight: height } = this.getState();\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Detects the current screen resolution.\n   *\n   * @return {{width: number, height: number}}\n   */\n  _detectScreenResolution() {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  // TODO: fetchMonitorRefreshRate (via request-skippable-animation-frame)\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nimport ScreenService from \"./ScreenService\";\n\nexport { EVT_UPDATED };\n\nconst DESKTOP_MINIMUM_WIDTH = 640;\nconst DESKTOP_MINIMUM_HEIGHT = 480;\n\nexport const DESKTOP_PARADIGM = \"desktop\";\nexport const MOBILE_PARADIGM = \"mobile\";\n\n/**\n * UI service class for desktop paradigm detection.\n */\nexport default class UIParadigmService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Paradigm Service\");\n\n    this._screenService = this.useServiceClass(ScreenService);\n\n    // TODO: Retain preferred setting across page loads\n    this.setState({\n      uiParadigm: null,\n      isAutoSet: true,\n    });\n\n    // Monitor paradigm changes\n    (() => {\n      const _handleUIParadigmAutoDetect = () => {\n        // Skip if not auto set\n        if (!this.getState().isAutoSet) {\n          return;\n        }\n\n        this.setState({\n          uiParadigm: this._detectUIParadigm(),\n        });\n      };\n\n      this.proxyOn(this._screenService, EVT_UPDATED, () =>\n        _handleUIParadigmAutoDetect()\n      );\n\n      // Perform initial auto-detection\n      _handleUIParadigmAutoDetect();\n    })();\n  }\n\n  /**\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | null} uiParadigm If set to\n   * null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(uiParadigm) {\n    if (\n      uiParadigm !== DESKTOP_PARADIGM &&\n      uiParadigm !== MOBILE_PARADIGM &&\n      uiParadigm !== null\n    ) {\n      throw new Error(\n        `uiParadigm must be set to \"${DESKTOP_PARADIGM}\", \"${MOBILE_PARADIGM}\", or null`\n      );\n    }\n\n    if (uiParadigm) {\n      this.setState({\n        uiParadigm,\n        // Skip auto-set\n        isAutoSet: false,\n      });\n    } else {\n      this.setState({\n        uiParadigm: this._detectUIParadigm(),\n        // Reset to auto-set\n        isAutoSet: true,\n      });\n    }\n  }\n\n  /**\n   * Retrieves if the UI paradigm is automatically set, otherwise being\n   * manually set.\n   *\n   * @return {boolean}\n   */\n  getIsAutoSet() {\n    return this.getState().isAutoSet;\n  }\n\n  /**\n   * Retrieves the paradigm of the ReShell environment.\n   *\n   * @return {DESKTOP_PARADIGM | MOBILE_PARADIGM}\n   */\n  getUIParadigm() {\n    return this.getState().uiParadigm;\n  }\n\n  /**\n   * Detects the current desktop paradigm.\n   *\n   * @return {boolean}\n   */\n  _detectUIParadigm() {\n    const { screenWidth, screenHeight } = this._screenService.getState();\n\n    let uiParadigm = DESKTOP_PARADIGM;\n\n    if (\n      screenWidth < DESKTOP_MINIMUM_WIDTH ||\n      screenHeight < DESKTOP_MINIMUM_HEIGHT\n    ) {\n      uiParadigm = MOBILE_PARADIGM;\n    }\n\n    return uiParadigm;\n  }\n}\n","/**\n * Retrieves the given element's size in pixels.\n *\n * @param {DOMElement} el\n * @return {{width: number, height: number}}\n */\nexport default function getElSize(el) {\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n\n  return {\n    width,\n    height,\n  };\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","/**\n * Retrieves the given element's upper-left-hand corner position in pixels\n * relative to its parent.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n *\n * @param {HTMLElement} el\n * @return {{x: number, y: number}}\n */\nexport default function getElPosition(el) {\n  return {\n    x: el.offsetLeft,\n    y: el.offsetTop,\n  };\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport UIParadigmService from \"./UIParadigmService\";\n\n/**\n * Manages state for the DesktopServiceProvider.\n */\nexport default class DesktopService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Desktop Service\");\n\n    this._uiParadigmService = this.useServiceClass(UIParadigmService);\n\n    this.setState({\n      isProfiling: false,\n      activeWindowController: null,\n      uiParadigm: this._uiParadigmService.getUIParadigm(),\n      isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n    });\n\n    // Mirror UI paradigm service updates to local state\n    //\n    // FIXME: (jh) Perhaps get rid of UIParadigmService altogether; this\n    // shouldn't need to be mirrored like this\n    this._uiParadigmService.on(EVT_UPDATED, () => {\n      this.setState({\n        uiParadigm: this._uiParadigmService.getUIParadigm(),\n        isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n      });\n    });\n\n    // Auto-null activeWindowController state if the current one is destructed\n    //\n    // FIXME: (jh) This logic is a bit more complicated than it should be;\n    // perhaps PhantomCore could offer some way of doing state comparisons\n    // like dependencies do for React useEffect\n    (() => {\n      // Deactivate hook window controller state if destructed\n      const _handleWindowControllerDestruct = () => {\n        this.setActiveWindowController(null);\n      };\n\n      let prevActiveWindowController = null;\n\n      this.on(EVT_UPDATED, () => {\n        const activeWindowController = this.getActiveWindowController();\n\n        // Only run comparison if active window controller has changed\n        if (activeWindowController !== prevActiveWindowController) {\n          if (prevActiveWindowController) {\n            this.proxyOff(\n              prevActiveWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          if (activeWindowController) {\n            this.proxyOnce(\n              activeWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          prevActiveWindowController = activeWindowController;\n        }\n      });\n    })();\n  }\n\n  /**\n   * Sets whether or not the windows should run React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @param {boolean} isProfiling\n   * @return {void}\n   */\n  setIsProfiling(isProfiling) {\n    this.setState({ isProfiling });\n  }\n\n  /**\n   * Retrieves whether or not the windows are running React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @return {boolean}\n   */\n  getIsProfiling() {\n    return this.getState().isProfiling;\n  }\n\n  /**\n   * Sets the active (top-most) window.\n   *\n   * @param {WindowController | null} activeWindowController\n   */\n  setActiveWindowController(activeWindowController) {\n    if (\n      activeWindowController !== null &&\n      !(activeWindowController instanceof WindowController)\n    ) {\n      throw new TypeError(\"activeWindowController must be a WindowController\");\n    }\n\n    this.setState({ activeWindowController });\n  }\n\n  /**\n   * Retrieves the active (top-most) window controller.\n   *\n   * @return {WindowController | null}\n   */\n  getActiveWindowController() {\n    return this.getState().activeWindowController;\n  }\n\n  /**\n   * @typedef {import('./UIParadigmService').DESKTOP_PARADIGM} DESKTOP_PARADIGM\n   * @typedef {import('./UIParadigmService').MOBILE_PARADIGM} MOBILE_PARADIGM\n   *\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | null} staticUIParadigm If set\n   * to null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(staticUIParadigm) {\n    this._uiParadigmService.setStaticUIParadigm(staticUIParadigm);\n  }\n}\n","import { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\n/**\n * Grabs the app registration ID from the current React Router location.\n *\n * @return {string | void}\n */\nexport default function useLocationAppRegistrationID() {\n  const location = useLocation();\n\n  const [appRegistrationID, setAppRegistrationID] = useState(null);\n\n  useEffect(() => {\n    // Remove leading forward slash (/) from location\n    const appRegistrationID = location.pathname?.substring(1);\n\n    setAppRegistrationID(appRegistrationID);\n  }, [location]);\n\n  return appRegistrationID;\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} resources An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {Object} // TODO: Document return type\n */\nexport default function usePreload(resources) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the resources; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refResources = useRef(resources);\n\n  useEffect(() => {\n    const resources = refResources.current;\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * @return {string | number}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Document\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  // TODO: Document\n  getIsAutoStart() {\n    return Boolean(this._appDescriptor.isAutoStart);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // FIXME: (jh) The only way I could get this to sort alphabetically on\n    // Firefox was to build a reverse-sorted list, then reverse it again;\n    // Chrome was not affected by this\n    return this.getChildren()\n      .sort((a, b) => {\n        const aTitle = a.getTitle();\n        const bTitle = b.getTitle();\n\n        if (aTitle < bTitle) {\n          return 1;\n        } else if (bTitle > aTitle) {\n          return -1;\n        } else {\n          return 0;\n        }\n      })\n      .reverse();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, data => {\n      this.emit(EVT_UPDATED, data);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOnce(this._appRegistration, EVT_DESTROYED, () => {\n      if (!this.getIsDestroying()) {\n        this.destroy();\n      }\n    });\n\n    this._windowController = null;\n\n    this.registerCleanupHandler(async () => {\n      if (!this.getIsDestroying()) {\n        this._windowController.destroy();\n      }\n\n      this._windowController = null;\n\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration?.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n\n    this._DesktopService = this.useServiceClass(DesktopService);\n  }\n\n  // TODO: Document\n  getActiveWindowController() {\n    return this._DesktopService.getActiveWindowController();\n  }\n\n  // TODO: Document\n  getActiveAppRegistration() {\n    return this.getActiveWindowController()?.getAppRegistration();\n  }\n\n  // TODO: Document\n  getActiveAppRuntime() {\n    return this.getActiveWindowController()?.getActiveAppRuntime();\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * descriptor ID.\n   *\n   * @param {string} appDescriptorID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithDescriptorID(appDescriptorID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appDescriptorID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appDescriptorID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getRunningAppRegistrations().includes(appRegistration)) {\n      // Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      //\n      // TODO: Incorporate this logic:\n      // \"The user can also click an app’s Dock icon to bring all of that app’s\n      // windows forward; the most recently accessed app window becomes the key\n      // window.\"\n      // (Ref. \"Activating Windows\": https://developer.apple.com/design/human-interface-guidelines/macos/windows-and-views/window-anatomy/)\n      //\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the currently registered app with the given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRegistration | void}\n   */\n  getAppRegistrationWithID(appRegistrationID) {\n    return this.getAppRegistrations().find(\n      registration => registration.getID() === appRegistrationID\n    );\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * NOTE: This is not named \"getActiveAppRegistrations\" because the \"active\"\n   * connotes the top-most window.\n   *\n   * @return {AppRegistration[]}\n   */\n  getRunningAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves whether or not an AppRegistration with the given ID is running.\n   *\n   * @param {string} appRegistrationID\n   * @return {boolean}\n   */\n  getIsAppRegistrationRunningWithID(appRegistrationID) {\n    return Boolean(\n      this.getRunningAppRegistrations().find(\n        registration => registration.getID() === appRegistrationID\n      )\n    );\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","import React from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nexport const AppOrchestrationContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const runningAppRegistrations =\n    appOrchestrationService.getRunningAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n  /*\n  const windowControllers = appRuntimes\n    .map(runtime => runtime.getWindowController())\n    // Don't include runtimes without window controllers\n    .filter(pred => pred);\n  */\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationID =\n    appOrchestrationService.activateAppRegistrationID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithDescriptorID =\n    appOrchestrationService.getAppRegistrationTitleWithDescriptorID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationContext.Provider\n      value={{\n        runningAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        // windowControllers,\n        //\n        activateAppRegistration,\n        activateAppRegistrationID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithDescriptorID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationContext.Provider>\n  );\n}\n","import AppOrchestrationProvider, {\n  AppOrchestrationContext,\n} from \"./AppOrchestrationProvider\";\n\nexport default AppOrchestrationProvider;\nexport { AppOrchestrationContext };\n","import { EVT_UPDATED } from \"phantom-core\";\nimport { useEffect } from \"react\";\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\n// FIXME: (jh) Refactor [native] window title setting\nconst INITIAL_DOCUMENT_TITLE = document.title;\n\n// FIXME: (jh) [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n/**\n * Manages setting of the HTML document title and related effects when the\n * active window controller is changed.\n *\n * @param {WindowController | null} activeWindowController\n * @return {void}\n */\nexport default function useActiveWindowController(activeWindowController) {\n  if (\n    activeWindowController !== null &&\n    !(activeWindowController instanceof WindowController)\n  ) {\n    throw new TypeError(\"activeWindowController must be a WindowController\");\n  }\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  //\n  // FIXME: (jh) This can probably be removed now that the active window\n  // controller is managed by a service\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // FIXME: (jh) Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = INITIAL_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${INITIAL_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport const DesktopServiceContext = React.createContext({});\n\n/**\n * Provides the React app DesktopService UIServiceCore binding.\n */\nexport default function DesktopServiceProvider({ children }) {\n  const { serviceInstance: desktopService } = useServiceClass(DesktopService);\n\n  const desktopState = desktopService.getState();\n\n  useActiveWindowController(desktopState.activeWindowController);\n\n  return (\n    <DesktopServiceContext.Provider\n      value={{\n        ...desktopState,\n        setActiveWindowController: desktopService.setActiveWindowController,\n        setStaticUIParadigm: desktopService.setStaticUIParadigm,\n        setIsProfiling: desktopService.setIsProfiling,\n      }}\n    >\n      {children}\n    </DesktopServiceContext.Provider>\n  );\n}\n","import DesktopServiceProvider, {\n  DesktopServiceContext,\n} from \"./DesktopServiceProvider\";\n\nexport default DesktopServiceProvider;\nexport { DesktopServiceContext };\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {boolean} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(getIsOverflown);\n\n  refPrevIsOverflown.current = isOverflown;\n\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      // FIXME: (jh) Debounce? (even though it's called within\n      // requestAnimationFrame it probably doesn't need to check at 60+fps)\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","import React, { useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n};\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nexport default function StackingContext({\n  className,\n  children,\n  isAccelerated = false,\n  onMount = () => null,\n  ...rest\n}) {\n  const refOnMount = useRef(onMount);\n\n  const refEl = useRef(null);\n\n  // Handle onMount and onDOMMatrix callbacks\n  useEffect(() => {\n    const el = refEl.current;\n\n    if (el) {\n      const onMount = refOnMount.current;\n\n      onMount(el);\n    }\n  }, []);\n\n  return (\n    <div\n      ref={refEl}\n      {...rest}\n      className={classNames(\n        styles[\"stacking-context\"],\n        isAccelerated && styles[\"accelerated\"],\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","import { useEffect, useRef } from \"react\";\nimport useLocationAppRegistrationID from \"@hooks/useLocationAppRegistrationID\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  const locationAppRegistrationID = useLocationAppRegistrationID();\n\n  // Automatically start registrations with isAutoStart set to true\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      // Prevent auto-start sequence from happening more than once\n      refHasBegunAutoStart.current = true;\n\n      // FIXME: (jh) The reversed registrations seems to open apps in forward\n      // order, based on how they are defined in the desktop array.  I\n      // haven't done a lot of testing against this, so this may need to be\n      // redefined as necessary\n      for (const registration of [...appRegistrations]\n        .filter(registration => registration.getIsAutoStart())\n        .reverse()) {\n        activateAppRegistration(registration);\n      }\n\n      // IMPORTANT: The setImmediate call fixes an issue where deep-linked apps\n      // would not focus\n      setImmediate(() => {\n        if (locationAppRegistrationID) {\n          const locationAppRegistration = appRegistrations.find(\n            registration => registration.getID() === locationAppRegistrationID\n          );\n\n          if (locationAppRegistration) {\n            activateAppRegistration(locationAppRegistration);\n          }\n        }\n      });\n    }\n  }, [locationAppRegistrationID, appRegistrations, activateAppRegistration]);\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};"],"sourceRoot":""}