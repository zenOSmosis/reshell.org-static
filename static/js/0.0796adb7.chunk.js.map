{"version":3,"sources":["components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","components/Window/classes/WindowController.js","services/ScreenService.js","services/UIParadigmService.js","hooks/useServiceClass.js","components/Cover/Cover.jsx","components/Cover/index.jsx","hooks/useForceUpdate.js","utils/getElSize.js","core/providers/UIServicesProvider/index.jsx","services/AppOrchestrationService/classes/AppRegistration.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","utils/getElPosition.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/UIServicesProvider.jsx","services/DesktopService.js","hooks/useLocationAppRegistrationID.js","hooks/useAnimation.js","hooks/usePreload.js","core/providers/DesktopServiceProvider/hooks/useActiveWindowController.js","core/providers/DesktopServiceProvider/DesktopServiceProvider.jsx","core/providers/DesktopServiceProvider/index.jsx","components/StackingContext/index.jsx","components/StackingContext/StackingContext.jsx","core/providers/AppOrchestrationServiceProvider/AppOrchestrationServiceProvider.jsx","core/providers/AppOrchestrationServiceProvider/index.js","components/Animation/index.jsx","components/Animation/Animation.jsx","utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","core/providers/AppOrchestrationServiceProvider/useAppRuntimesAutoStart.js","components/Center/Center.module.css","components/Animation/Animation.module.css"],"names":["Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","classNames","styles","ref","Full","render","this","props","StackingContext","Component","EVT_RENDER_PROFILED","EVT_RESIZED","EVT_MOVED","WindowController","initialState","onBringToTop","DEFAULT_STATE","isMaximized","isMinimized","PhantomState","mergeOptions","_appRuntime","_elWindow","_elWindowManager","_handleBringToTop","_emitDebouncedResized","debounce","bind","_emitDebouncedMoved","_centerHandler","_scatterHandler","a","clear","getIsDestroying","destroy","__INTERNAL__setCenterHandler","centerHandler","getIsMaximized","getIsMinimized","restore","sleep","__INTERNAL__setScatterHandler","scatterHandler","bringToTop","captureRenderProfile","arrRenderProfile","emit","__INTERNAL__attachWindowElement","el","__INTERNAL__attachWindowManagerElement","setAppRuntime","appRuntime","setTitle","getTitle","getAppRuntime","getAppRegistration","runtime","getRegistration","setSize","width","height","elWindow","requestSkippableAnimationFrame","undefined","style","_uuid","getSize","getElSize","log","warn","getWindowManagerSize","elWindowManager","setPosition","x","y","left","right","top","bottom","getPosition","getElPosition","getIsBorderDisabled","setState","partialNextState","TypeError","setIsMaximized","maximize","getState","setIsMinimized","minimize","ScreenService","args","screenWidth","screenHeight","_handleViewportResize","_detectScreenResolution","window","addEventListener","registerCleanupHandler","removeEventListener","getScreenResolution","innerWidth","innerHeight","UIServiceCore","DESKTOP_PARADIGM","MOBILE_PARADIGM","AUTO_DETECT_PARADIGM","UIParadigmService","_screenService","useServiceClass","uiParadigm","isAutoSet","_handleUIParadigmAutoDetect","_detectUIParadigm","proxyOn","EVT_UPDATED","setStaticUIParadigm","Error","getIsAutoSet","getUIParadigm","ServiceClass","subscribeToUpdates","useServicesContext","startServiceClass","serviceInstance","useMemo","serviceState","setServiceState","useEffect","_handleServiceUpdate","on","unmount","off","React","forwardRef","Cover","forwardedRef","isVisible","useForceUpdate","refIsUnmount","useRef","current","setAlt","useCallback","alt","offsetWidth","offsetHeight","UIServicesProvider","_registrations","AppRegistration","appDescriptor","_appDescriptor","id","getAppDescriptor","getID","getAppDescriptorID","title","getMenu","menu","getIsPinned","Boolean","isPinned","getIsPinnedToDock","isPinnedToDock","getIsAutoStart","isAutoStart","updateAppDescriptor","Object","keys","length","appDescriptorOrID","PhantomCore","AppRegistrationCollection","addChild","appRegistration","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","getChildren","PhantomCollection","AppRuntime","_appRegistration","data","proxyOnce","EVT_DESTROYED","_windowController","__INTERNAL__setWindowController","windowController","getWindowController","getRegistrationID","getEnvironment","process","AppRuntimeCollection","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","_DesktopService","DesktopService","getWindowControllers","map","filter","getActiveAppRegistration","getActiveWindowController","getActiveAppRuntime","getWindowControllerWithUUID","uuid","matchedWindowController","getUUID","getAppRegistrationTitleWithID","appRegistrationID","find","predicate","console","addOrUpdateAppRegistration","_launchAppRegistration","activateAppRegistration","getRunningAppRegistrations","includes","forEach","activateAppRegistrationWithID","getAppRegistrationWithID","registration","Set","getIsAppRegistrationRunningWithID","getAppRuntimesWithRegistrationID","offsetLeft","offsetTop","useContext","UIServicesContext","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","Provider","value","services","_uiParadigmService","isProfiling","activeWindowController","isUIParadigmAutoSet","_handleWindowControllerDestruct","setActiveWindowController","prevActiveWindowController","proxyOff","setIsProfiling","getIsProfiling","staticUIParadigm","useLocationAppRegistrationID","location","useLocation","setAppRegistrationID","pathname","substring","useAnimation","domElement","animationName","animationDuration","animationDelay","onAnimationEnd","animationEngine","isDisabled","shouldRun","refOnAnimationEnd","classes","classList","visibility","BASE","contains","add","usePreload","resources","isPreloaded","_setIsPreloaded","progress","_setProgress","refResources","preload","Preload","onprogress","evt","oncomplete","fetch","INITIAL_DOCUMENT_TITLE","document","DesktopServiceContext","DesktopServiceProvider","desktopService","desktopState","useActiveWindowController","forceDesktopUpdate","_handleUpdate","updatedState","isAccelerated","onMount","refOnMount","refEl","AppOrchestrationServiceContext","AppOrchestrationServiceProvider","appOrchestrationService","runningAppRegistrations","appRegistrations","sort","b","localeCompare","sensitivity","appRuntimes","useAppRuntimesAutoStart","Animation","preloadResources","tag","inline","disabled","_setDomElement","View","getIsElOverflown","element","innerOffsetHeight","innerOffsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","isDetecting","refPrevIsOverflown","getIsOverflown","setIsOverflown","uuidv4","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","ResizeObserver","observe","unobserve","install","module","exports","refHasBegunAutoStart","locationAppRegistrationID","locationAppRegistration"],"mappings":"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","file":"static/js/0.0796adb7.chunk.js","sourcesContent":["import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import { PhantomState, EVT_UPDATED, EVT_DESTROYED, sleep } from \"phantom-core\";\nimport { debounce } from \"debounce\";\n\nimport getElPosition from \"@utils/getElPosition\";\nimport getElSize from \"@utils/getElSize\";\n\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// @see https://reactjs.org/docs/profiler.html\nexport const EVT_RENDER_PROFILED = \"render-profile\";\n\nexport const EVT_RESIZED = \"resized\";\nexport const EVT_MOVED = \"moved\";\n\n// Number of milliseconds to wait after a restore operation before running a\n// positioning effect such as scattering or centering. This is necessary in\n// order to allow all restore calculations (along with their CSS transitions,\n// etc.) to occur before trying to run the position effect calculations.\nconst POST_RESTORE_POSITION_EFFECT_TIMEOUT = 1000;\n\n// TODO: Implement ability to take snapshot (i.e. save to png, etc) for window previewing\n\n// TODO: Move into core directory?\n// TODO: Document\nexport default class WindowController extends PhantomState {\n  // TODO: Document\n  constructor(initialState = {}, { onBringToTop }) {\n    const DEFAULT_STATE = {\n      isMaximized: false,\n      isMinimized: false,\n    };\n\n    super(PhantomState.mergeOptions({ ...DEFAULT_STATE, ...initialState }));\n\n    this._appRuntime = null;\n\n    this._elWindow = null;\n    this._elWindowManager = null;\n\n    this._handleBringToTop = onBringToTop;\n\n    this._emitDebouncedResized = debounce(\n      this._emitDebouncedResized.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    this._emitDebouncedMoved = debounce(\n      this._emitDebouncedMoved.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    // TODO: Retain last size / moved and enable reverting back to previous settings\n    // TODO: Enable percentage calculation and adjust when resizing viewport (this should prevent windows from being able to leave the viewport)\n\n    // TODO: Ensure these are unbound when controller is destructed (related issue: https://github.com/zenOSmosis/phantom-core/issues/68)\n    // (For manually triggering Chrome's built-in Garbage Collector, see: https://github.com/facebook/react/issues/22471)\n    this._centerHandler = null;\n    this._scatterHandler = null;\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    return super.destroy(async () => {\n      // Clear any currently scheduled resize executions\n      this._emitDebouncedResized.clear();\n\n      // TODO: Determine if in dirty state, prior to closing\n      // TODO: Replace w/ UIModal\n      // if (\n      // window.confirm(`Are you sure you wish to close \"${this.getTitle()}\"?`)\n      // ) {\n\n      if (this._appRuntime && !this._appRuntime.getIsDestroying()) {\n        await this._appRuntime.destroy();\n      }\n\n      this._appRuntime = null;\n      this._elWindow = null;\n      this._elWindowManager = null;\n    });\n\n    //}\n  }\n\n  // TODO: Document\n  __INTERNAL__setCenterHandler(centerHandler) {\n    this._centerHandler = centerHandler;\n  }\n\n  // TODO: Document\n  async center() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not center correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._centerHandler();\n    }\n  }\n\n  // TODO: Document\n  __INTERNAL__setScatterHandler(scatterHandler) {\n    this._scatterHandler = scatterHandler;\n  }\n\n  // TODO: Document\n  async scatter() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not scatter correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._scatterHandler();\n    }\n  }\n\n  // TODO: Document\n  bringToTop() {\n    this._handleBringToTop(this);\n  }\n\n  // TODO: Document\n  /*\n  __INTERNAL__setIsActive(isActive) {\n    if (isActive !== this.getIsActive()) {\n      this.setState({ isActive });\n    }\n  }\n  */\n\n  // TODO: Document\n  /*\n  getIsActive() {\n    return this.getState().isActive;\n  }\n  */\n\n  // TODO: Document\n  // @see https://reactjs.org/docs/profiler.html\n  captureRenderProfile(arrRenderProfile) {\n    this.emit(EVT_RENDER_PROFILED, arrRenderProfile);\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowElement(el) {\n    this._elWindow = el;\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowManagerElement(el) {\n    this._elWindowManager = el;\n  }\n\n  /**\n   * Associates an AppRuntime instance with this window controller.\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  setAppRuntime(appRuntime) {\n    // TODO: Ensure appRuntime is an AppRuntime instance\n\n    this._appRuntime = appRuntime;\n\n    // TODO: Refactor title to app runtime passing (ensure it can work both ways)\n    this._appRuntime.setTitle(this.getTitle());\n  }\n\n  /**\n   * Retrieves the associated AppRuntime for this window controller.\n   *\n   * @return {AppRuntime | void}\n   */\n  getAppRuntime() {\n    return this._appRuntime;\n  }\n\n  // TODO: Document\n  getAppRegistration() {\n    const runtime = this.getAppRuntime();\n\n    if (runtime) {\n      return runtime.getRegistration();\n    }\n  }\n\n  // TODO: Document\n  setSize({ width, height }) {\n    // IMPORTANT!: Do not update state on each iteration (if at all) because that would cause excessive re-rendering\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      // FIXME: (jh) Can these be applied as a single reflow?\n      // @see https://www.sitepoint.com/10-ways-minimize-reflows-improve-performance/\n\n      requestSkippableAnimationFrame(() => {\n        if (width !== undefined) {\n          elWindow.style.width = `${width}px`;\n        }\n        if (height !== undefined) {\n          elWindow.style.height = `${height}px`;\n        }\n\n        // Emit debounced EVT_RESIZED event\n        this._emitDebouncedResized();\n      }, `${this._uuid}-size`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedResized() {\n    this.emit(EVT_RESIZED);\n  }\n\n  /**\n   * Retrieves the window's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getSize() {\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      return getElSize(elWindow);\n    } else {\n      this.log.warn(\"Unable to acquire elWindow\");\n    }\n  }\n\n  /**\n   * Retrieves the window manager's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getWindowManagerSize() {\n    const elWindowManager = this._elWindowManager;\n    if (elWindowManager) {\n      return getElSize(elWindowManager);\n    } else {\n      this.log.warn(\"Unable to acquire elWindowManager\");\n    }\n  }\n\n  // TODO: Document\n  setPosition({ x, y }) {\n    // Fixes issue where restoring using widow title bar (i.e. double-click or\n    // using window control button) would make window go to upper-left of\n    // screen\n    if (this.getIsMaximized()) {\n      return;\n    }\n\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      /**\n       * FIXME: (jh) While using translate would be better here, it is buggier\n       * to use with some of the window animations (open / minimize / restore)\n       *\n       * However, if able to tie directly into matrix operations provided by\n       * accelerated StackingContext, it might improve acceleration even\n       * further\n       *\n       * Additional reading:\n       *    - [will-change] https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\n       *    - [animating the box model]: https://whistlr.info/2021/box-model-animation\n       */\n\n      requestSkippableAnimationFrame(() => {\n        if (x !== undefined) {\n          elWindow.style.left = `${x}px`;\n\n          // Delete opposing right style\n          delete elWindow.style.right;\n        }\n        if (y !== undefined) {\n          elWindow.style.top = `${y}px`;\n\n          // Delete opposing bottom style\n          delete elWindow.style.bottom;\n        }\n\n        // IMPORTANT!: Do not update state on each iteration (if at all)\n        // because that would cause excessive re-rendering\n        this._emitDebouncedMoved();\n      }, `${this._uuid}-position`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedMoved() {\n    this.emit(EVT_MOVED);\n  }\n\n  /**\n   * Retrieves the window's upper-left-hand corner position relative to its\n   * parent (the window manager).\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n   *\n   * @param {HTMLElement} el\n   * @return {{x: number, y: number}}\n   */\n  getPosition() {\n    const elWindow = this._elWindow;\n\n    if (elWindow) {\n      return getElPosition(elWindow);\n    }\n  }\n\n  // TODO: Document\n  getIsBorderDisabled() {\n    return this.getIsMaximized() || this.getIsMinimized();\n  }\n\n  /**\n   * Sets a partial next state for this window controller.\n   *\n   * TODO: States are currently deep-merged but may become shallow merged\n   * instead.\n   *\n   * @param {Object} partialNextState\n   * @emits EVT_UPDATED\n   * @return {void}\n   */\n  setState(partialNextState) {\n    if (typeof partialNextState !== \"object\") {\n      throw new TypeError(\"partialNextState is not an object\");\n    }\n\n    // Reset polar-opposite states\n    if (partialNextState.isMaximized) {\n      partialNextState.isMinimized = false;\n    } else if (partialNextState.isMinimized) {\n      partialNextState.isMaximized = false;\n    }\n\n    return super.setState(partialNextState);\n  }\n\n  /**\n   * @param {boolean} isMaximized\n   * @return {void}\n   */\n  setIsMaximized(isMaximized) {\n    return this.setState({ isMaximized });\n  }\n\n  // TODO: Document\n  maximize() {\n    return this.setIsMaximized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is maximized.\n   *\n   * @returns {boolean}\n   */\n  getIsMaximized() {\n    return this.getState().isMaximized;\n  }\n\n  /**\n   * Sets whether or not the window is minimized.\n   *\n   * @param {boolean} isMinimized\n   * @return {void}\n   */\n  setIsMinimized(isMinimized) {\n    return this.setState({ isMinimized });\n  }\n\n  // TODO: Document\n  minimize() {\n    return this.setIsMinimized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is minimized.\n   *\n   * @return {boolean}\n   */\n  getIsMinimized() {\n    return this.getState().isMinimized;\n  }\n\n  // TODO: Document\n  restore() {\n    // IMPORTANT: The maximized / minimized states need to be set at the same\n    // time here; don't call the individual methods directly\n    this.setState({\n      isMaximized: false,\n      isMinimized: false,\n    });\n  }\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nexport { EVT_UPDATED };\n\n/**\n * UI service class for screen resolution detection.\n */\nexport default class ScreenService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Screen Service\");\n\n    this.setState({\n      screenWidth: null,\n      screenHeight: null,\n    });\n\n    // Monitor resolution changes\n    (() => {\n      // FIXME: (jh) Debounce?\n      const _handleViewportResize = () => {\n        const { width: screenWidth, height: screenHeight } =\n          this._detectScreenResolution();\n\n        this.setState({\n          screenWidth,\n          screenHeight,\n        });\n      };\n\n      // TODO: Use common handler instead\n      window.addEventListener(\"resize\", _handleViewportResize);\n\n      this.registerCleanupHandler(() => {\n        window.removeEventListener(\"resize\", _handleViewportResize);\n      });\n\n      // Capture initial size\n      _handleViewportResize();\n    })();\n  }\n\n  /**\n   * @return {{width: number, height: number}}\n   */\n  getScreenResolution() {\n    const { screenWidth: width, screenHeight: height } = this.getState();\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Detects the current screen resolution.\n   *\n   * @return {{width: number, height: number}}\n   */\n  _detectScreenResolution() {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  // TODO: fetchMonitorRefreshRate (via request-skippable-animation-frame)\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nimport ScreenService from \"./ScreenService\";\n\nexport { EVT_UPDATED };\n\nconst DESKTOP_MINIMUM_WIDTH = 640;\nconst DESKTOP_MINIMUM_HEIGHT = 480;\n\nexport const DESKTOP_PARADIGM = \"desktop\";\nexport const MOBILE_PARADIGM = \"mobile\";\nexport const AUTO_DETECT_PARADIGM = null;\n\n/**\n * UI service class for desktop paradigm detection.\n */\nexport default class UIParadigmService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Paradigm Service\");\n\n    this._screenService = this.useServiceClass(ScreenService);\n\n    // TODO: Retain preferred setting across page loads\n    this.setState({\n      uiParadigm: AUTO_DETECT_PARADIGM,\n      isAutoSet: true,\n    });\n\n    // Monitor paradigm changes\n    (() => {\n      const _handleUIParadigmAutoDetect = () => {\n        // Skip if not auto set\n        if (!this.getState().isAutoSet) {\n          return;\n        }\n\n        this.setState({\n          uiParadigm: this._detectUIParadigm(),\n        });\n      };\n\n      this.proxyOn(this._screenService, EVT_UPDATED, () =>\n        _handleUIParadigmAutoDetect()\n      );\n\n      // Perform initial auto-detection\n      _handleUIParadigmAutoDetect();\n    })();\n  }\n\n  /**\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | AUTO_DETECT_PARADIGM} uiParadigm If set to\n   * null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(uiParadigm) {\n    if (\n      uiParadigm !== DESKTOP_PARADIGM &&\n      uiParadigm !== MOBILE_PARADIGM &&\n      uiParadigm !== AUTO_DETECT_PARADIGM\n    ) {\n      throw new Error(\n        `uiParadigm must be set to \"${DESKTOP_PARADIGM}\", \"${MOBILE_PARADIGM}\", or null`\n      );\n    }\n\n    if (uiParadigm) {\n      this.setState({\n        uiParadigm,\n        // Skip auto-set\n        isAutoSet: false,\n      });\n    } else {\n      this.setState({\n        uiParadigm: this._detectUIParadigm(),\n        // Reset to auto-set\n        isAutoSet: true,\n      });\n    }\n  }\n\n  /**\n   * Retrieves if the UI paradigm is automatically set, otherwise being\n   * manually set.\n   *\n   * @return {boolean}\n   */\n  getIsAutoSet() {\n    return this.getState().isAutoSet;\n  }\n\n  /**\n   * Retrieves the paradigm of the ReShell environment.\n   *\n   * @return {DESKTOP_PARADIGM | MOBILE_PARADIGM}\n   */\n  getUIParadigm() {\n    return this.getState().uiParadigm;\n  }\n\n  /**\n   * Detects the current desktop paradigm.\n   *\n   * @return {boolean}\n   */\n  _detectUIParadigm() {\n    const { screenWidth, screenHeight } = this._screenService.getState();\n\n    let uiParadigm = DESKTOP_PARADIGM;\n\n    if (\n      screenWidth < DESKTOP_MINIMUM_WIDTH ||\n      screenHeight < DESKTOP_MINIMUM_HEIGHT\n    ) {\n      uiParadigm = MOBILE_PARADIGM;\n    }\n\n    return uiParadigm;\n  }\n}\n","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n * @property {boolean} subscribeToUpdates? [default = true] If true, will re-\n * render the hook when the service emits EVT_UPDATED.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(\n  ServiceClass,\n  subscribeToUpdates = true\n) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    if (subscribeToUpdates) {\n      const _handleServiceUpdate = () => {\n        // IMPORTANT: Must set shallow clone of state or attached components may\n        // not update\n        setServiceState({ ...serviceInstance.getState() });\n      };\n\n      // Capture initial state\n      _handleServiceUpdate();\n\n      serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n      return function unmount() {\n        serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n      };\n    }\n  }, [serviceInstance, subscribeToUpdates]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","/**\n * Retrieves the given element's size in pixels.\n *\n * @param {DOMElement} el\n * @return {{width: number, height: number}}\n */\nexport default function getElSize(el) {\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n\n  return {\n    width,\n    height,\n  };\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    // TODO: Validate against proper type\n    if (!Object.keys(appDescriptor).length) {\n      throw new TypeError(\n        \"appDescriptor does not appear to be a valid application descriptor\"\n      );\n    }\n\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * Retrieves the app descriptor's ID.\n   *\n   * NOTE: [appRegistration]ID and appDescriptorID are synonymous here, however\n   * they should not be confused with UUID and shortUUID.\n   *\n   * @return {string}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * Alias for this.getID().\n   *\n   * NOTE: [appRegistration]ID and appDescriptorID are synonymous here, however\n   * they should not be confused with UUID and shortUUID.\n   *\n   * @alias <getAppDescriptorID>\n   */\n  getAppDescriptorID() {\n    return this.getID();\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Document\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  // TODO: Document\n  getIsAutoStart() {\n    return Boolean(this._appDescriptor.isAutoStart);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // IMPORTANT: Don't sort these here unless the result can be memoized\n    return this.getChildren();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, data => {\n      this.emit(EVT_UPDATED, data);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOnce(this._appRegistration, EVT_DESTROYED, () => {\n      if (!this.getIsDestroying()) {\n        this.destroy();\n      }\n    });\n\n    this._windowController = null;\n\n    this.registerCleanupHandler(async () => {\n      if (!this.getIsDestroying()) {\n        this._windowController.destroy();\n      }\n\n      this._windowController = null;\n\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration?.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n\n    this._DesktopService = this.useServiceClass(DesktopService);\n  }\n\n  // TODO: Import WindowController type\n  /**\n   * Retrieves all of the window controllers for all of the running apps.\n   *\n   * @return {WindowController[]}\n   */\n  getWindowControllers() {\n    return this.getAppRuntimes()\n      .map(runtime => runtime.getWindowController())\n      .filter(windowController => windowController);\n  }\n\n  // TODO: Document\n  getActiveAppRegistration() {\n    return this.getActiveWindowController()?.getAppRegistration();\n  }\n\n  // TODO: Document\n  getActiveAppRuntime() {\n    return this.getActiveWindowController()?.getActiveAppRuntime();\n  }\n\n  // TODO: Document\n  getActiveWindowController() {\n    return this._DesktopService.getActiveWindowController();\n  }\n\n  // TODO: Import WindowController type\n  /**\n   * Retrieves the window controller with the given UUID.\n   *\n   * @param {uuid} string\n   * @return {WindowController | void}\n   */\n  getWindowControllerWithUUID(uuid) {\n    let matchedWindowController;\n\n    for (const windowController of this.getWindowControllers()) {\n      if (windowController.getUUID() === uuid) {\n        matchedWindowController = windowController;\n        break;\n      }\n    }\n\n    return matchedWindowController;\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithID(appRegistrationID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appRegistrationID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appRegistrationID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getRunningAppRegistrations().includes(appRegistration)) {\n      // Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      //\n      // TODO: Incorporate this logic:\n      // \"The user can also click an apps Dock icon to bring all of that apps\n      // windows forward; the most recently accessed app window becomes the key\n      // window.\"\n      // (Ref. \"Activating Windows\": https://developer.apple.com/design/human-interface-guidelines/macos/windows-and-views/window-anatomy/)\n      //\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationWithID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the currently registered app with the given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRegistration | void}\n   */\n  getAppRegistrationWithID(appRegistrationID) {\n    return this.getAppRegistrations().find(\n      registration => registration.getID() === appRegistrationID\n    );\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * NOTE: This is not named \"getActiveAppRegistrations\" because the \"active\"\n   * connotes the top-most window.\n   *\n   * @return {AppRegistration[]}\n   */\n  getRunningAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves whether or not an AppRegistration with the given ID is running.\n   *\n   * @param {string} appRegistrationID\n   * @return {boolean}\n   */\n  getIsAppRegistrationRunningWithID(appRegistrationID) {\n    return Boolean(\n      this.getRunningAppRegistrations().find(\n        registration => registration.getID() === appRegistrationID\n      )\n    );\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","/**\n * Retrieves the given element's upper-left-hand corner position in pixels\n * relative to its parent.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n *\n * @param {HTMLElement} el\n * @return {{x: number, y: number}}\n */\nexport default function getElPosition(el) {\n  return {\n    x: el.offsetLeft,\n    y: el.offsetTop,\n  };\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport UIParadigmService from \"./UIParadigmService\";\n\n/**\n * Manages state for the DesktopServiceProvider.\n */\nexport default class DesktopService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Desktop Service\");\n\n    this._uiParadigmService = this.useServiceClass(UIParadigmService);\n\n    this.setState({\n      isProfiling: false,\n      activeWindowController: null,\n      uiParadigm: this._uiParadigmService.getUIParadigm(),\n      isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n    });\n\n    // Mirror UI paradigm service updates to local state\n    //\n    // FIXME: (jh) Perhaps get rid of UIParadigmService altogether; this\n    // shouldn't need to be mirrored like this\n    this._uiParadigmService.on(EVT_UPDATED, () => {\n      this.setState({\n        uiParadigm: this._uiParadigmService.getUIParadigm(),\n        isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n      });\n    });\n\n    // Auto-null activeWindowController state if the current one is destructed\n    //\n    // FIXME: (jh) This logic is a bit more complicated than it should be;\n    // perhaps PhantomCore could offer some way of doing state comparisons\n    // like dependencies do for React useEffect\n    (() => {\n      // Deactivate hook window controller state if destructed\n      const _handleWindowControllerDestruct = () => {\n        this.setActiveWindowController(null);\n      };\n\n      let prevActiveWindowController = null;\n\n      this.on(EVT_UPDATED, () => {\n        const activeWindowController = this.getActiveWindowController();\n\n        // Only run comparison if active window controller has changed\n        if (activeWindowController !== prevActiveWindowController) {\n          if (prevActiveWindowController) {\n            this.proxyOff(\n              prevActiveWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          if (activeWindowController) {\n            this.proxyOnce(\n              activeWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          prevActiveWindowController = activeWindowController;\n        }\n      });\n    })();\n  }\n\n  /**\n   * Sets whether or not the windows should run React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @param {boolean} isProfiling\n   * @return {void}\n   */\n  setIsProfiling(isProfiling) {\n    this.setState({ isProfiling });\n  }\n\n  /**\n   * Retrieves whether or not the windows are running React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @return {boolean}\n   */\n  getIsProfiling() {\n    return this.getState().isProfiling;\n  }\n\n  /**\n   * Sets the active (top-most) window.\n   *\n   * @param {WindowController | null} activeWindowController\n   */\n  setActiveWindowController(activeWindowController) {\n    if (\n      activeWindowController !== null &&\n      !(activeWindowController instanceof WindowController)\n    ) {\n      throw new TypeError(\"activeWindowController must be a WindowController\");\n    }\n\n    this.setState({ activeWindowController });\n  }\n\n  /**\n   * Retrieves the active (top-most) window controller.\n   *\n   * @return {WindowController | null}\n   */\n  getActiveWindowController() {\n    return this.getState().activeWindowController;\n  }\n\n  /**\n   * @typedef {import('./UIParadigmService').DESKTOP_PARADIGM} DESKTOP_PARADIGM\n   * @typedef {import('./UIParadigmService').MOBILE_PARADIGM} MOBILE_PARADIGM\n   *\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | AUTO_DETECT_PARADIGM} staticUIParadigm If set\n   * to null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(staticUIParadigm) {\n    this._uiParadigmService.setStaticUIParadigm(staticUIParadigm);\n  }\n}\n","import { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\n/**\n * Grabs the app registration ID from the current React Router location.\n *\n * @return {string | void}\n */\nexport default function useLocationAppRegistrationID() {\n  const location = useLocation();\n\n  const [appRegistrationID, setAppRegistrationID] = useState(null);\n\n  useEffect(() => {\n    // Remove leading forward slash (/) from location\n    const appRegistrationID = location.pathname?.substring(1);\n\n    setAppRegistrationID(appRegistrationID);\n  }, [location]);\n\n  return appRegistrationID;\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} resources An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {Object} // TODO: Document return type\n */\nexport default function usePreload(resources) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the resources; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refResources = useRef(resources);\n\n  useEffect(() => {\n    const resources = refResources.current;\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import { EVT_UPDATED } from \"phantom-core\";\nimport { useEffect } from \"react\";\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\n// FIXME: (jh) Refactor [native] window title setting\nconst INITIAL_DOCUMENT_TITLE = document.title;\n\n// FIXME: (jh) [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n/**\n * Manages setting of the HTML document title and related effects when the\n * active window controller is changed.\n *\n * @param {WindowController | null} activeWindowController\n * @return {void}\n */\nexport default function useActiveWindowController(activeWindowController) {\n  if (\n    activeWindowController !== null &&\n    !(activeWindowController instanceof WindowController)\n  ) {\n    throw new TypeError(\"activeWindowController must be a WindowController\");\n  }\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  //\n  // FIXME: (jh) This can probably be removed now that the active window\n  // controller is managed by a service\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // FIXME: (jh) Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = INITIAL_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${INITIAL_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport const DesktopServiceContext = React.createContext({});\n\n/**\n * Provides the React app DesktopService UIServiceCore binding.\n */\nexport default function DesktopServiceProvider({ children }) {\n  const { serviceInstance: desktopService } = useServiceClass(DesktopService);\n\n  const desktopState = desktopService.getState();\n\n  useActiveWindowController(desktopState.activeWindowController);\n\n  return (\n    <DesktopServiceContext.Provider\n      value={{\n        ...desktopState,\n        setActiveWindowController: desktopService.setActiveWindowController,\n        setStaticUIParadigm: desktopService.setStaticUIParadigm,\n        setIsProfiling: desktopService.setIsProfiling,\n      }}\n    >\n      {children}\n    </DesktopServiceContext.Provider>\n  );\n}\n","import DesktopServiceProvider, {\n  DesktopServiceContext,\n} from \"./DesktopServiceProvider\";\n\nexport default DesktopServiceProvider;\nexport { DesktopServiceContext };\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","import React, { useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n};\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nexport default function StackingContext({\n  className,\n  children,\n  isAccelerated = false,\n  onMount = () => null,\n  ...rest\n}) {\n  const refOnMount = useRef(onMount);\n\n  const refEl = useRef(null);\n\n  // Handle onMount and onDOMMatrix callbacks\n  useEffect(() => {\n    const el = refEl.current;\n\n    if (el) {\n      const onMount = refOnMount.current;\n\n      onMount(el);\n    }\n  }, []);\n\n  return (\n    <div\n      ref={refEl}\n      {...rest}\n      className={classNames(\n        styles[\"stacking-context\"],\n        isAccelerated && styles[\"accelerated\"],\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n}\n","import React, { useEffect } from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nexport const AppOrchestrationServiceContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationServiceProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const runningAppRegistrations =\n    appOrchestrationService.getRunningAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n\n  // Sort app registrations in place\n  //\n  // FIXME: (jh) It would be better to move this functionality into the\n  // collection itself; this also might not handle situations where updating\n  // a registration title during runtime will automatically re-apply the sort.\n  // Relevant issue: https://github.com/jzombie/pre-re-shell/issues/172\n  useEffect(() => {\n    appRegistrations\n      // Locale compare sort fix borrowed from: https://dev.to/charlesmwray/comment/l899\n      .sort((a, b) => {\n        return a.getTitle().localeCompare(\n          b.getTitle(),\n          // TODO: Replace hardcoding with dynamic variable\n          \"en\",\n          { sensitivity: \"base\" }\n        );\n      });\n  }, [appRegistrations]);\n\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n\n  // TODO: If enabling, this needs to be memoized (or contained within a\n  // phantom collection)\n  /*\n  const windowControllers = appRuntimes\n    .map(runtime => runtime.getWindowController())\n    // Don't include runtimes without window controllers\n    .filter(pred => pred);\n  */\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationWithID =\n    appOrchestrationService.activateAppRegistrationWithID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithID =\n    appOrchestrationService.getAppRegistrationTitleWithID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationServiceContext.Provider\n      value={{\n        runningAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        // windowControllers,\n        //\n        activateAppRegistration,\n        activateAppRegistrationWithID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationServiceContext.Provider>\n  );\n}\n","import AppOrchestrationServiceProvider, {\n  AppOrchestrationServiceContext,\n} from \"./AppOrchestrationServiceProvider\";\n\nexport default AppOrchestrationServiceProvider;\nexport { AppOrchestrationServiceContext };\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\n// TODO: Document\n// TODO: Add prop-types\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  // i.e. \"1s\"\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {boolean} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(getIsOverflown);\n\n  refPrevIsOverflown.current = isOverflown;\n\n  // TODO: Replace w/ useUUID\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      // FIXME: (jh) Debounce? (even though it's called within\n      // requestAnimationFrame it probably doesn't need to check at 60+fps)\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","import { useEffect, useRef } from \"react\";\nimport useLocationAppRegistrationID from \"@hooks/useLocationAppRegistrationID\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  const locationAppRegistrationID = useLocationAppRegistrationID();\n\n  // Automatically start registrations with isAutoStart set to true\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      // Prevent auto-start sequence from happening more than once\n      refHasBegunAutoStart.current = true;\n\n      for (const registration of [...appRegistrations].filter(registration =>\n        registration.getIsAutoStart()\n      )) {\n        activateAppRegistration(registration);\n      }\n\n      // IMPORTANT: The setImmediate call fixes an issue where deep-linked apps\n      // would not focus\n      setImmediate(() => {\n        if (locationAppRegistrationID) {\n          const locationAppRegistration = appRegistrations.find(\n            registration => registration.getID() === locationAppRegistrationID\n          );\n\n          if (locationAppRegistration) {\n            activateAppRegistration(locationAppRegistration);\n          }\n        }\n      });\n    }\n  }, [locationAppRegistrationID, appRegistrations, activateAppRegistration]);\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};"],"sourceRoot":""}