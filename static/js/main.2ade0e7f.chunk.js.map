{"version":3,"sources":["core/classes/UIServiceCore.js","core/BaseView/providers/AppRegistrationsProvider/classes/AppRegistration.js","hooks/useForceUpdate.js","core/startupHelpers.js","services/KeyVaultService/engines/StorageEngine.js","services/KeyVaultService/engines/SessionStorageEngine.js","services/KeyVaultService/engines/LocalStorageEngine.js","services/KeyVaultService/KeyVaultService.js","services/KeyVaultService/index.js","components/FullViewport/FullViewport.jsx","components/FullViewport/index.jsx","core/BaseView/providers/ParadigmProvider.jsx","core/BaseView/index.jsx","core/BaseView/BaseView.jsx","core/classes/ReShellCore.js","core/classes/UIServiceCollection.js","core/BaseView/providers/UIServicesProvider/UIServicesProvider.jsx","core/BaseView/providers/UIServicesProvider/index.jsx","core/BaseView/providers/AppRegistrationsProvider/classes/AppRegistrationCollection.js","core/BaseView/providers/AppRegistrationsProvider/AppRegistrationsProvider.jsx","core/BaseView/providers/AppRegistrationsProvider/index.jsx","core/globals/window.ReShell.js","core/index.js","core/BaseView/providers/AppRuntimesProvider/classes/AppRuntime.js","core/BaseView/providers/AppRuntimesProvider/classes/AppRuntimeCollection.js","core/BaseView/providers/AppRuntimesProvider/services/AppRuntimeOrchestrationService.js","core/BaseView/providers/AppRuntimesProvider/AppRuntimesProvider.jsx","core/BaseView/providers/AppRuntimesProvider/index.jsx","core/BaseView/providers/AppRuntimesProvider/useAppRuntimesAutoStart.js","core/BaseView/providers/DesktopProvider/hooks/useActiveWindowController.js","core/BaseView/providers/DesktopProvider/classes/BackgroundAssetCollection.js","core/BaseView/providers/DesktopProvider/DesktopProvider.jsx","core/BaseView/providers/DesktopProvider/index.jsx","core/BaseView/providers/DesktopProvider/hooks/useBackgroundAssetCollection.js","reportWebVitals.js","registerPortals.js","index.js"],"names":["UIServiceCore","initialState","DEFAULT_STATE","_useServiceHandler","ReferenceError","_state","Object","seal","mergeOptions","_collectionMap","Map","setTitle","getClassName","getMethodNames","forEach","methodName","bind","a","Promise","all","this","values","map","collection","destroy","ServiceClass","CollectionClass","get","collectionInstance","PhantomCollection","TypeError","proxyOn","EVT_UPDATED","emit","set","instance","getCollectionInstance","partialNextState","PhantomCore","_registrations","AppRegistration","appDescriptor","_appDescriptor","id","title","menu","Boolean","isPinned","isPinnedToDock","isAutoStart","updateAppDescriptor","appDescriptorOrID","useForceUpdate","refIsUnmount","useRef","useEffect","current","useState","setAlt","useCallback","alt","dayjs","extend","relativeTime","StorageEngine","key","value","SessionStorageEngine","args","window","sessionStorage","setItem","removeItem","getItem","keys","clear","LocalStorageEngine","localStorage","KeyVaultService","_storageEngineCollection","StorageEngineCollection","addStorageEngineClass","storageEngines","getStorageEngines","keyStorageEngineMaps","storageEngine","fetchKeys","push","fetchKeyStorageEngineMaps","StorageEngineClass","removeStorageEngineClass","getChildren","shortUUID","find","predicate","getShortUUID","getChildWithKey","addChild","removeChild","EVT_RESIZE","EVT_TOUCH_MOVE","EVT_TOUCH_END","FullViewport","props","_handleTouchMove","evt","preventDefault","_handleTap","t2","timeStamp","dt","currentTarget","__lastTouch","fingers","touches","length","_handleViewportResize","_ref","isInPollingMode","document","activeElement","includes","tagName","body","scrollTop","width","innerWidth","height","innerHeight","_lastPollWidth","_lastPollHeight","style","onResize","_pollingInterval","_pollingTime","addEventListener","passive","setInterval","documentElement","classList","add","remove","removeEventListener","clearInterval","children","className","propsRest","ref","c","classNames","Component","ParadigmContext","React","createContext","ParadigmProvider","Provider","BaseView","portal","areBaseStylesLoaded","setAreBaseStylesLoaded","then","catch","err","console","error","PortalView","UIServicesProvider","AppRegistrationsProvider","AppRuntimesProvider","DesktopProvider","KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME","_instance","ReShellCore","portalName","isReady","_uiServiceCollection","UIServiceCollection","startServiceClass","_init","sessionStorageEngine","getService","getSessionStorageEngine","fetchItem","_activePortalName","innerHTML","getElementsByTagName","elStyle","parentNode","_elBase","createElement","appendChild","ReactDOM","render","StrictMode","fallback","ret","urlQuery","queryString","stringify","location","href","portals","reload","switchToPortal","getUIServiceCollection","getPortalName","setTimeout","parse","search","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","EVT_DESTROYED","destroyAllChildren","service","cachedService","prototype","useService","addServiceClass","UIServicesContext","forceUpdate","useMemo","serviceCollection","_handleServiceAddedOrRemoved","on","startService","stopService","stopServiceClass","services","AppRegistrationCollection","appRegistration","sort","b","aTitle","getTitle","bTitle","reverse","AppRegistrationsContext","appRegistrations","_setAppRegistrations","_appRegistrationCollection","_setAppRegistrationCollection","appCollection","getAppRegistrations","addOrUpdateAppRegistration","addAppRegistration","removeAppRegistration","getAppRegistrationTitle","appDescriptorID","getID","warn","ReShell","AppRuntime","_appRegistration","_windowController","bringToTop","windowController","getAppDescriptor","process","AppRuntimeCollection","appRuntime","AppRuntimeOrchestrationService","bindCollectionClass","addAppRuntime","getAppRuntimes","AppRuntimesContext","useContext","appOrchestrationService","appRuntimes","runningRegistrations","runtime","getRegistration","off","startAppRuntime","bringToFrontOrStartAppRuntime","filter","switchToAppRegistrationID","appRegistrationID","stopAppRuntime","getAppRuntimesWithRegistrationID","registrationID","getRegistrationID","refHasAutoStarted","openTimeout","registration","getIsAutoStart","clearTimeout","useAppRuntimesAutoStart","DEFAULT_DOCUMENT_TITLE","BackgroundAssetCollection","backgroundAsset","DesktopContext","activeWindowController","setActiveWindowController","forceDesktopUpdate","_handleUpdate","updatedState","undefined","useActiveWindowController","assetCollection","setAssetCollection","backgroundAssets","setBackgroundAssets","once","getBackgroundAssets","addBackgroundAsset","removeBackgroundAsset","useBackgroundAssetCollection","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","default","lazy","registerPortals","name","log","webVitalsReport"],"mappings":"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","file":"static/js/main.2ade0e7f.chunk.js","sourcesContent":["// TODO: Add this to PhantomCore repository\nimport PhantomCore, {\n  PhantomCollection,\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Configure reporter channel (base class PhantomState, SyncObject or\n// equivalent (not sure if SyncObject would be useful here, but could enable\n// remote reporting))\n//\n// TODO: Base off of node.js-able module in PhantomCore (i.e. PhantomServiceCore, or similar)\n//\n// TODO: Document\n//\n// TODO: Consider this: Thought about extending PhantomCollection, instead,\n// since retaining a localized state of children (which happen to be\n// collections as well), but want to keep it open to the possibility of\n// managing other types of collection-type data without the possibility of a\n// conflict (i.e. collections based on role, etc.)\nexport default class UIServiceCore extends PhantomCore {\n  constructor(initialState = {}) {\n    const DEFAULT_STATE = {};\n\n    super();\n\n    if (typeof this._useServiceHandler !== \"function\") {\n      throw new ReferenceError(\n        \"_useServiceHandler property should be set by the collection this service is collected in\"\n      );\n    }\n\n    this._state = Object.seal(\n      UIServiceCore.mergeOptions(DEFAULT_STATE, initialState)\n    );\n\n    // A map of collections, attached to this service core\n    this._collectionMap = new Map();\n\n    // Set default title\n    this.setTitle(`[non-aliased-service]:${this.getClassName()}`);\n\n    // TODO: Include ability to dynamically link in Providers to a service so\n    // that the same providers will be available to all consumers of the\n    // service\n\n    // Rebind each method to this instance so that buttons, etc. can be mapped\n    // directly to serviceCore methods without an intermediate handler\n    // TODO: Move to PhantomCore (@see https://github.com/zenOSmosis/phantom-core/issues/74)\n    // @see [for how to test] https://github.com/sindresorhus/auto-bind\n    this.getMethodNames().forEach(methodName => {\n      this[methodName] = this[methodName].bind(this);\n    });\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // Destruct all attached collections\n    await Promise.all(\n      [...this._collectionMap.values()].map(collection => collection.destroy())\n    );\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  useService(ServiceClass) {\n    return this._useServiceHandler(ServiceClass);\n  }\n\n  /**\n   * @param {PhantomCollection} CollectionClass\n   * @return {PhantomCollection} instance\n   */\n  getCollectionInstance(CollectionClass) {\n    return this._collectionMap.get(CollectionClass);\n  }\n\n  /**\n   * Binds a non-instantiated PhantomCollection to this service, propagating\n   * EVT_UPDATED through the class.\n   *\n   * IMPORTANT: Bound collection classes shared with multiple services using\n   * bindCollectionClass will use separate instances of the collection.\n   *\n   * @param {PhantomCollection} CollectionClass\n   * @return {void}\n   */\n  bindCollectionClass(CollectionClass) {\n    const collectionInstance = new CollectionClass();\n\n    // FIXME: (jh) A better check would be to determine this before\n    // instantiation, if possible\n    if (!(collectionInstance instanceof PhantomCollection)) {\n      throw new TypeError(\"collectionInstance is not a PhantomCollection\");\n    }\n\n    // Proxy collection EVT_UPDATED through the service core\n    this.proxyOn(collectionInstance, EVT_UPDATED, () => this.emit(EVT_UPDATED));\n\n    this._collectionMap.set(CollectionClass, collectionInstance);\n  }\n\n  // TODO: Document\n  unbindCollectionClass(CollectionClass) {\n    const instance = this.getCollectionInstance(CollectionClass);\n\n    if (instance) {\n      instance.destroy();\n    }\n  }\n\n  // TODO: Implement optional profiling?\n  // TODO: Document\n  setState(partialNextState = {}) {\n    // IMPORTANT: This state is only shallow merged due to deep merging not\n    // working for certain native types\n    this._state = { ...this._state, ...partialNextState };\n\n    this.emit(EVT_UPDATED, partialNextState);\n  }\n\n  // TODO: Document\n  getState() {\n    return this._state;\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\n// TODO: Use Map instead?\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * @return {string | number}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Document\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  // TODO: Document\n  getIsAutoStart() {\n    return Boolean(this._appDescriptor.isAutoStart);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt((alt) => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","// IMPORTANT: This file is included within ReShell core, so it is good practice\n// to not include ReShell core as a dependency here\n\nimport dayjs from \"dayjs\";\n\n// Extend day.js w/ fromNow() method\nimport relativeTime from \"dayjs/plugin/relativeTime\";\ndayjs.extend(relativeTime);\n","import PhantomCore from \"phantom-core\";\n\n/**\n * NOTE: All of these methods are async to handle potential network,\n * off-process, or async-based storage engines.\n *\n * To ensure maximum compatibility, extension classes should use the async API\n * as well.\n */\nexport default class StorageEngine extends PhantomCore {\n  // TODO: Document\n  async setItem(key, value) {\n    throw new ReferenceError(\"setItem must be overridden\");\n  }\n\n  // TODO: Document\n  async removeItem(key) {\n    throw new ReferenceError(\"removeItem must be overridden\");\n  }\n\n  // TODO: Document\n  async fetchItem(key) {\n    throw new ReferenceError(\"fetchItem must be overridden\");\n  }\n\n  // TODO: Document\n  async fetchKeys() {\n    throw new ReferenceError(\"fetchKeys must be overridden\");\n  }\n\n  // TODO: Document\n  async clear() {\n    throw new ReferenceError(\"clear must be overridden\");\n  }\n}\n","import StorageEngine from \"./StorageEngine\";\n\nexport default class SessionStorageEngine extends StorageEngine {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"SessionStorageEngine\");\n  }\n\n  // TODO: Document\n  async setItem(key, value) {\n    return window.sessionStorage.setItem(key, value);\n  }\n\n  // TODO: Document\n  async removeItem(key) {\n    return window.sessionStorage.removeItem(key);\n  }\n\n  // TODO: Document\n  async fetchItem(key) {\n    return window.sessionStorage.getItem(key);\n  }\n\n  // TODO: Document\n  async fetchKeys() {\n    return Object.keys(window.sessionStorage);\n  }\n\n  // TODO: Document\n  async clear() {\n    window.sessionStorage.clear();\n  }\n}\n","import StorageEngine from \"./StorageEngine\";\n\nexport default class LocalStorageEngine extends StorageEngine {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"LocalStorageEngine\");\n  }\n\n  // TODO: Document\n  async setItem(key, value) {\n    return window.localStorage.setItem(key, value);\n  }\n\n  // TODO: Document\n  async removeItem(key) {\n    return window.localStorage.removeItem(key);\n  }\n\n  // TODO: Document\n  async fetchItem(key) {\n    return window.localStorage.getItem(key);\n  }\n\n  // TODO: Document\n  async fetchKeys() {\n    return Object.keys(window.localStorage);\n  }\n\n  // TODO: Document\n  async clear() {\n    window.localStorage.clear();\n  }\n}\n","import { PhantomCollection, EVT_UPDATED } from \"phantom-core\";\nimport UIServiceCore from \"@core/classes/UIServiceCore\";\n\nimport StorageEngine from \"./engines/StorageEngine\";\nimport SessionStorageEngine from \"./engines/SessionStorageEngine\";\nimport LocalStorageEngine from \"./engines/LocalStorageEngine\";\n\n// TODO: [max size estimate; no Safari support!] https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/estimate\n\n// Additional reading: https://web.dev/storage-for-the-web/\n\n// Potential storage backends:\n// - https://github.com/willgm/web-crypto-storage\n// - https://www.npmjs.com/package/secure-ls\n\nexport default class KeyVaultService extends UIServiceCore {\n  constructor() {\n    super();\n\n    this.setTitle(\"Key Vault Service\");\n\n    this._storageEngineCollection = new StorageEngineCollection();\n\n    // Proxy storage engine collection EVT_UPDATED events through this instance\n    this.proxyOn(this._storageEngineCollection, EVT_UPDATED, (...args) =>\n      this.emit(EVT_UPDATED, ...args)\n    );\n\n    this.addStorageEngineClass(SessionStorageEngine);\n    this.addStorageEngineClass(LocalStorageEngine);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    await this._storageEngineCollection.destroy();\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  // TODO: TODO: Implement optional filtering\n  async fetchKeyStorageEngineMaps() {\n    const storageEngines = this._storageEngineCollection.getStorageEngines();\n\n    const keyStorageEngineMaps = [];\n\n    for (const storageEngine of storageEngines) {\n      const keys = await storageEngine.fetchKeys();\n\n      // TODO: Refactor as part of PhantomCore API (i.e. storageEngine.getClass())\n      // const StorageEngineClass = storageEngine.constructor;\n\n      for (const key of keys) {\n        keyStorageEngineMaps.push([key, storageEngine]);\n      }\n    }\n\n    return keyStorageEngineMaps;\n  }\n\n  // TODO: Implement optional filtering\n  /**\n   * Fetches all keys from all connected storage engines.\n   *\n   * @return {any[]}\n   */\n  async fetchKeys() {\n    return (await this.fetchKeyStorageEngineMaps()).map(\n      keyStorageEngineMaps => keyStorageEngineMaps[0]\n    );\n  }\n\n  // TODO: Document\n  addStorageEngineClass(StorageEngineClass) {\n    this._storageEngineCollection.addStorageEngineClass(StorageEngineClass);\n  }\n\n  // TODO: Document\n  removeStorageEngineClass(StorageEngineClass) {\n    this._storageEngineCollection.removeStorageEngineClass(StorageEngineClass);\n  }\n\n  // TODO: Document\n  getStorageEngines() {\n    return this._storageEngineCollection.getChildren();\n  }\n\n  // TODO: Document\n  getStorageEngineWithShortUUID(shortUUID) {\n    return this.getStorageEngines().find(\n      predicate => predicate.getShortUUID() === shortUUID\n    );\n  }\n\n  // TODO: Document\n  getSessionStorageEngine() {\n    return this._storageEngineCollection.getChildWithKey(SessionStorageEngine);\n  }\n\n  // TODO: Document\n  async clearAllStorageEngines() {\n    await Promise.all(\n      this.getStorageEngines().map(storageEngine => storageEngine.clear())\n    );\n  }\n}\n\nclass StorageEngineCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(StorageEngineClass) {\n    if (this.getChildWithKey(StorageEngineClass)) {\n      throw new ReferenceError(\"StorageEngineClass is already registered\");\n    }\n\n    // TODO: Ensure title is set and unique across instances\n\n    const storageEngine = new StorageEngineClass();\n\n    // FIXME: (jh) Even better would be to check this before instantiation, but\n    // I'm not quite sure how to yet\n    if (!(storageEngine instanceof StorageEngine)) {\n      throw new TypeError(\"storageEngine is not of StorageEngine type\");\n    }\n\n    return super.addChild(storageEngine, StorageEngineClass);\n  }\n\n  // TODO: Document\n  removeChild(StorageEngineClass) {\n    const storageEngine = this.getChildWithKey(StorageEngineClass);\n\n    if (storageEngine) {\n      storageEngine.destroy();\n    }\n  }\n\n  // TODO: Document\n  addStorageEngineClass(StorageEngineClass) {\n    return this.addChild(StorageEngineClass);\n  }\n\n  // TODO: Document\n  removeStorageEngineClass(StorageEngineClass) {\n    return this.removeChild(StorageEngineClass);\n  }\n\n  // TODO: Document\n  getStorageEngines() {\n    return this.getChildren();\n  }\n}\n","import KeyVaultService from \"./KeyVaultService\";\n\nexport default KeyVaultService;\n","import classNames from \"classnames\";\nimport PropTypes from \"prop-types\";\nimport React, { Component } from \"react\";\n\n// NOTE: This intentionally does not make use of *.module.css because it also\n// includes internal styling for the html and body tags\n//\n// TODO: Maybe this can work for adding module support w/ global styles?  https://stackoverflow.com/a/40065474\nimport \"./FullViewport.css\";\n\nconst EVT_RESIZE = \"resize\";\nconst EVT_TOUCH_MOVE = \"touchmove\";\nconst EVT_TOUCH_END = \"touchend\";\n\n/**\n * A React Component which utilizes the entire viewport (or what is available\n * beyond the window chrome) of the device.\n *\n * It helps solve layout issues related to mobile layouts (especially on iOS,\n * where the viewport size can change depending if URL bar is shown or hidden),\n * by explicitly setting widths and heights in pixels, so that child elements\n * can utilize size percentages (i.e. height=\"100%\") and fully consume\n * available container layout area.\n *\n * This component is intended to be a direct descendant (or at least near-\n * direct descendant) to the DOM's <body> tag, and works best if the\n * underlying CSS for html & body are not padded, nor have margins.\n *\n * The entire application should be rendered within this component for best\n * results.\n */\nexport default class FullViewport extends Component {\n  static propTypes = {\n    onResize: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this._ref = null;\n    this._pollingInterval = null;\n    this._pollingTime = 1000; // In milliseconds\n\n    this._lastPollWidth = 0;\n    this._lastPollHeight = 0;\n  }\n\n  componentDidMount() {\n    this._handleViewportResize();\n\n    /**\n     * IMPORTANT: passive: false is extremely important or else when moving\n     * finger on mobile Safari the page will bounce around\n     *\n     * @see https://stackoverflow.com/a/49853392\n     */\n    window.addEventListener(EVT_TOUCH_MOVE, this._handleTouchMove, {\n      passive: false,\n    });\n\n    window.addEventListener(EVT_RESIZE, this._handleViewportResize);\n    window.addEventListener(EVT_TOUCH_END, this._handleTap);\n\n    // TODO: Document why this is needed\n    this._pollingInterval = setInterval(\n      this._handleViewportResize,\n      this._pollingTime\n    );\n\n    // Dynamically add .full-viewport to html / body elements\n    document.documentElement.classList.add(\"full-viewport\");\n    document.body.classList.add(\"full-viewport\");\n  }\n\n  componentWillUnmount() {\n    // Dynamically remove .full-viewport from html / body elements\n    document.documentElement.classList.remove(\"full-viewport\");\n    document.body.classList.remove(\"full-viewport\");\n\n    window.removeEventListener(EVT_TOUCH_MOVE, this._handleTouchMove);\n    window.removeEventListener(EVT_RESIZE, this._handleViewportResize);\n    window.removeEventListener(EVT_TOUCH_END, this._handleTap);\n\n    clearInterval(this._pollingInterval);\n  }\n\n  componentDidUpdate() {\n    this._handleViewportResize();\n  }\n\n  _handleTouchMove = evt => {\n    evt.preventDefault();\n  };\n\n  /**\n   * Prevents double-tap zooming on iOS.\n   *\n   * Note: Source adapted from https://exceptionshub.com/disable-double-tap-zoom-option-in-browser-on-touch-devices.html\n   *\n   * @param {DocumentEvent} evt Event of touchend type\n   */\n  _handleTap = evt => {\n    const t2 = evt.timeStamp;\n    const t1 = evt.currentTarget.__lastTouch || t2;\n    const dt = t2 - t1;\n    const fingers = evt.touches.length;\n    evt.currentTarget.__lastTouch = t2;\n\n    if (!dt || dt > 500 || fingers > 1) {\n      // Not double-tap\n    } else {\n      // Prevent double-tap zoom\n      evt.preventDefault();\n    }\n  };\n\n  /**\n   * Note: Automatic viewport resizing is called as either a window resizing\n   * event callback, or at a set interval time.\n   *\n   * Depending on whether it is called with an event object, the method will\n   * adapt its handling accordingly.\n   *\n   * @param {DocumentEvent} evt? [default = null] If no evt is passed, it is in\n   * polling mode.\n   */\n  _handleViewportResize = (evt = null) => {\n    if (!this._ref) {\n      return;\n    }\n\n    // TODO: Document\n    const isInPollingMode = evt ? false : true;\n\n    // Fixes issue where text input fields can disappear behind mobile keyboard\n    // when in use\n    // FIXME: Don't run following code block unless on mobile, w/ software\n    // keyboard enabled\n    if (\n      isInPollingMode &&\n      document.activeElement &&\n      [\"INPUT\", \"TEXTAREA\"].includes(document.activeElement.tagName)\n    ) {\n      return;\n    }\n\n    // Fixes issue on iOS where the content may be behind the URL bar\n    document.body.scrollTop = 0;\n\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    // If the width or height hasn't changed since the last poll interval, do\n    // nothing\n    if (\n      isInPollingMode &&\n      width === this._lastPollWidth &&\n      height === this._lastPollHeight\n    ) {\n      return;\n    } else {\n      this._lastPollWidth = width;\n      this._lastPollHeight = height;\n    }\n\n    this._ref.style.width = `${width}px`;\n    this._ref.style.height = `${height}px`;\n\n    if (typeof this.props.onResize === \"function\") {\n      this.props.onResize({\n        width,\n        height,\n      });\n    }\n  };\n\n  render() {\n    let { children, className, onResize, ...propsRest } = this.props;\n\n    return (\n      <div\n        ref={c => (this._ref = c)}\n        {...propsRest}\n        className={classNames(\"full-viewport\", className)}\n      >\n        {children}\n      </div>\n    );\n  }\n}\n","import FullViewport from './FullViewport';\n\nexport default FullViewport;","import React from \"react\";\n\nexport const ParadigmContext = React.createContext({});\n\n// TODO: Add desktop paradigm\n// TODO: Add mobile paradigm (half-quadrant snapping; scroll dock / scroll side-by-side-apps / views able to be split vertically / horizontally, and windows able to be dragged into quadrants / scaling optional)\n\nexport default function ParadigmProvider({ children }) {\n  // TODO: Work out paradigm values; use PhantomCollection for paradigm management\n  return (\n    <ParadigmContext.Provider value={{}}>{children}</ParadigmContext.Provider>\n  );\n}\n","import BaseView from \"./BaseView\";\n\nexport default BaseView;\n","import { useEffect, useState } from \"react\";\nimport FullViewport from \"@components/FullViewport\";\n\nimport ParadigmProvider from \"./providers/ParadigmProvider\";\nimport UIServicesProvider from \"./providers/UIServicesProvider\";\nimport AppRegistrationsProvider from \"./providers/AppRegistrationsProvider\";\nimport AppRuntimesProvider from \"./providers/AppRuntimesProvider\";\nimport DesktopProvider from \"./providers/DesktopProvider\";\n\n// TODO: Document and add prop-types\nexport default function BaseView({ portal }) {\n  const [areBaseStylesLoaded, setAreBaseStylesLoaded] = useState(false);\n\n  useEffect(() => {\n    // Lazy-load BaseView style so it doesn't override before the app is mounted\n    //\n    // TODO: Use preload\n    import(\"./base-styles.css\")\n      .then(() => setAreBaseStylesLoaded(true))\n      .catch(err => console.error(err));\n  }, []);\n\n  if (!areBaseStylesLoaded) {\n    return null;\n  }\n\n  const PortalView = portal;\n  return (\n    <FullViewport>\n      <ParadigmProvider>\n        <UIServicesProvider>\n          <AppRegistrationsProvider>\n            <AppRuntimesProvider>\n              <DesktopProvider>\n                <PortalView />\n              </DesktopProvider>\n            </AppRuntimesProvider>\n          </AppRegistrationsProvider>\n        </UIServicesProvider>\n      </ParadigmProvider>\n    </FullViewport>\n  );\n}\n","import \"@core/startupHelpers\";\n\nimport PhantomCore from \"phantom-core\";\nimport React, { Suspense } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport UIServiceCollection from \"../classes/UIServiceCollection\";\nimport KeyVaultService from \"@services/KeyVaultService\";\n\nimport BaseView from \"../BaseView\";\n\nimport queryString from \"query-string\";\n\nconst KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME = \"reshell-default-portal\";\n\n// TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\nlet _instance = null;\n\nexport default class ReShellCore extends PhantomCore {\n  // TODO: Document\n  static #portals = {};\n\n  // TODO: Document\n  static registerPortals(portals) {\n    ReShellCore.#portals = portals;\n  }\n\n  // TODO: Document\n  static getPortals() {\n    return ReShellCore.#portals;\n  }\n\n  // TODO: Document\n  static async init(portalName = null) {\n    return new ReShellCore(portalName);\n  }\n\n  constructor(portalName = null) {\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    if (_instance) {\n      throw new ReferenceError(\n        \"UIServiceCollection cannot have multiple instances\"\n      );\n    }\n\n    super({\n      isReady: false,\n    });\n\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = this;\n\n    this._uiServiceCollection = new UIServiceCollection();\n    this._uiServiceCollection.startServiceClass(KeyVaultService);\n\n    // TODO: Bind window \"beforeunload\" event to try to prevent accidental shut\n    // down before we have a chance to save states, etc. Ensure it gets unbound\n    // before the destructor finishes.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload\n\n    this._init(portalName);\n  }\n\n  // TODO: Document\n  async _init(portalName) {\n    const sessionStorageEngine = this._uiServiceCollection\n      .getService(KeyVaultService)\n      .getSessionStorageEngine();\n\n    // If no portalName is passed and there is a session storage (not local) variable set for portal, use it\n    if (!portalName) {\n      portalName =\n        // Retrieve portal name from session storage\n        (await sessionStorageEngine.fetchItem(\n          KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME\n        )) || \"default\";\n    }\n\n    const portal = ReShellCore.#portals[portalName];\n\n    if (!portal) {\n      throw new ReferenceError(\n        `Unable to init portal with name: ${portalName}`\n      );\n    }\n\n    // Save portal name in session storage\n    sessionStorageEngine.setItem(\n      KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME,\n      portalName\n    );\n\n    this._activePortalName = portalName;\n\n    // Wipe existing content\n    document.body.innerHTML = \"\";\n\n    // Wipe existing styling\n    [...document.getElementsByTagName(\"style\")].forEach(elStyle =>\n      elStyle.parentNode.removeChild(elStyle)\n    );\n\n    this._elBase = document.createElement(\"div\");\n    document.body.appendChild(this._elBase);\n\n    ReactDOM.render(\n      <React.StrictMode>\n        <Suspense fallback={<div />}>\n          <BaseView portal={portal} />\n        </Suspense>\n      </React.StrictMode>,\n      this._elBase\n    );\n\n    // TODO: Use KeyVaultService sub-service to open any previously\n    // closed windows and retain their window positions for this portal\n    // @see https://developer.apple.com/design/human-interface-guidelines/macos/app-architecture/restoring-state/\n\n    super._init();\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // TODO: Shut down running apps first, and provide a way to cancel out of\n    // shut-down in case we need to save any states\n\n    // Unrender DOM\n    // Stop the current UI\n    ReactDOM.render(<div>[Tear down]</div>, this._elBase);\n\n    await this._uiServiceCollection.destroy();\n\n    const ret = await super.destroy();\n\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = null;\n\n    return ret;\n  }\n\n  // TODO: Document\n  static async destroy() {\n    return _instance?.destroy();\n  }\n\n  // TODO: Document\n  static async reload() {\n    await _instance?.destroy();\n\n    window.location.reload();\n  }\n\n  // TODO: Document\n  async switchToPortal(portalName) {\n    const sessionStorageEngine = this._uiServiceCollection\n      .getService(KeyVaultService)\n      .getSessionStorageEngine();\n\n    // Cache portalName to the session storage\n    await sessionStorageEngine.setItem(\n      KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME,\n      portalName\n    );\n\n    await this.destroy();\n\n    const urlQuery = queryString.stringify({ portalName });\n\n    window.location.href = `?${urlQuery}`;\n  }\n\n  // TODO: Document\n  static async switchToPortal(portalName) {\n    await _instance?.switchToPortal(portalName);\n  }\n\n  // TODO: Document\n  getUIServiceCollection() {\n    return this._uiServiceCollection;\n  }\n\n  // TODO: Document\n  static getUIServiceCollection() {\n    return _instance?.getUIServiceCollection();\n  }\n\n  // TODO: Document\n  getPortalName() {\n    return this._activePortalName;\n  }\n\n  // TODO: Document\n  static getPortalName() {\n    return _instance?.getPortalName();\n  }\n}\n\n// Auto-init if query string\n// TODO: Refactor\n(() => {\n  if (!_instance) {\n    // IMPORTANT: This setTimeout (or any other async equiv.) is necessary to\n    // allow the parsing of registerPortals.js before trying to run the init on\n    // them\n    //\n    // Works in conjuction with ReShellCore.switchToPortal static method.\n    //\n    // TODO: Use setImmediate / microtask / other async (use in PhantomCore)\n    // @see [nextTick vs setImmediate] https://stackoverflow.com/a/15349865\n    // @see [MDN recommended setImmediate polyfill] https://github.com/YuzuJS/setImmediate/blob/master/setImmediate.js\n    setTimeout(() => {\n      const urlQuery = queryString.parse(window.location.search);\n\n      const { portalName } = urlQuery;\n\n      if (portalName) {\n        // ReShellCore.init(portalName);\n      }\n    });\n  }\n})();\n","import { PhantomCollection } from \"phantom-core\";\nimport UIServiceCore from \"@core/classes/UIServiceCore\";\n\nconst {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} = PhantomCollection;\n\nexport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n  EVT_UPDATED,\n  EVT_DESTROYED,\n};\n\n// TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\nlet _instance = null;\n\n// IMPORTANT: This must be treated as a singleton for desktop usage\n// TODO: Document\nexport default class UIServiceCollection extends PhantomCollection {\n  constructor(...args) {\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    if (_instance) {\n      throw new ReferenceError(\n        \"UIServiceCollection cannot have multiple instances\"\n      );\n    }\n\n    super(...args);\n\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = this;\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // Destruct all services on collection destruc\n    await this.destroyAllChildren();\n\n    const ret = await super.destroy();\n\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = null;\n\n    return ret;\n  }\n\n  // TODO: Document\n  addChild(service, ServiceClass) {\n    if (!(service instanceof UIServiceCore)) {\n      throw new TypeError(\"service is not a UIServiceCore instance\");\n    }\n\n    return super.addChild(service, ServiceClass);\n  }\n\n  // TODO: Document\n  // TODO: Refactor most of this into addChild, directly\n  // IMPORTANT: Making this async might be more trouble than its worth, if that\n  // is ever a consideration\n  startServiceClass(ServiceClass) {\n    const cachedService = this.getChildWithKey(ServiceClass);\n\n    if (cachedService) {\n      return cachedService;\n    }\n\n    // Bind functionality to the service to be able to use other services,\n    // using this service collection as the backend\n    //\n    // NOTE: This was engineered this way in order to not have to pass\n    // arguments to the ServiceClass itself, thus making it easier to extend\n    // services without having to think about needed constructor arguments\n    ServiceClass.prototype._useServiceHandler = ServiceClass =>\n      this.useService(ServiceClass);\n\n    // NOTE: Services are instantiated with the collection without arguments,\n    // but may pass arguments down to the base ServiceCore class (i.e. for\n    // setting initial state) in extension classes.  The extension classes\n    // themselves won't be instantiated with any arguments set, however, by the\n    // collection.\n    const service = new ServiceClass();\n\n    this.addChild(service, ServiceClass);\n\n    return service;\n  }\n\n  // TODO: Document\n  async stopServiceClass(ServiceClass) {\n    const cachedService = this.getChildWithKey(ServiceClass);\n\n    if (cachedService) {\n      cachedService.destroy();\n    }\n  }\n\n  // TODO: Document\n  useService(ServiceClass) {\n    const cachedService = this.getChildWithKey(ServiceClass);\n\n    if (cachedService) {\n      return cachedService;\n    } else {\n      return this.addServiceClass(ServiceClass);\n    }\n  }\n\n  // TODO: Document\n  getService(ServiceClass) {\n    const cachedService = this.getChildWithKey(ServiceClass);\n\n    return cachedService;\n  }\n}\n","import React, { useCallback, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceCollection\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n// TODO: Document\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  // const [_uiServiceCollection, _setUIServiceCollection] = useState(null);\n  // TODO: Refactor into useEffect; fix destruct error where React can't perform state update on unmounted component\n  const _uiServiceCollection = useMemo(() => {\n    const serviceCollection = ReShellCore.getUIServiceCollection();\n\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This timeout is to prevent trying to re-render while a\n      // child component is being updated (i.e. WindowManager currently is\n      // instantiating services during the render cycle)\n      setTimeout(() => {\n        forceUpdate();\n      });\n    };\n\n    // TODO: Unbind on teardown\n    serviceCollection.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    // TODO: Unbind on teardown\n    serviceCollection.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return serviceCollection;\n  }, [forceUpdate]);\n\n  // TODO: Document\n  const startService = useCallback(\n    ServiceClass => _uiServiceCollection.startServiceClass(ServiceClass),\n    [_uiServiceCollection]\n  );\n\n  // TODO: Document\n  const stopService = useCallback(\n    ServiceClass => _uiServiceCollection.stopServiceClass(ServiceClass),\n    [_uiServiceCollection]\n  );\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceCollection && _uiServiceCollection.getChildren(),\n        startService,\n        stopService,\n      }}\n    >\n      {\n        // TODO: For services which contain internal providers, render those providers here, wrapping the children with them\n      }\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // FIXME: (jh) The only way I could get this to sort alphabetically on\n    // Firefox was to build a reverse-sorted list, then reverse it again;\n    // Chrome was not affected by this\n    return this.getChildren()\n      .sort((a, b) => {\n        const aTitle = a.getTitle();\n        const bTitle = b.getTitle();\n\n        if (aTitle < bTitle) {\n          return 1;\n        } else if (bTitle > aTitle) {\n          return -1;\n        } else {\n          return 0;\n        }\n      })\n      .reverse();\n  }\n}\n","import React, { useCallback, useEffect, useState } from \"react\";\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection, {\n  EVT_UPDATED,\n} from \"./classes/AppRegistrationCollection\";\n\nexport const AppRegistrationsContext = React.createContext({});\n\n// TODO: Refactor into a service\nexport default function AppRegistrationsProvider({ children }) {\n  const [appRegistrations, _setAppRegistrations] = useState([]);\n  const [_appRegistrationCollection, _setAppRegistrationCollection] =\n    useState(null);\n\n  // Sync app registrations state with that of internal collection\n  useEffect(() => {\n    const appCollection = new AppRegistrationCollection();\n    _setAppRegistrationCollection(appCollection);\n\n    const _handleAppRegistrationsUpdated = () => {\n      _setAppRegistrations(appCollection.getAppRegistrations());\n    };\n\n    appCollection.on(EVT_UPDATED, _handleAppRegistrationsUpdated);\n\n    return function unmount() {\n      appCollection.destroy();\n    };\n  }, []);\n\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  const addOrUpdateAppRegistration = useCallback(\n    appDescriptor => {\n      const appRegistration =\n        AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n      _appRegistrationCollection.addAppRegistration(appRegistration);\n    },\n    [_appRegistrationCollection]\n  );\n\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  const removeAppRegistration = useCallback(\n    appDescriptorOrID => {\n      // NOTE: This should also remove it from the collection\n      AppRegistration.removeAppRegistration(appDescriptorOrID);\n    },\n\n    []\n  );\n\n  // TODO: Document\n  const getAppRegistrationTitle = useCallback(\n    appDescriptorID => {\n      const appRegistration = appRegistrations.find(\n        predicate => predicate.getID() === appDescriptorID\n      );\n\n      if (!appRegistration) {\n        console.warn(\n          `Could not locate appRegistration with id: ${appDescriptorID}`\n        );\n      } else {\n        return appRegistration.getTitle();\n      }\n    },\n    [appRegistrations]\n  );\n\n  return (\n    <AppRegistrationsContext.Provider\n      value={{\n        addOrUpdateAppRegistration,\n        removeAppRegistration,\n        appRegistrations,\n        getAppRegistrationTitle,\n      }}\n    >\n      {children}\n    </AppRegistrationsContext.Provider>\n  );\n}\n","import AppRegistrationsProvider, {\n  AppRegistrationsContext,\n} from \"./AppRegistrationsProvider\";\n\nexport default AppRegistrationsProvider;\nexport { AppRegistrationsContext };\n","import ReShellCore from \"../classes/ReShellCore\";\n\n/**\n * @global\n */\nwindow.ReShell = ReShellCore;\n","import ReShellCore from \"./classes/ReShellCore\";\nimport \"./globals\";\n\nexport default ReShellCore;\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"../../AppRegistrationsProvider/classes/AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to set default environment here\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, () => {\n      this.emit(EVT_UPDATED);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOn(this._appRegistration, EVT_DESTROYED, () => {\n      this.destroy();\n    });\n\n    this._windowController = null;\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRuntime from \"../classes/AppRuntime\";\nimport AppRuntimeCollection from \"../classes/AppRuntimeCollection\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the starting, stopping, and collection of AppRuntimes.\n */\nexport default class AppRuntimeOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor() {\n    super();\n\n    this.setTitle(\"AppRuntime Orchestration Service\");\n\n    this.bindCollectionClass(AppRuntimeCollection);\n  }\n\n  // TODO: Document\n  startAppRuntime(appDescriptor) {\n    const appRuntime = new AppRuntime(appDescriptor);\n\n    this.getCollectionInstance(AppRuntimeCollection).addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  // TODO: Document\n  // Helper method; does not have to be called directly on this service if\n  // destructing the instance directly\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  // TODO: Document\n  getAppRuntimes() {\n    return this.getCollectionInstance(AppRuntimeCollection).getAppRuntimes();\n  }\n}\n","import React, { useCallback, useContext, useEffect, useMemo } from \"react\";\nimport AppRuntimeOrchestrationService, {\n  EVT_UPDATED,\n} from \"./services/AppRuntimeOrchestrationService\";\n\nimport { AppRegistrationsContext } from \"../AppRegistrationsProvider\";\n\nimport { UIServicesContext } from \"../UIServicesProvider\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nexport const AppRuntimesContext = React.createContext({});\n\n// TODO: Document\nexport default function AppRuntimesProvider({ children }) {\n  const { appRegistrations } = useContext(AppRegistrationsContext);\n\n  const { startService } = useContext(UIServicesContext);\n  const forceUpdate = useForceUpdate();\n\n  // TODO: Document\n  const appOrchestrationService = useMemo(\n    () => startService(AppRuntimeOrchestrationService),\n    [startService]\n  );\n\n  // TODO: Document\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n\n  // TODO: Import type definition\n  /** @type {AppRegistration[]} */\n  const runningRegistrations = useMemo(\n    () => appRuntimes.map(runtime => runtime.getRegistration()),\n    [appRuntimes]\n  );\n\n  // TODO: Document\n  useEffect(() => {\n    appOrchestrationService.on(EVT_UPDATED, forceUpdate);\n\n    return function unmount() {\n      appOrchestrationService.off(EVT_UPDATED, forceUpdate);\n    };\n  }, [appOrchestrationService, forceUpdate]);\n\n  // TODO: Document\n  const startAppRuntime = useCallback(\n    appRegistration => {\n      return appOrchestrationService.startAppRuntime(appRegistration);\n    },\n    [appOrchestrationService]\n  );\n\n  // TODO: Merge with startAppRuntime after descriptors can specify multiple\n  // window support\n  const bringToFrontOrStartAppRuntime = useCallback(\n    appRegistration => {\n      if (!runningRegistrations.includes(appRegistration)) {\n        // TODO: Open app w/ registration\n        startAppRuntime(appRegistration);\n      } else {\n        // Move grouped windows to top\n        // TODO: Order by window manager stacking order (most recently used\n        // window in group should appear in top)\n        // TODO: Refactor into window manager?\n        appRuntimes\n          .filter(runtime => runtime.getRegistration() === appRegistration)\n          .forEach(runtime => runtime.bringToTop());\n      }\n    },\n    [runningRegistrations, appRuntimes, startAppRuntime]\n  );\n\n  // TODO: Document (for linking to other windows)\n  const switchToAppRegistrationID = useCallback(\n    appRegistrationID => {\n      const appRegistration = appRegistrations.find(\n        predicate => predicate.getID() === appRegistrationID\n      );\n\n      if (!appRegistration) {\n        console.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n      } else {\n        bringToFrontOrStartAppRuntime(appRegistration);\n      }\n    },\n    [appRegistrations, bringToFrontOrStartAppRuntime]\n  );\n\n  // TODO: Document\n  const stopAppRuntime = useCallback(\n    appRegistration => {\n      return appOrchestrationService.stopAppRuntime(appRegistration);\n    },\n    [appOrchestrationService]\n  );\n\n  // TODO: Document\n  const getAppRuntimesWithRegistrationID = useCallback(\n    registrationID =>\n      appRuntimes.filter(\n        appRuntime => appRuntime.getRegistrationID() === registrationID\n      ),\n    [appRuntimes]\n  );\n\n  // TODO: Document\n  useAppRuntimesAutoStart({\n    appRegistrations,\n    startAppRuntime,\n  });\n\n  return (\n    <AppRuntimesContext.Provider\n      value={{\n        startAppRuntime,\n        stopAppRuntime,\n        appRuntimes,\n        getAppRuntimesWithRegistrationID,\n        runningRegistrations,\n        bringToFrontOrStartAppRuntime,\n        switchToAppRegistrationID,\n      }}\n    >\n      {children}\n    </AppRuntimesContext.Provider>\n  );\n}\n","import AppRuntimesProvider, { AppRuntimesContext } from \"./AppRuntimesProvider\";\n\nexport default AppRuntimesProvider;\nexport { AppRuntimesContext };\n","import { useEffect, useRef } from \"react\";\n\n// TODO: Document\nexport default function useAppRuntimesAutoStart({\n  appRegistrations,\n  startAppRuntime,\n}) {\n  const refHasAutoStarted = useRef(false);\n\n  // Automatically start registrations with isAutoStart set to true\n  useEffect(() => {\n    // NOTE: This timeout fixes an issue where two or more registrations could\n    // not open at once\n    const openTimeout = setTimeout(() => {\n      if (appRegistrations.length && !refHasAutoStarted.current) {\n        // FIXME: (jh) The reversed registrations seems to open apps in forward\n        // order, based on how they are defined in the desktop array.  I\n        // haven't done a lot of testing against this, so this may need to be\n        // redefined as necessary\n        for (const registration of [...appRegistrations].reverse()) {\n          if (registration.getIsAutoStart()) {\n            startAppRuntime(registration);\n          }\n        }\n\n        refHasAutoStarted.current = true;\n      }\n    });\n\n    return function unmount() {\n      clearTimeout(openTimeout);\n    };\n  }, [appRegistrations, startAppRuntime]);\n}\n","import { EVT_UPDATED } from \"phantom-core\";\nimport { useEffect, useState } from \"react\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n// import useServicesContext from \"@hooks/useServicesContext\";\n// import AppRuntimeOrchestrationService from \"../../AppRuntimesProvider/services/AppRuntimeOrchestrationService\";\n\n// TODO: Refactor [native] window title setting\nconst DEFAULT_DOCUMENT_TITLE = document.title;\n\n// TODO: [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n// TODO: Document\nexport default function useActiveWindowController() {\n  const [activeWindowController, setActiveWindowController] = useState(null);\n  // const [backgroundVideoMediaStreamTrack, setBackgroundVideoMediaStreamTrack] = useState(null);\n\n  /*\n  const appOrchestrationService = useServiceClass(\n    AppRuntimeOrchestrationService\n  );\n  */\n\n  // TODO: Remove\n  // TODO: Mirror active window controller w/ AppRuntimeOrchestrationService (maybe have useActiveWindowController reflect orchestration state)\n  // const { services } = useServicesContext();\n  // console.log({ services });\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // TODO: Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = DEFAULT_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${DEFAULT_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update\n        forceDesktopUpdate();\n      }\n    };\n\n    _handleUpdate();\n\n    if (activeWindowController) {\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n\n  return {\n    activeWindowController,\n    setActiveWindowController,\n  };\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\nexport default class BackgroundAssetCollection extends PhantomCollection {\n  // TODO: Document\n  addBackgroundAsset(backgroundAsset) {\n    return this.addChild(backgroundAsset);\n  }\n\n  // TODO: Document\n  removeBackgroundAsset(backgroundAsset) {\n    return this.removeChild(backgroundAsset);\n  }\n\n  // TODO: Document\n  getBackgroundAssets() {\n    return this.getChildren();\n  }\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\nimport useBackgroundAssetCollection from \"./hooks/useBackgroundAssetCollection\";\n\nexport const DesktopContext = React.createContext({});\n\nexport default function DesktopProvider({ children }) {\n  const { activeWindowController, setActiveWindowController } =\n    useActiveWindowController();\n  const { backgroundAssets, addBackgroundAsset, removeBackgroundAsset } =\n    useBackgroundAssetCollection();\n\n  return (\n    <DesktopContext.Provider\n      value={{\n        activeWindowController,\n        setActiveWindowController,\n\n        backgroundAssets,\n        addBackgroundAsset,\n        removeBackgroundAsset,\n      }}\n    >\n      {children}\n    </DesktopContext.Provider>\n  );\n}\n","import DesktopProvider, { DesktopContext } from \"./DesktopProvider\";\n\nexport default DesktopProvider;\nexport { DesktopContext };\n","import { useCallback, useEffect, useState } from \"react\";\nimport BackgroundAssetCollection, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"../classes/BackgroundAssetCollection\";\n\nexport default function useBackgroundAssetCollection() {\n  const [assetCollection, setAssetCollection] = useState(null);\n  const [backgroundAssets, setBackgroundAssets] = useState([]);\n\n  useEffect(() => {\n    const assetCollection = new BackgroundAssetCollection();\n\n    setAssetCollection(assetCollection);\n\n    assetCollection.once(EVT_DESTROYED, () => {\n      setAssetCollection(null);\n    });\n\n    setBackgroundAssets(assetCollection.getBackgroundAssets());\n    assetCollection.on(EVT_UPDATED, () =>\n      setBackgroundAssets(assetCollection.getBackgroundAssets())\n    );\n\n    return function unmount() {\n      assetCollection.destroy();\n    };\n  }, []);\n\n  // TODO: Document\n  const addBackgroundAsset = useCallback(\n    backgroundAsset => assetCollection.addBackgroundAsset(backgroundAsset),\n    [assetCollection]\n  );\n\n  // TODO: Document\n  const removeBackgroundAsset = useCallback(\n    backgroundAsset => assetCollection.removeBackgroundAsset(backgroundAsset),\n    [assetCollection]\n  );\n\n  return {\n    backgroundAssets,\n    addBackgroundAsset,\n    removeBackgroundAsset,\n  };\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReShellCore from \"./core\";\n\n// The portals defined here are what are selectable inside of the application\nconst portals = {\n  default: React.lazy(() => import(\"@portals/ReShell.org\")),\n\n  /*\n  default: React.lazy(() => import(\"@portals/SpeakerAppPortal\")),\n\n  ReShellOrg: React.lazy(() => import(\"@portals/ReShell.org\")),\n\n  example: React.lazy(() => import(\"@portals/ExamplePortal\")),\n\n  test: React.lazy(() => import(\"@portals/TestPortal\")),\n  */\n};\n\nReShellCore.registerPortals(portals);\n\n// TODO: Include ability to parse out an HTML file and dynamically link it to\n// the public directory during runtime (and during build) for SEO\n\n// TODO: Enable any application to include about info, metadata, so that they\n// can be included in SEO\n\n// TODO: Don't automatically initialize ReShell when a search engine is\n// detected (i.e. look for various JS properties a search engine might not\n// exhibit and test if those capabilities exist in order to determine if a\n// search engine or not)\n\n// TODO: Try to not get too fancy with SEO pages, and keep them mostly HTML,\n// with JS assets sprinkled in to be able to open relevant parts of ReShell\n// when needed, if it is not automatically initialized\n","import reportWebVitals from \"./reportWebVitals\";\n\nimport \"./registerPortals\";\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n//\n// Additional reading for \"name\" element:\n//  - [FCP] https://web.dev/fcp/\n//  - [TTFB] https://web.dev/time-to-first-byte/\n//  - [FID] https://web.dev/fid/\n//  - [CLS] https://web.dev/cls/\nreportWebVitals(({ id, name, value }) => {\n  // TODO: Remove\n  console.log({\n    webVitalsReport: {\n      id,\n      name,\n      value,\n    },\n  });\n});\n"],"sourceRoot":""}