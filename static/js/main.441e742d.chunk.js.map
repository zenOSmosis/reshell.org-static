{"version":3,"sources":["services/BrowserShutdownInterceptorService.js","services/LocalDeviceIdentificationService.js","core/BaseView/index.jsx","core/BaseView/BaseView.jsx","utils/getReShellVersion.js","core/classes/ReShellCore.js","core/globals/window.ReShell.js","core/index.js","core/classes/UIServiceManager.js","utils/fetchIsLatestVersion.js","core/startupHelpers.js","reportWebVitals.js","__registerPortals__.js","index.js","core/classes/UIServiceCore.js","services/KeyVaultService/engines/_BaseStorageEngine.js","services/KeyVaultService/engines/SessionStorageEngine.js","services/KeyVaultService/engines/SecureLocalStorageEngine.js","services/KeyVaultService/KeyVaultService.js","services/KeyVaultService/index.js"],"names":["BrowserShutdownInterceptorService","args","setTitle","window","onbeforeunload","evt","preventDefault","registerCleanupHandler","UIServiceCore","getInMemoryLocalIdentity","setInMemoryLocalIdentity","localIdentity","LocalDeviceIdentificationService","_keyVaultService","useServiceClass","KeyVaultService","a","this","fetchLocalIdentity","inMemoryLocalIdentity","secureLocalStorageEngine","getSecureLocalStorageEngine","fetchItem","_generateLocalIdentity","setItem","EthCrypto","createIdentity","address","privateKey","publicKey","ReferenceError","fetchLocalAddress","BaseView","portal","useState","areBaseStylesLoaded","setAreBaseStylesLoaded","useEffect","then","catch","err","console","error","PortalWrapper","useMemo","React","lazy","Suspense","fallback","version","KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME","_instance","ReShellCore","portalName","isAsync","_uiServiceManager","UIServiceManager","startServiceClass","_init","sessionStorageEngine","getServiceInstance","getSessionStorageEngine","fetchIsLatestVersion","isLatest","confirm","forceUpdate","localDeviceIdentificationService","initLocalIdentity","_activePortalName","document","body","children","forEach","child","tagName","toUpperCase","parentNode","removeChild","existingStyles","getElementsByTagName","setTimeout","elStyle","_elBase","createElement","appendChild","ReactDOM","render","StrictMode","destroy","ret","urlQuery","queryString","stringify","location","href","getUIServiceManager","getPortalName","getReShellVersion","Date","getTime","portals","reload","switchToPortal","PhantomCore","ReShell","EVT_CHILD_INSTANCE_ADDED","PhantomServiceManager","EVT_CHILD_INSTANCE_REMOVED","EVT_UPDATED","EVT_DESTROYED","ours","_getStaticTags","axios","get","response","domParser","DOMParser","resultDOM","parseFromString","data","theirs","length","Error","src","includes","dom","jsTags","staticJsTagSrcs","filter","tag","getAttribute","startsWith","map","dayjs","require","relativeTime","extend","localizedFormat","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","default","registerPortals","id","name","value","log","webVitalsReport","PhantomServiceCore","BaseStorageEngine","options","DEFAULT_OPTIONS","encryptionType","mergeOptions","_encryptionType","getOptions","getEncryptionType","key","SessionStorageEngine","sessionStorage","emit","removeItem","getItem","Object","keys","clear","SecureLocalStorageEngine","_ls","SecureLS","encodingType","set","remove","getAllKeys","undefined","_storageEngineCollection","bindCollectionClass","StorageEngineCollection","proxyOn","addStorageEngineClass","storageEngines","getStorageEngines","keyStorageEngineMaps","storageEngine","fetchKeys","push","fetchKeyStorageEngineMaps","StorageEngineClass","removeStorageEngineClass","getChildren","getStorageEngineWithShortUUID","shortUUID","find","predicate","getShortUUID","getChildWithKey","Promise","all","addChild","TypeError","PhantomCollection"],"mappings":"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","file":"static/js/main.441e742d.chunk.js","sourcesContent":["import UIServiceCore from \"@core/classes/UIServiceCore\";\n\n/**\n * Provides basic shutdown handling interception.\n */\nexport default class BrowserShutdownInterceptorService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Browser Shutdown Interceptor Service\");\n\n    window.onbeforeunload = evt => {\n      evt.preventDefault();\n\n      return false;\n    };\n\n    this.registerCleanupHandler(() => {\n      window.onbeforeunload = null;\n    });\n  }\n}\n","import UIServiceCore from \"@core/classes/UIServiceCore\";\nimport KeyVaultService from \"./KeyVaultService\";\nimport EthCrypto from \"eth-crypto\";\n\n// TODO: Refactor\nconst LS_KEY_DEVICE_IDENTIFICATION = \"id0\";\n\nconst { getInMemoryLocalIdentity, setInMemoryLocalIdentity } = (() => {\n  let localIdentity = null;\n\n  return {\n    getInMemoryLocalIdentity: () => localIdentity,\n    setInMemoryLocalIdentity: localIdentity => localIdentity,\n  };\n})();\n\n// TODO: Implement public key compression / decompression?\n\n// TODO: Document\nexport default class LocalDeviceIdentificationService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Local Device Identification Service\");\n\n    this._keyVaultService = this.useServiceClass(KeyVaultService);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async initLocalIdentity() {\n    // NOTE: We're not concerned about returning the identity itself here, just\n    // initializing it\n    await this.fetchLocalIdentity();\n  }\n\n  // TODO: Document\n  async fetchLocalIdentity() {\n    const inMemoryLocalIdentity = getInMemoryLocalIdentity();\n\n    if (inMemoryLocalIdentity) {\n      return inMemoryLocalIdentity;\n    } else {\n      const secureLocalStorageEngine =\n        this._keyVaultService.getSecureLocalStorageEngine();\n\n      let localIdentity = await secureLocalStorageEngine.fetchItem(\n        LS_KEY_DEVICE_IDENTIFICATION\n      );\n\n      if (!localIdentity) {\n        localIdentity = this._generateLocalIdentity();\n\n        await secureLocalStorageEngine.setItem(\n          LS_KEY_DEVICE_IDENTIFICATION,\n          localIdentity\n        );\n      }\n\n      setInMemoryLocalIdentity(localIdentity);\n\n      return localIdentity;\n    }\n  }\n\n  /**\n   * Generates a local identity without storing it directly.\n   *\n   * @return {Object}\n   */\n  _generateLocalIdentity() {\n    // const entropy = Buffer.from('f2dacf...', 'utf-8'); // must contain at least 128 chars\n\n    const { address, privateKey, publicKey } =\n      EthCrypto.createIdentity(/* entropy */);\n\n    return {\n      address,\n      privateKey,\n      publicKey,\n    };\n  }\n\n  // TODO: Implement and document\n  /*\n  validateLocalPublicKey() {\n    // @see https://www.npmjs.com/package/eth-crypto#publickeytoaddress (publicKey.toAddress())\n  }\n  */\n\n  /**\n   * Retrieves local address, derived from Ethereum identity associated with\n   * this service.\n   *\n   * @return {Promise<string>}\n   */\n  async fetchLocalAddress() {\n    const { address } = await this.fetchLocalIdentity();\n\n    if (!address) {\n      throw new ReferenceError(\"Could not obtain address from local identity\");\n    }\n\n    return address;\n  }\n\n  /**\n   * Alias to this.fetchLocalAddress().\n   *\n   * @return {Promise<string>}\n   */\n  async fetchDeviceAddress() {\n    return this.fetchLocalAddress();\n  }\n\n  /**\n   * Retrieves local public key, derived from Ethereum identity associated with\n   * this service.\n   *\n   * @return {Promise<string}\n   */\n  async fetchLocalPublicKey() {\n    const { publicKey } = await this.fetchLocalIdentity();\n\n    if (!publicKey) {\n      throw new ReferenceError(\n        \"Could not obtain public key from local identity\"\n      );\n    }\n\n    return publicKey;\n  }\n\n  // TODO: Implement and document\n  /*\n  async fetchLocalPrivateKey(requestor) {\n    // TODO: Validate requestor\n  }\n  */\n}\n","import BaseView from \"./BaseView\";\n\nexport default BaseView;\n","import React, { useEffect, useMemo, useState } from \"react\";\n\n/**\n * Loads the base CSS styling for ReShell and sets up lazy-loading to load the\n * configured ReShell portal for this environment.\n *\n * IMPORTANT: All other view components must be loaded as children of this\n * component, and not included directly here, or the CSS modules may not load\n * (i.e. put all view components inside of, or as descendants of PortalWrapper)\n */\nexport default function BaseView({ portal }) {\n  const [areBaseStylesLoaded, setAreBaseStylesLoaded] = useState(false);\n\n  useEffect(() => {\n    // Lazy-load BaseView style so it doesn't override the non-React HTML web\n    // page before the app is mounted\n    //\n    // TODO: Use usePreload hook\n    import(\"./base-styles.css\")\n      .then(() => setAreBaseStylesLoaded(true))\n      .catch(err => console.error(err));\n  }, []);\n\n  const PortalWrapper = useMemo(\n    () => React.lazy(() => import(\"./PortalWrapper\")),\n    []\n  );\n\n  if (!areBaseStylesLoaded) {\n    // TODO: Display configurable fallback message / component\n    return null;\n  }\n\n  return (\n    // TODO: Use configurable prop for fallback property\n    <React.Suspense fallback={<div>Loading base utilities...</div>}>\n      <PortalWrapper portal={portal} />\n    </React.Suspense>\n  );\n}\n","import packageJson from \"../../package.json\";\n\nconst { version } = packageJson;\n\n/**\n * @return {string}\n */\nexport default function getReShellVersion() {\n  return version;\n}\n","import \"@core/startupHelpers\";\n\nimport PhantomCore from \"phantom-core\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport UIServiceManager from \"../classes/UIServiceManager\";\nimport BrowserShutdownInterceptorService from \"@services/BrowserShutdownInterceptorService\";\nimport KeyVaultService from \"@services/KeyVaultService\";\nimport LocalDeviceIdentificationService from \"@services/LocalDeviceIdentificationService\";\n\nimport BaseView from \"../BaseView\";\n\nimport queryString from \"query-string\";\n\nimport fetchIsLatestVersion from \"@utils/fetchIsLatestVersion\";\nimport getReShellVersion from \"@utils/getReShellVersion\";\n\nconst KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME = \"reshell-default-portal\";\n\n// TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\nlet _instance = null;\n\n/**\n * Handles bootstrapping the ReShell environment on the browser DOM and\n * establishes lifecycle control methods for the base ReShell environment.\n */\nexport default class ReShellCore extends PhantomCore {\n  /**\n   * @return {string}\n   */\n  static getReShellVersion() {\n    return getReShellVersion();\n  }\n\n  // TODO: Document\n  static async forceUpdate() {\n    if (_instance) {\n      await _instance.destroy();\n    }\n\n    // TODO: Adjust as necessary\n    window.location.href = `${\n      process.env.PUBLIC_URL || \"\"\n    }?__forceReboot=${new Date().getTime()}`;\n  }\n\n  // TODO: Document\n  static #portals = {};\n\n  // TODO: Document\n  static registerPortals(portals) {\n    ReShellCore.#portals = portals;\n  }\n\n  // TODO: Document\n  static getPortals() {\n    return ReShellCore.#portals;\n  }\n\n  // TODO: Document\n  static async init(portalName = null) {\n    return new ReShellCore(portalName);\n  }\n\n  constructor(portalName = null) {\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    if (_instance) {\n      throw new ReferenceError(\n        \"UIServiceManager cannot have multiple instances\"\n      );\n    }\n\n    super({\n      isAsync: true,\n    });\n\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = this;\n\n    this._uiServiceManager = new UIServiceManager();\n    this._uiServiceManager.startServiceClass(BrowserShutdownInterceptorService);\n    this._uiServiceManager.startServiceClass(KeyVaultService);\n    this._uiServiceManager.startServiceClass(LocalDeviceIdentificationService);\n\n    // TODO: Bind window \"beforeunload\" event to try to prevent accidental shut\n    // down before we have a chance to save states, etc. Ensure it gets unbound\n    // before the destructor finishes.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload\n\n    this._init(portalName);\n  }\n\n  // TODO: Document\n  async _init(portalName) {\n    const sessionStorageEngine = this._uiServiceManager\n      .getServiceInstance(KeyVaultService)\n      .getSessionStorageEngine();\n\n    // If no portalName is passed and there is a session storage (not local) variable set for portal, use it\n    if (!portalName) {\n      portalName =\n        // Retrieve portal name from session storage\n        (await sessionStorageEngine.fetchItem(\n          KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME\n        )) || \"default\";\n    }\n\n    const portal = ReShellCore.#portals[portalName];\n\n    if (!portal) {\n      throw new ReferenceError(\n        `Unable to init portal with name: ${portalName}`\n      );\n    }\n\n    // Save portal name in session storage\n    await sessionStorageEngine.setItem(\n      KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME,\n      portalName\n    );\n\n    // IMPORANT: This should come after setting of portal name in session storage\n    // NOTE: Intentionally not awaiting this (though maybe we should)\n    fetchIsLatestVersion().then(isLatest => {\n      if (!isLatest) {\n        if (\n          // TODO: Update\n          window.confirm(\n            \"It appears you are not running the latest version.  Reload?\"\n          )\n        ) {\n          ReShellCore.forceUpdate();\n        }\n      }\n    });\n\n    // Initialize local device identity so that it can be uniquely identified\n    // on any sub networks (i.e. Speaker.app).\n    //\n    // NOTE: Being browser-based, this will actually be unique per browser\n    // profile instead of per device\n    await (async () => {\n      const localDeviceIdentificationService =\n        this._uiServiceManager.getServiceInstance(\n          LocalDeviceIdentificationService\n        );\n\n      await localDeviceIdentificationService.initLocalIdentity();\n    })();\n\n    this._activePortalName = portalName;\n\n    // Wipe existing content, except for script tags (these script tags are\n    // used by the fetchIsLatestVersion utility for comparsion purposes)\n    [...document.body.children].forEach(child => {\n      if (child.tagName.toUpperCase() !== \"SCRIPT\") {\n        child.parentNode.removeChild(child);\n      }\n    });\n\n    // Wipe existing styling\n    (() => {\n      const existingStyles = [...document.getElementsByTagName(\"style\")];\n\n      // IMPORTANT: The timeout is utilized so that there is not a white \"pop\"\n      // during style transitioning, allowing time for JS-driven styles to be\n      // loaded\n      setTimeout(() => {\n        existingStyles.forEach(elStyle =>\n          elStyle.parentNode.removeChild(elStyle)\n        );\n      }, 1000);\n    })();\n\n    this._elBase = document.createElement(\"div\");\n    document.body.appendChild(this._elBase);\n\n    ReactDOM.render(\n      <React.StrictMode>\n        <BaseView portal={portal} />\n      </React.StrictMode>,\n      this._elBase\n    );\n\n    // TODO: Use KeyVaultService sub-service to open any previously\n    // closed windows and retain their window positions for this portal\n    // @see https://developer.apple.com/design/human-interface-guidelines/macos/app-architecture/restoring-state/\n\n    super._init();\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // TODO: Shut down running apps first, and provide a way to cancel out of\n    // shut-down in case we need to save any states\n\n    // Unrender DOM\n    // Stop the current UI\n    ReactDOM.render(<div>[Tear down]</div>, this._elBase);\n\n    await this._uiServiceManager.destroy();\n\n    const ret = await super.destroy();\n\n    // TODO: Refactor this handling into PhantomCore as optional singleton instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = null;\n\n    return ret;\n  }\n\n  // TODO: Document\n  static async destroy() {\n    return _instance?.destroy();\n  }\n\n  // TODO: Document\n  static async reload() {\n    await _instance?.destroy();\n\n    window.location.reload();\n  }\n\n  // TODO: Document\n  async switchToPortal(portalName) {\n    const sessionStorageEngine = this._uiServiceManager\n      .getServiceInstance(KeyVaultService)\n      .getSessionStorageEngine();\n\n    // Cache portalName to the session storage\n    await sessionStorageEngine.setItem(\n      KEY_SESSION_STORAGE_DEFAULT_PORTAL_NAME,\n      portalName\n    );\n\n    await this.destroy();\n\n    const urlQuery = queryString.stringify({ portalName });\n\n    window.location.href = `${process.env.PUBLIC_URL || \"\"}?${urlQuery}`;\n  }\n\n  // TODO: Document\n  static async switchToPortal(portalName) {\n    await _instance?.switchToPortal(portalName);\n  }\n\n  // TODO: Document\n  getUIServiceManager() {\n    return this._uiServiceManager;\n  }\n\n  // TODO: Document\n  static getUIServiceManager() {\n    return _instance?.getUIServiceManager();\n  }\n\n  // TODO: Document\n  getPortalName() {\n    return this._activePortalName;\n  }\n\n  // TODO: Document\n  static getPortalName() {\n    return _instance?.getPortalName();\n  }\n}\n","import ReShellCore from \"../classes/ReShellCore\";\n\n/**\n * @global\n */\nwindow.ReShell = ReShellCore;\n","import ReShellCore from \"./classes/ReShellCore\";\nimport \"./globals\";\n\nexport default ReShellCore;\n","import { PhantomServiceManager } from \"phantom-core\";\n\nconst {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} = PhantomServiceManager;\n\nexport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n  EVT_UPDATED,\n  EVT_DESTROYED,\n};\n\n// TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\nlet _instance = null;\n\n// IMPORTANT: This must be treated as a singleton for desktop usage\n// TODO: Document\nexport default class UIServiceManager extends PhantomServiceManager {\n  constructor(...args) {\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    if (_instance) {\n      throw new ReferenceError(\n        \"UIServiceManager cannot have multiple instances\"\n      );\n    }\n\n    super(...args);\n\n    // TODO: Refactor this handling into PhantomCore as optional single-instance (@see https://github.com/zenOSmosis/phantom-core/issues/72)\n    _instance = this;\n  }\n}\n","import axios from \"axios\";\n\n/**\n * This attempts to determine if we're running the latest version, regardless\n * if we have the ability to control the server-side headers related to browser\n * caching.\n *\n * @return {Promise<boolean>}\n */\nexport default async function fetchIsLatestVersion() {\n  /**\n   * @type {string[]} Array of static tag sources from our own DOM.\n   */\n  const ours = _getStaticTags();\n\n  // Pull the remote index.html file with a cache-busting timestamp appended\n  const response = await axios.get(\n    `${process.env.PUBLIC_URL || \"\"}/?__t=${new Date().getTime()}`\n  );\n\n  // Parse the remote response with browser's included DOMParser\n  const domParser = new window.DOMParser();\n  const resultDOM = domParser.parseFromString(response.data, \"text/html\");\n\n  /**\n   * @type {string[]} Array of static tag sources from the remote DOM.\n   */\n  const theirs = _getStaticTags(resultDOM);\n\n  if (theirs.length === 0) {\n    throw new Error(\"Unable to acquire remote info\");\n  }\n\n  for (const src of theirs) {\n    if (!ours.includes(src)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param {Object} dom? [default = window.document]\n * @return {string[]}\n */\nfunction _getStaticTags(dom = window.document) {\n  const jsTags = [...dom.getElementsByTagName(\"script\")];\n\n  // TODO: Also look at CSS tags\n\n  const staticJsTagSrcs = jsTags\n    .filter(tag => tag.getAttribute(\"src\")?.startsWith(\"/static\"))\n    .map(tag => tag.getAttribute(\"src\"));\n\n  return staticJsTagSrcs;\n}\n","// IMPORTANT: This file is included within ReShell core, so it is good practice\n// to not include ReShell core as a dependency here\n\nconst dayjs = require(\"dayjs\");\n\n// Extend day.js w/ fromNow() method\nconst relativeTime = require(\"dayjs/plugin/relativeTime\");\ndayjs.extend(relativeTime);\n\n// Extend day.js w/ localization\nconst localizedFormat = require(\"dayjs/plugin/localizedFormat\");\ndayjs.extend(localizedFormat);\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","// This file is automatically generated and should not be directly modified\n\nimport React from \"react\";\nimport ReShellCore from \"./core\";\n\n// The portals defined here are what are selectable inside of the application\nconst portals = {\n  default: React.lazy(() =>\n    import(\"@portals/ReShell.org\")\n  )\n};\n\nReShellCore.registerPortals(portals);\n","import reportWebVitals from \"./reportWebVitals\";\n\n// Load dynamically linked ReShell portal(s)\nimport \"./__registerPortals__\";\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n//\n// Additional reading for \"name\" element:\n//  - [FCP] https://web.dev/fcp/\n//  - [TTFB] https://web.dev/time-to-first-byte/\n//  - [FID] https://web.dev/fid/\n//  - [CLS] https://web.dev/cls/\nreportWebVitals(({ id, name, value }) => {\n  // TODO: Remove\n  console.log({\n    webVitalsReport: {\n      id,\n      name,\n      value,\n    },\n  });\n});\n","import { PhantomServiceCore } from \"phantom-core\";\nconst { EVT_UPDATED, EVT_DESTROYED } = PhantomServiceCore;\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class UIServiceCore extends PhantomServiceCore {\n  // TODO: Check if we're running in UI thread?\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Look into https://www.npmjs.com/package/localforage for local IndexedDB handling\n// TODO: Implement encrypted storage (indexeddb usage as well?)\n\n/**\n * NOTE: All of these methods are async to handle potential network,\n * off-process, or async-based storage engines.\n *\n * To ensure maximum compatibility, extension classes should use the async API\n * as well.\n */\nexport default class BaseStorageEngine extends PhantomCore {\n  constructor(options = {}) {\n    const DEFAULT_OPTIONS = { encryptionType: null };\n\n    super(\n      PhantomCore.mergeOptions({\n        DEFAULT_OPTIONS,\n        ...PhantomCore.mergeOptions({\n          ...options,\n          isAsync: false,\n        }),\n      })\n    );\n\n    // TODO: Implement startup checking for CRUD operations, using objects as\n    // types (which must be serialized most browser native storage engines),\n    // using ephemeral data\n\n    // IMPORTANT: The encryption type is left up to the storage engine itself\n    // to implement; this only contains its type\n    this._encryptionType = this.getOptions().encryptionType;\n  }\n\n  // TODO: Document\n  getEncryptionType() {\n    return this._encryptionType;\n  }\n\n  // TODO: Document\n  // @emits {EVT_UPDATED} // IMPORTANT: The extension must emit this or we might not know when to update the UI\n  async setItem(key, value) {\n    throw new ReferenceError(\"setItem must be overridden\");\n  }\n\n  // TODO: Document\n  // @emits {EVT_UPDATED} // IMPORTANT: The extension must emit this or we might not know when to update the UI\n  async removeItem(key) {\n    throw new ReferenceError(\"removeItem must be overridden\");\n  }\n\n  // TODO: Document\n  async fetchItem(key) {\n    throw new ReferenceError(\"fetchItem must be overridden\");\n  }\n\n  // TODO: Document\n  async fetchKeys() {\n    throw new ReferenceError(\"fetchKeys must be overridden\");\n  }\n\n  // TODO: Document\n  // @emits {EVT_UPDATED} // IMPORTANT: The extension must emit this or we might not know when to update the UI\n  async clear() {\n    throw new ReferenceError(\"clear must be overridden\");\n  }\n}\n","import BaseStorageEngine, { EVT_UPDATED } from \"./_BaseStorageEngine\";\n\nexport default class SessionStorageEngine extends BaseStorageEngine {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"SessionStorageEngine\");\n\n    // TODO: Implement ability to accept object data or other data types and\n    // perform serialization/ unserialization here directly (look at secure-ls\n    // handling for clues for some potential approaches )\n  }\n\n  // TODO: Document\n  async setItem(key, value) {\n    window.sessionStorage.setItem(key, value);\n\n    this.emit(EVT_UPDATED);\n  }\n\n  // TODO: Document\n  async removeItem(key) {\n    window.sessionStorage.removeItem(key);\n\n    this.emit(EVT_UPDATED);\n  }\n\n  // TODO: Document\n  async fetchItem(key) {\n    return window.sessionStorage.getItem(key);\n  }\n\n  // TODO: Document\n  async fetchKeys() {\n    return Object.keys(window.sessionStorage);\n  }\n\n  // TODO: Document\n  async clear() {\n    window.sessionStorage.clear();\n\n    this.emit(EVT_UPDATED);\n  }\n}\n","import PhantomCore from \"phantom-core\";\nimport BaseStorageEngine, { EVT_UPDATED } from \"./_BaseStorageEngine\";\nimport SecureLS from \"secure-ls\";\n\n// TODO: Document\nexport default class SecureLocalStorageEngine extends BaseStorageEngine {\n  constructor(options) {\n    const DEFAULT_OPTIONS = {\n      encryptionType: \"aes\",\n    };\n\n    super(PhantomCore.mergeOptions(DEFAULT_OPTIONS, options));\n\n    // @see https://github.com/softvar/secure-ls\n    this._ls = new SecureLS({ encodingType: this.getEncryptionType() });\n\n    this.setTitle(\"SecureLocalStorageEngine\");\n  }\n\n  // TODO: Document\n  async setItem(key, value) {\n    this._ls.set(key, value);\n\n    this.emit(EVT_UPDATED);\n  }\n\n  // TODO: Document\n  async removeItem(key) {\n    this._ls.remove(key);\n\n    this.emit(EVT_UPDATED);\n  }\n\n  // TODO: Document\n  async fetchItem(key) {\n    // Fix issue where empty string is returned if key is not available\n    const keys = this._ls.getAllKeys();\n    if (!keys.includes(key)) {\n      return undefined;\n    }\n\n    try {\n      return this._ls.get(key);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  // TODO: Document\n  async fetchKeys() {\n    return this._ls.getAllKeys();\n  }\n\n  // TODO: Document\n  async clear() {\n    this._ls.clear();\n\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { PhantomCollection, EVT_UPDATED } from \"phantom-core\";\nimport UIServiceCore from \"@core/classes/UIServiceCore\";\n\nimport BaseStorageEngine from \"./engines/_BaseStorageEngine\";\nimport SessionStorageEngine from \"./engines/SessionStorageEngine\";\nimport SecureLocalStorageEngine from \"./engines/SecureLocalStorageEngine\";\n\n// TODO: [max size estimate; no Safari support!] https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/estimate\n\n// Additional reading: https://web.dev/storage-for-the-web/\n\n// Potential storage backends:\n// - https://github.com/willgm/web-crypto-storage\n// - https://www.npmjs.com/package/secure-ls\n\nexport default class KeyVaultService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Key Vault Service\");\n\n    this._storageEngineCollection = this.bindCollectionClass(\n      StorageEngineCollection\n    );\n\n    // Proxy storage engine collection EVT_UPDATED events through this instance\n    this.proxyOn(this._storageEngineCollection, EVT_UPDATED, (...args) =>\n      this.emit(EVT_UPDATED, ...args)\n    );\n\n    this.addStorageEngineClass(SessionStorageEngine);\n    this.addStorageEngineClass(SecureLocalStorageEngine);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    await this._storageEngineCollection.destroy();\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  // TODO: TODO: Implement optional filtering\n  async fetchKeyStorageEngineMaps() {\n    const storageEngines = this._storageEngineCollection.getStorageEngines();\n\n    const keyStorageEngineMaps = [];\n\n    for (const storageEngine of storageEngines) {\n      const keys = await storageEngine.fetchKeys();\n\n      // TODO: Refactor as part of PhantomCore API (i.e. storageEngine.getClass())\n      // const StorageEngineClass = storageEngine.constructor;\n\n      for (const key of keys) {\n        keyStorageEngineMaps.push([key, storageEngine]);\n      }\n    }\n\n    return keyStorageEngineMaps;\n  }\n\n  // TODO: Implement optional filtering\n  /**\n   * Fetches all keys from all connected storage engines.\n   *\n   * @return {any[]}\n   */\n  async fetchKeys() {\n    return (await this.fetchKeyStorageEngineMaps()).map(\n      keyStorageEngineMaps => keyStorageEngineMaps[0]\n    );\n  }\n\n  // TODO: Document\n  addStorageEngineClass(StorageEngineClass) {\n    this._storageEngineCollection.addStorageEngineClass(StorageEngineClass);\n  }\n\n  // TODO: Document\n  removeStorageEngineClass(StorageEngineClass) {\n    this._storageEngineCollection.removeStorageEngineClass(StorageEngineClass);\n  }\n\n  // TODO: Document\n  getStorageEngines() {\n    return this._storageEngineCollection.getChildren();\n  }\n\n  // TODO: Document\n  getStorageEngineWithShortUUID(shortUUID) {\n    return this.getStorageEngines().find(\n      predicate => predicate.getShortUUID() === shortUUID\n    );\n  }\n\n  // TODO: Document\n  getSecureLocalStorageEngine() {\n    return this._storageEngineCollection.getChildWithKey(\n      SecureLocalStorageEngine\n    );\n  }\n\n  // TODO: Document\n  getSessionStorageEngine() {\n    return this._storageEngineCollection.getChildWithKey(SessionStorageEngine);\n  }\n\n  // TODO: Document\n  async clearAllStorageEngines() {\n    await Promise.all(\n      this.getStorageEngines().map(storageEngine => storageEngine.clear())\n    );\n  }\n}\n\n// TODO: Refactor and document\nclass StorageEngineCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(StorageEngineClass) {\n    if (this.getChildWithKey(StorageEngineClass)) {\n      throw new ReferenceError(\"StorageEngineClass is already registered\");\n    }\n\n    // TODO: Ensure title is set and unique across instances\n\n    const storageEngine = new StorageEngineClass();\n\n    // FIXME: (jh) Even better would be to check this before instantiation, but\n    // I'm not quite sure how to yet\n    if (!(storageEngine instanceof BaseStorageEngine)) {\n      throw new TypeError(\"storageEngine is not of StorageEngine type\");\n    }\n\n    return super.addChild(storageEngine, StorageEngineClass);\n  }\n\n  // TODO: Document\n  removeChild(StorageEngineClass) {\n    const storageEngine = this.getChildWithKey(StorageEngineClass);\n\n    if (storageEngine) {\n      storageEngine.destroy();\n    }\n  }\n\n  // TODO: Document\n  addStorageEngineClass(StorageEngineClass) {\n    return this.addChild(StorageEngineClass);\n  }\n\n  // TODO: Document\n  removeStorageEngineClass(StorageEngineClass) {\n    return this.removeChild(StorageEngineClass);\n  }\n\n  // TODO: Document\n  getStorageEngines() {\n    return this.getChildren();\n  }\n}\n","import KeyVaultService from \"./KeyVaultService\";\n\nexport default KeyVaultService;\n"],"sourceRoot":""}