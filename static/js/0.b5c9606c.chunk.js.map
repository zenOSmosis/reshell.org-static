{"version":3,"sources":["components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","hooks/useServiceClass.js","components/Cover/Cover.jsx","components/Cover/index.jsx","components/Window/classes/WindowController.js","services/ScreenService.js","services/UIParadigmService.js","hooks/useForceUpdate.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","services/AppOrchestrationService/classes/AppRegistration.js","utils/getElSize.js","core/providers/UIServicesProvider/index.jsx","services/AppAutoStartService.js","hooks/usePreload.js","components/Animation/index.jsx","components/Animation/Animation.jsx","utils/getElPosition.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/UIServicesProvider.jsx","services/DesktopService.js","services/UINotificationService.js","hooks/useLocationAppRegistrationID.js","hooks/useAnimation.js","services/NativeSpyService/registerSpyAgent/SpyAgent.js","services/NativeSpyService/persistentSpyAgentCollection.js","services/NativeSpyService/registerSpyAgent/registerSpyAgent.js","services/NativeSpyService/registerSpyAgent/index.js","services/NativeSpyService/spies/WebSocket.spy.js","services/NativeSpyService/spies/WebWorker.spy.js","services/NativeSpyService/NativeSpyService.js","services/NativeSpyService/index.js","core/providers/DesktopServiceProvider/hooks/useActiveWindowController.js","core/providers/DesktopServiceProvider/DesktopServiceProvider.jsx","core/providers/DesktopServiceProvider/index.jsx","components/StackingContext/index.jsx","components/StackingContext/StackingContext.jsx","core/providers/AppOrchestrationServiceProvider/AppOrchestrationServiceProvider.jsx","core/providers/AppOrchestrationServiceProvider/index.js","utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","core/providers/AppOrchestrationServiceProvider/useAppRuntimesAutoStart.js","components/Center/Center.module.css","components/Animation/Animation.module.css","core/startupServiceClasses.js","core/providers/UIServicesProvider/hooks/useUIServicesAutoStart.js"],"names":["Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","classNames","styles","ref","Full","render","this","props","StackingContext","Component","useServiceClass","ServiceClass","subscribeToUpdates","useServicesContext","startServiceClass","serviceInstance","useMemo","serviceState","setServiceState","useEffect","_handleServiceUpdate","getState","on","EVT_UPDATED","unmount","off","React","forwardRef","Cover","forwardedRef","isVisible","EVT_RENDER_PROFILED","EVT_RESIZED","EVT_MOVED","WindowController","initialState","onBringToTop","DEFAULT_STATE","isMaximized","isMinimized","PhantomState","mergeOptions","_appRuntime","_elWindow","_elWindowManager","_handleBringToTop","_emitDebouncedResized","debounce","bind","_emitDebouncedMoved","_centerHandler","_scatterHandler","a","clear","getIsDestroying","destroy","__INTERNAL__setCenterHandler","centerHandler","getIsMaximized","getIsMinimized","restore","sleep","__INTERNAL__setScatterHandler","scatterHandler","bringToTop","captureRenderProfile","arrRenderProfile","emit","__INTERNAL__attachWindowElement","el","__INTERNAL__attachWindowManagerElement","setAppRuntime","appRuntime","setTitle","getTitle","getAppRuntime","getAppRegistration","runtime","getRegistration","setSize","width","height","elWindow","requestSkippableAnimationFrame","undefined","style","_uuid","getSize","getElSize","log","warn","getWindowManagerSize","elWindowManager","setPosition","x","y","left","right","top","bottom","getPosition","getElPosition","getIsBorderDisabled","setState","partialNextState","TypeError","setIsMaximized","maximize","setIsMinimized","minimize","ScreenService","args","screenWidth","screenHeight","_handleViewportResize","_detectScreenResolution","window","addEventListener","registerCleanupHandler","removeEventListener","getScreenResolution","innerWidth","innerHeight","UIServiceCore","DESKTOP_PARADIGM","MOBILE_PARADIGM","AUTO_DETECT_PARADIGM","UIParadigmService","_screenService","uiParadigm","isAutoSet","_handleUIParadigmAutoDetect","_detectUIParadigm","proxyOn","setStaticUIParadigm","Error","getIsAutoSet","getUIParadigm","useForceUpdate","refIsUnmount","useRef","current","setAlt","useCallback","alt","AppRegistrationCollection","addChild","appRegistration","AppRegistration","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","getChildren","PhantomCollection","AppRuntime","_appRegistration","data","proxyOnce","EVT_DESTROYED","_windowController","__INTERNAL__setWindowController","windowController","getWindowController","getRegistrationID","getID","getAppDescriptor","getEnvironment","process","PhantomCore","AppRuntimeCollection","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","_desktopService","DesktopService","getWindowControllers","map","filter","getActiveAppRegistration","getActiveWindowController","getActiveAppRuntime","getWindowControllerWithUUID","uuid","matchedWindowController","getUUID","getAppRegistrationTitleWithID","appRegistrationID","find","predicate","console","addOrUpdateAppRegistration","appDescriptor","_launchAppRegistration","activateAppRegistration","getRunningAppRegistrations","includes","forEach","activateAppRegistrationWithID","getAppRegistrationWithID","registration","Set","getIsAppRegistrationRunningWithID","Boolean","getAppRuntimesWithRegistrationID","_registrations","_appDescriptor","id","getAppDescriptorID","title","getMenu","menu","getIsPinned","isPinned","getIsPinnedToDock","isPinnedToDock","updateAppDescriptor","Object","keys","length","appDescriptorOrID","offsetWidth","offsetHeight","UIServicesProvider","KEY_SESSION_STORAGE_APP_AUTOSTART","AppAutoStartService","appAutoStartConfigs","_appOrchestrationService","_keyVaultService","KeyVaultService","_localStorageEngine","getSecureLocalStorageEngine","updatedState","nextAutoStartConfigs","setItem","fetchItem","then","cachedAutoStartConfigs","setDefaultAppAutoStartConfigs","getAppAutoStartConfigs","setAutoStartAppRegistration","priority","removeAutoStartAppRegistration","getPrioritizedAppAutoStartRegistrations","entries","sort","metadata_A","metadata_B","registrationID","usePreload","resources","isPreloaded","_setIsPreloaded","progress","_setProgress","refResources","preload","Preload","onprogress","evt","oncomplete","fetch","Animation","animationName","animationDuration","animationDelay","animationEngine","preloadResources","onAnimationEnd","tag","inline","disabled","domElement","_setDomElement","useAnimation","isDisabled","View","offsetLeft","offsetTop","useContext","UIServicesContext","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","useUIServicesAutoStart","Provider","value","services","_uiParadigmService","_uiNotificationService","UINotificationService","isProfiling","activeWindowController","isUIParadigmAutoSet","_handleWindowControllerDestruct","setActiveWindowController","prevActiveWindowController","proxyOff","setIsProfiling","showNotification","body","getIsProfiling","staticUIParadigm","notifications","image","onClick","onClose","uuidv4","closeNotificationWithUUID","next","prevUUID","isKept","useLocationAppRegistrationID","location","useLocation","setAppRegistrationID","pathname","substring","shouldRun","refOnAnimationEnd","classes","classList","visibility","BASE","contains","add","SpyAgent","spiesOn","_spiesOn","_spiesOnClassName","getClassName","persistentSpyAgentCollection","address","url","getSpiesOn","getSpiedOnClassName","spyAgentMap","Map","scope","spyAgent","get","getIsDestroyed","set","once","EVT_BEFORE_DESTROY","delete","SpyAgentCollection","nativeSpies","registerSpyAgent","initFn","push","createSpyAgentSignature","NativeWebSocket","WebSocket","isOpen","error","invokeSpyAgent","WebSocketSpy","NativeWorker","Worker","WorkerSpy","terminate","NativeSpyService","spyAgents","_persistentSpyAgentCollection","getRegisteredSpies","getSpyAgents","INITIAL_DOCUMENT_TITLE","document","DesktopServiceContext","DesktopServiceProvider","desktopService","desktopState","useActiveWindowController","forceDesktopUpdate","_handleUpdate","isAccelerated","onMount","refOnMount","refEl","AppOrchestrationServiceContext","AppOrchestrationServiceProvider","appOrchestrationService","runningAppRegistrations","appRegistrations","b","localeCompare","sensitivity","appRuntimes","useAppRuntimesAutoStart","getIsElOverflown","element","innerOffsetHeight","innerOffsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","isDetecting","refPrevIsOverflown","getIsOverflown","setIsOverflown","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","ResizeObserver","observe","unobserve","install","module","exports","refHasBegunAutoStart","locationAppRegistrationID","appAutoStartService","prioritizedAutoStartAppRegistrations","locationAppRegistration","STARTUP_SERVICE_CLASSES","startupServiceClasses","serviceClass"],"mappings":"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","file":"static/js/0.b5c9606c.chunk.js","sourcesContent":["import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n * @property {boolean} subscribeToUpdates? [default = true] If true, will re-\n * render the hook when the service emits EVT_UPDATED.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(\n  ServiceClass,\n  subscribeToUpdates = true\n) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    if (subscribeToUpdates) {\n      const _handleServiceUpdate = () => {\n        // IMPORTANT: Must set shallow clone of state or attached components may\n        // not update\n        setServiceState({ ...serviceInstance.getState() });\n      };\n\n      // Capture initial state\n      _handleServiceUpdate();\n\n      serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n      return function unmount() {\n        serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n      };\n    }\n  }, [serviceInstance, subscribeToUpdates]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import { PhantomState, EVT_UPDATED, EVT_DESTROYED, sleep } from \"phantom-core\";\nimport { debounce } from \"debounce\";\n\nimport getElPosition from \"@utils/getElPosition\";\nimport getElSize from \"@utils/getElSize\";\n\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// @see https://reactjs.org/docs/profiler.html\nexport const EVT_RENDER_PROFILED = \"render-profile\";\n\nexport const EVT_RESIZED = \"resized\";\nexport const EVT_MOVED = \"moved\";\n\n// Number of milliseconds to wait after a restore operation before running a\n// positioning effect such as scattering or centering. This is necessary in\n// order to allow all restore calculations (along with their CSS transitions,\n// etc.) to occur before trying to run the position effect calculations.\nconst POST_RESTORE_POSITION_EFFECT_TIMEOUT = 1000;\n\n// TODO: Implement ability to take snapshot (i.e. save to png, etc) for window previewing\n\n// TODO: Move into core directory?\n// TODO: Document\nexport default class WindowController extends PhantomState {\n  // TODO: Document\n  constructor(initialState = {}, { onBringToTop }) {\n    const DEFAULT_STATE = {\n      isMaximized: false,\n      isMinimized: false,\n    };\n\n    super(PhantomState.mergeOptions({ ...DEFAULT_STATE, ...initialState }));\n\n    this._appRuntime = null;\n\n    this._elWindow = null;\n    this._elWindowManager = null;\n\n    this._handleBringToTop = onBringToTop;\n\n    this._emitDebouncedResized = debounce(\n      this._emitDebouncedResized.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    this._emitDebouncedMoved = debounce(\n      this._emitDebouncedMoved.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    // TODO: Retain last size / moved and enable reverting back to previous settings\n    // TODO: Enable percentage calculation and adjust when resizing viewport (this should prevent windows from being able to leave the viewport)\n\n    // TODO: Ensure these are unbound when controller is destructed (related issue: https://github.com/zenOSmosis/phantom-core/issues/68)\n    // (For manually triggering Chrome's built-in Garbage Collector, see: https://github.com/facebook/react/issues/22471)\n    this._centerHandler = null;\n    this._scatterHandler = null;\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // TODO: Determine if in dirty state, prior to closing\n    // TODO: Replace w/ UIModal\n    // if (\n    // window.confirm(`Are you sure you wish to close \"${this.getTitle()}\"?`)\n    // ) {\n\n    return super.destroy(async () => {\n      // Clear any currently scheduled resize executions\n      this._emitDebouncedResized.clear();\n\n      if (this._appRuntime && !this._appRuntime.getIsDestroying()) {\n        await this._appRuntime.destroy();\n      }\n\n      this._appRuntime = null;\n      this._elWindow = null;\n      this._elWindowManager = null;\n    });\n\n    //}\n  }\n\n  // TODO: Document\n  __INTERNAL__setCenterHandler(centerHandler) {\n    this._centerHandler = centerHandler;\n  }\n\n  // TODO: Document\n  async center() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not center correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._centerHandler();\n    }\n  }\n\n  // TODO: Document\n  __INTERNAL__setScatterHandler(scatterHandler) {\n    this._scatterHandler = scatterHandler;\n  }\n\n  // TODO: Document\n  async scatter() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not scatter correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._scatterHandler();\n    }\n  }\n\n  // TODO: Document\n  // TODO: Rename to bringToFront and / or activate\n  bringToTop() {\n    this._handleBringToTop(this);\n  }\n\n  // TODO: Document\n  /*\n  __INTERNAL__setIsActive(isActive) {\n    if (isActive !== this.getIsActive()) {\n      this.setState({ isActive });\n    }\n  }\n  */\n\n  // TODO: Document\n  /*\n  getIsActive() {\n    return this.getState().isActive;\n  }\n  */\n\n  // TODO: Document\n  // @see https://reactjs.org/docs/profiler.html\n  captureRenderProfile(arrRenderProfile) {\n    this.emit(EVT_RENDER_PROFILED, arrRenderProfile);\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowElement(el) {\n    this._elWindow = el;\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowManagerElement(el) {\n    this._elWindowManager = el;\n  }\n\n  /**\n   * Associates an AppRuntime instance with this window controller.\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  setAppRuntime(appRuntime) {\n    // TODO: Ensure appRuntime is an AppRuntime instance\n\n    this._appRuntime = appRuntime;\n\n    // TODO: Refactor title to app runtime passing (ensure it can work both ways)\n    this._appRuntime.setTitle(this.getTitle());\n  }\n\n  /**\n   * Retrieves the associated AppRuntime for this window controller.\n   *\n   * @return {AppRuntime | void}\n   */\n  getAppRuntime() {\n    return this._appRuntime;\n  }\n\n  // TODO: Document\n  getAppRegistration() {\n    const runtime = this.getAppRuntime();\n\n    if (runtime) {\n      return runtime.getRegistration();\n    }\n  }\n\n  // TODO: Document\n  setSize({ width, height }) {\n    // Skip if maximized\n    if (this.getIsMaximized()) {\n      return;\n    }\n\n    // IMPORTANT!: Do not update state on each iteration (if at all) because that would cause excessive re-rendering\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      // FIXME: (jh) Can these be applied as a single reflow?\n      // @see https://www.sitepoint.com/10-ways-minimize-reflows-improve-performance/\n\n      requestSkippableAnimationFrame(() => {\n        if (width !== undefined) {\n          elWindow.style.width = `${width}px`;\n        }\n        if (height !== undefined) {\n          elWindow.style.height = `${height}px`;\n        }\n\n        // Emit debounced EVT_RESIZED event\n        this._emitDebouncedResized();\n      }, `${this._uuid}-size`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedResized() {\n    this.emit(EVT_RESIZED);\n  }\n\n  /**\n   * Retrieves the window's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getSize() {\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      return getElSize(elWindow);\n    } else {\n      this.log.warn(\"Unable to acquire elWindow\");\n    }\n  }\n\n  /**\n   * Retrieves the window manager's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getWindowManagerSize() {\n    const elWindowManager = this._elWindowManager;\n    if (elWindowManager) {\n      return getElSize(elWindowManager);\n    } else {\n      this.log.warn(\"Unable to acquire elWindowManager\");\n    }\n  }\n\n  // TODO: Document\n  setPosition({ x, y }) {\n    // Fixes issue where restoring using widow title bar (i.e. double-click or\n    // using window control button) would make window go to upper-left of\n    // screen\n    if (this.getIsMaximized()) {\n      return;\n    }\n\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      /**\n       * FIXME: (jh) While using translate would be better here, it is buggier\n       * to use with some of the window animations (open / minimize / restore)\n       *\n       * However, if able to tie directly into matrix operations provided by\n       * accelerated StackingContext, it might improve acceleration even\n       * further\n       *\n       * Additional reading:\n       *    - [will-change] https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\n       *    - [animating the box model]: https://whistlr.info/2021/box-model-animation\n       */\n\n      requestSkippableAnimationFrame(() => {\n        if (x !== undefined) {\n          elWindow.style.left = `${x}px`;\n\n          // Delete opposing right style\n          delete elWindow.style.right;\n        }\n        if (y !== undefined) {\n          elWindow.style.top = `${y}px`;\n\n          // Delete opposing bottom style\n          delete elWindow.style.bottom;\n        }\n\n        // IMPORTANT!: Do not update state on each iteration (if at all)\n        // because that would cause excessive re-rendering\n        this._emitDebouncedMoved();\n      }, `${this._uuid}-position`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedMoved() {\n    this.emit(EVT_MOVED);\n  }\n\n  /**\n   * Retrieves the window's upper-left-hand corner position relative to its\n   * parent (the window manager).\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n   *\n   * @param {HTMLElement} el\n   * @return {{x: number, y: number}}\n   */\n  getPosition() {\n    const elWindow = this._elWindow;\n\n    if (elWindow) {\n      return getElPosition(elWindow);\n    }\n  }\n\n  // TODO: Document\n  getIsBorderDisabled() {\n    return this.getIsMaximized() || this.getIsMinimized();\n  }\n\n  /**\n   * Sets a partial next state for this window controller.\n   *\n   * TODO: States are currently deep-merged but may become shallow merged\n   * instead.\n   *\n   * @param {Object} partialNextState\n   * @emits EVT_UPDATED\n   * @return {void}\n   */\n  setState(partialNextState) {\n    if (typeof partialNextState !== \"object\") {\n      throw new TypeError(\"partialNextState is not an object\");\n    }\n\n    // Reset polar-opposite states\n    if (partialNextState.isMaximized) {\n      partialNextState.isMinimized = false;\n    } else if (partialNextState.isMinimized) {\n      partialNextState.isMaximized = false;\n    }\n\n    return super.setState(partialNextState);\n  }\n\n  /**\n   * @param {boolean} isMaximized\n   * @return {void}\n   */\n  setIsMaximized(isMaximized) {\n    return this.setState({ isMaximized });\n  }\n\n  // TODO: Document\n  maximize() {\n    return this.setIsMaximized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is maximized.\n   *\n   * @returns {boolean}\n   */\n  getIsMaximized() {\n    return this.getState().isMaximized;\n  }\n\n  /**\n   * Sets whether or not the window is minimized.\n   *\n   * @param {boolean} isMinimized\n   * @return {void}\n   */\n  setIsMinimized(isMinimized) {\n    return this.setState({ isMinimized });\n  }\n\n  // TODO: Document\n  minimize() {\n    return this.setIsMinimized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is minimized.\n   *\n   * @return {boolean}\n   */\n  getIsMinimized() {\n    return this.getState().isMinimized;\n  }\n\n  // TODO: Document\n  restore() {\n    // IMPORTANT: The maximized / minimized states need to be set at the same\n    // time here; don't call the individual methods directly\n    this.setState({\n      isMaximized: false,\n      isMinimized: false,\n    });\n  }\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nexport { EVT_UPDATED };\n\n/**\n * UI service class for screen resolution detection.\n */\nexport default class ScreenService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Screen Service\");\n\n    this.setState({\n      screenWidth: null,\n      screenHeight: null,\n    });\n\n    // Monitor resolution changes\n    (() => {\n      // FIXME: (jh) Debounce?\n      const _handleViewportResize = () => {\n        const { width: screenWidth, height: screenHeight } =\n          this._detectScreenResolution();\n\n        this.setState({\n          screenWidth,\n          screenHeight,\n        });\n      };\n\n      // TODO: Use common handler instead\n      window.addEventListener(\"resize\", _handleViewportResize);\n\n      this.registerCleanupHandler(() => {\n        window.removeEventListener(\"resize\", _handleViewportResize);\n      });\n\n      // Capture initial size\n      _handleViewportResize();\n    })();\n  }\n\n  /**\n   * @return {{width: number, height: number}}\n   */\n  getScreenResolution() {\n    const { screenWidth: width, screenHeight: height } = this.getState();\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Detects the current screen resolution.\n   *\n   * @return {{width: number, height: number}}\n   */\n  _detectScreenResolution() {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  // TODO: fetchMonitorRefreshRate (via request-skippable-animation-frame)\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nimport ScreenService from \"./ScreenService\";\n\nexport { EVT_UPDATED };\n\nconst DESKTOP_MINIMUM_WIDTH = 640;\nconst DESKTOP_MINIMUM_HEIGHT = 480;\n\nexport const DESKTOP_PARADIGM = \"desktop\";\nexport const MOBILE_PARADIGM = \"mobile\";\nexport const AUTO_DETECT_PARADIGM = null;\n\n/**\n * UI service class for desktop paradigm detection.\n */\nexport default class UIParadigmService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Paradigm Service\");\n\n    this._screenService = this.useServiceClass(ScreenService);\n\n    // TODO: Retain preferred setting across page loads\n    this.setState({\n      uiParadigm: AUTO_DETECT_PARADIGM,\n      isAutoSet: true,\n    });\n\n    // Monitor paradigm changes\n    (() => {\n      const _handleUIParadigmAutoDetect = () => {\n        // Skip if not auto set\n        if (!this.getState().isAutoSet) {\n          return;\n        }\n\n        this.setState({\n          uiParadigm: this._detectUIParadigm(),\n        });\n      };\n\n      this.proxyOn(this._screenService, EVT_UPDATED, () =>\n        _handleUIParadigmAutoDetect()\n      );\n\n      // Perform initial auto-detection\n      _handleUIParadigmAutoDetect();\n    })();\n  }\n\n  /**\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | AUTO_DETECT_PARADIGM} uiParadigm If set to\n   * null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(uiParadigm) {\n    if (\n      uiParadigm !== DESKTOP_PARADIGM &&\n      uiParadigm !== MOBILE_PARADIGM &&\n      uiParadigm !== AUTO_DETECT_PARADIGM\n    ) {\n      throw new Error(\n        `uiParadigm must be set to \"${DESKTOP_PARADIGM}\", \"${MOBILE_PARADIGM}\", or null`\n      );\n    }\n\n    if (uiParadigm) {\n      this.setState({\n        uiParadigm,\n        // Skip auto-set\n        isAutoSet: false,\n      });\n    } else {\n      this.setState({\n        uiParadigm: this._detectUIParadigm(),\n        // Reset to auto-set\n        isAutoSet: true,\n      });\n    }\n  }\n\n  /**\n   * Retrieves if the UI paradigm is automatically set, otherwise being\n   * manually set.\n   *\n   * @return {boolean}\n   */\n  getIsAutoSet() {\n    return this.getState().isAutoSet;\n  }\n\n  /**\n   * Retrieves the paradigm of the ReShell environment.\n   *\n   * @return {DESKTOP_PARADIGM | MOBILE_PARADIGM}\n   */\n  getUIParadigm() {\n    return this.getState().uiParadigm;\n  }\n\n  /**\n   * Detects the current desktop paradigm.\n   *\n   * @return {boolean}\n   */\n  _detectUIParadigm() {\n    const { screenWidth, screenHeight } = this._screenService.getState();\n\n    let uiParadigm = DESKTOP_PARADIGM;\n\n    if (\n      screenWidth < DESKTOP_MINIMUM_WIDTH ||\n      screenHeight < DESKTOP_MINIMUM_HEIGHT\n    ) {\n      uiParadigm = MOBILE_PARADIGM;\n    }\n\n    return uiParadigm;\n  }\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * Usage:\n *  const forceUpdate = useForceUpdate()\n *\n * @return {Function} Force update function, guaranteed to have a stable\n * reference across renders.\n */\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // IMPORTANT: Don't sort these here unless the result can be memoized\n    return this.getChildren();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, data => {\n      this.emit(EVT_UPDATED, data);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOnce(this._appRegistration, EVT_DESTROYED, () => {\n      if (!this.getIsDestroying()) {\n        this.destroy();\n      }\n    });\n\n    this._windowController = null;\n\n    this.registerCleanupHandler(async () => {\n      if (!this.getIsDestroying()) {\n        this._windowController.destroy();\n      }\n\n      this._windowController = null;\n\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration?.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n\n    this._desktopService = this.useServiceClass(DesktopService);\n  }\n\n  // TODO: Import WindowController type\n  /**\n   * Retrieves all of the window controllers for all of the running apps.\n   *\n   * @return {WindowController[]}\n   */\n  getWindowControllers() {\n    return this.getAppRuntimes()\n      .map(runtime => runtime.getWindowController())\n      .filter(windowController => windowController);\n  }\n\n  // TODO: Document\n  getActiveAppRegistration() {\n    return this.getActiveWindowController()?.getAppRegistration();\n  }\n\n  // TODO: Document\n  getActiveAppRuntime() {\n    return this.getActiveWindowController()?.getActiveAppRuntime();\n  }\n\n  // TODO: Document\n  getActiveWindowController() {\n    return this._desktopService.getActiveWindowController();\n  }\n\n  // TODO: Import WindowController type\n  /**\n   * Retrieves the window controller with the given UUID.\n   *\n   * @param {uuid} string\n   * @return {WindowController | void}\n   */\n  getWindowControllerWithUUID(uuid) {\n    let matchedWindowController;\n\n    for (const windowController of this.getWindowControllers()) {\n      if (windowController.getUUID() === uuid) {\n        matchedWindowController = windowController;\n        break;\n      }\n    }\n\n    return matchedWindowController;\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithID(appRegistrationID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appRegistrationID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appRegistrationID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getRunningAppRegistrations().includes(appRegistration)) {\n      // Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      //\n      // TODO: Incorporate this logic:\n      // \"The user can also click an apps Dock icon to bring all of that apps\n      // windows forward; the most recently accessed app window becomes the key\n      // window.\"\n      // (Ref. \"Activating Windows\": https://developer.apple.com/design/human-interface-guidelines/macos/windows-and-views/window-anatomy/)\n      //\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationWithID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the currently registered app with the given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRegistration | void}\n   */\n  getAppRegistrationWithID(appRegistrationID) {\n    return this.getAppRegistrations().find(\n      registration => registration.getID() === appRegistrationID\n    );\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * NOTE: This is not named \"getActiveAppRegistrations\" because the \"active\"\n   * connotes the top-most window.\n   *\n   * @return {AppRegistration[]}\n   */\n  getRunningAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves whether or not an AppRegistration with the given ID is running.\n   *\n   * @param {string} appRegistrationID\n   * @return {boolean}\n   */\n  getIsAppRegistrationRunningWithID(appRegistrationID) {\n    return Boolean(\n      this.getRunningAppRegistrations().find(\n        registration => registration.getID() === appRegistrationID\n      )\n    );\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    // TODO: Validate against proper type\n    if (!Object.keys(appDescriptor).length) {\n      throw new TypeError(\n        \"appDescriptor does not appear to be a valid application descriptor\"\n      );\n    }\n\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * Retrieves the app descriptor's ID.\n   *\n   * NOTE: [appRegistration]ID and appDescriptorID are synonymous here, however\n   * they should not be confused with UUID and shortUUID.\n   *\n   * @return {string}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * Alias for this.getID().\n   *\n   * NOTE: [appRegistration]ID and appDescriptorID are synonymous here, however\n   * they should not be confused with UUID and shortUUID.\n   *\n   * @alias <getAppDescriptorID>\n   */\n  getAppDescriptorID() {\n    return this.getID();\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Remove; manage via a service\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","/**\n * Retrieves the given element's size in pixels.\n *\n * @param {DOMElement} el\n * @return {{width: number, height: number}}\n */\nexport default function getElSize(el) {\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n\n  return {\n    width,\n    height,\n  };\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport AppRegistration from \"./AppOrchestrationService/classes/AppRegistration\";\n\nimport KeyVaultService from \"@services/KeyVaultService\";\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\n/**\n * @typedef {{[key: string], priority: number}} AppAutoStartConfigs\n */\n\nconst KEY_SESSION_STORAGE_APP_AUTOSTART = \"app-autostart\";\n\n/**\n * Manages which applications should automatically start once ReShell loads.\n */\nexport default class AppAutoStartService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Auto Start Service\");\n\n    this.setState({\n      /** @type {AppAutoStartConfigs} */\n      appAutoStartConfigs: {},\n    });\n\n    this._appOrchestrationService = this.useServiceClass(\n      AppOrchestrationService\n    );\n\n    this._keyVaultService = this.useServiceClass(KeyVaultService);\n\n    this._localStorageEngine =\n      this._keyVaultService.getSecureLocalStorageEngine();\n    this.registerCleanupHandler(() => (this._localStorageEngine = null));\n\n    // Auto-cache auto start configs\n    this.on(EVT_UPDATED, updatedState => {\n      const nextAutoStartConfigs = updatedState.appAutoStartConfigs;\n\n      if (nextAutoStartConfigs !== undefined) {\n        this._localStorageEngine.setItem(\n          KEY_SESSION_STORAGE_APP_AUTOSTART,\n          nextAutoStartConfigs\n        );\n      }\n    });\n\n    // Auto-load from cache\n    //\n    // FIXME: (jh) I'm not positive if this could potentially lead to a race\n    // condition before setDefaultAppAutoStartConfig is externally called, or\n    // if the config is used in the useAppRuntimesAutoStart hook. This might\n    // need to be refactored.\n    this._localStorageEngine.fetchItem(KEY_SESSION_STORAGE_APP_AUTOSTART).then(\n      cachedAutoStartConfigs =>\n        cachedAutoStartConfigs &&\n        // TODO: Perform validation step\n        this.setState({ appAutoStartConfigs: cachedAutoStartConfigs })\n    );\n  }\n\n  /**\n   * Sets the default AppRegistrations and priorities, should they not already\n   * be available in the cache.\n   *\n   * @param {AppAutoStartConfigs} appAutoStartConfigs\n   * @return {void}\n   */\n  setDefaultAppAutoStartConfigs(appAutoStartConfigs) {\n    if (!Object.keys(this.getAppAutoStartConfigs()).length) {\n      // TODO: Perform validation step\n\n      this.setState({\n        appAutoStartConfigs,\n      });\n    }\n  }\n\n  /**\n   * Adds or updates the given AppRegistration and priority in the auto-start\n   * sequence.\n   *\n   * @param {AppRegistration} appRegistration\n   * @param {number} priority? [default=0] The higher the priority, the more\n   * preference the window is given in the window stack.\n   */\n  setAutoStartAppRegistration(appRegistration, priority = 0) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    const nextAutoStartConfigs = { ...this.getState().appAutoStartConfigs };\n    nextAutoStartConfigs[appRegistration.getAppDescriptorID()] = {\n      priority,\n    };\n\n    this.setState({\n      appAutoStartConfigs: nextAutoStartConfigs,\n    });\n  }\n\n  /**\n   * Removes the given AppRegistration from the auto-start.\n   *\n   * @param {AppRegistration} appRegistration\n   */\n  removeAutoStartAppRegistration(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    const nextAutoStartConfigs = { ...this.getState().appAutoStartConfigs };\n    delete nextAutoStartConfigs[appRegistration.getAppDescriptorID()];\n\n    this.setState({\n      appAutoStartConfigs: nextAutoStartConfigs,\n    });\n  }\n\n  /**\n   * Retrieves the auto-start configurations.\n   *\n   * @return {AutoStartConfigs}\n   */\n  getAppAutoStartConfigs() {\n    return this.getState().appAutoStartConfigs;\n  }\n\n  /**\n   * Retrieves a prioritized list of AppRegistration instances.\n   *\n   * @return {AppRegistration[]}\n   */\n  getPrioritizedAppAutoStartRegistrations() {\n    const prioritizedAppAutoStartConfigs = Object.entries(\n      this.getAppAutoStartConfigs()\n    )\n      .sort(\n        (\n          [registrationID_A, metadata_A = {}],\n          [registrationID_B, metadata_B = {}]\n        ) => {\n          if (metadata_A.priority < metadata_B.priority) {\n            return -1;\n          } else {\n            return 1;\n          }\n        }\n      )\n      .map(([registrationID]) =>\n        this._appOrchestrationService.getAppRegistrationWithID(registrationID)\n      )\n      .filter(registration => registration);\n\n    return prioritizedAppAutoStartConfigs;\n  }\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} resources An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {{isPreloaded: boolean, progress: number}}\n */\nexport default function usePreload(resources) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the resources; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refResources = useRef(resources);\n\n  useEffect(() => {\n    const resources = refResources.current;\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\n// TODO: Document\n// TODO: Add prop-types\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  // i.e. \"1s\"\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","/**\n * Retrieves the given element's upper-left-hand corner position in pixels\n * relative to its parent.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n *\n * @param {HTMLElement} el\n * @return {{x: number, y: number}}\n */\nexport default function getElPosition(el) {\n  return {\n    x: el.offsetLeft,\n    y: el.offsetTop,\n  };\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useUIServicesAutoStart from \"./hooks/useUIServicesAutoStart\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  // Startup auto-start services\n  useUIServicesAutoStart(startServiceClass);\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport UIParadigmService from \"./UIParadigmService\";\nimport UINotificationService from \"./UINotificationService\";\n\n/**\n * Manages state for the DesktopServiceProvider.\n */\nexport default class DesktopService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Desktop Service\");\n\n    this._uiParadigmService = this.useServiceClass(UIParadigmService);\n    this._uiNotificationService = this.useServiceClass(UINotificationService);\n\n    this.setState({\n      isProfiling: false,\n      activeWindowController: null,\n      uiParadigm: this._uiParadigmService.getUIParadigm(),\n      isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n    });\n\n    // Mirror UI paradigm service updates to local state\n    //\n    // FIXME: (jh) Perhaps get rid of UIParadigmService altogether; this\n    // shouldn't need to be mirrored like this\n    this._uiParadigmService.on(EVT_UPDATED, () => {\n      this.setState({\n        uiParadigm: this._uiParadigmService.getUIParadigm(),\n        isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n      });\n    });\n\n    // Auto-null activeWindowController state if the current one is destructed\n    //\n    // FIXME: (jh) This logic is a bit more complicated than it should be;\n    // perhaps PhantomCore could offer some way of doing state comparisons\n    // like dependencies do for React useEffect\n    (() => {\n      // Deactivate hook window controller state if destructed\n      const _handleWindowControllerDestruct = () => {\n        this.setActiveWindowController(null);\n      };\n\n      let prevActiveWindowController = null;\n\n      this.on(EVT_UPDATED, isProfiling => {\n        const activeWindowController = this.getActiveWindowController();\n\n        // Only run comparison if active window controller has changed\n        if (activeWindowController !== prevActiveWindowController) {\n          if (prevActiveWindowController) {\n            this.proxyOff(\n              prevActiveWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          if (activeWindowController) {\n            this.proxyOnce(\n              activeWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          prevActiveWindowController = activeWindowController;\n        }\n      });\n    })();\n  }\n\n  /**\n   * Sets whether or not the windows should run React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @param {boolean} isProfiling\n   * @return {void}\n   */\n  setIsProfiling(isProfiling) {\n    this.setState({ isProfiling });\n\n    // FIXME: (jh) Show develop icon\n    this._uiNotificationService.showNotification({\n      title: `Desktop profiling ${isProfiling ? \"enabled\" : \"disabled\"}`,\n      body: `Desktop profiling has been ${\n        isProfiling ? \"enabled\" : \"disabled\"\n      }.`,\n    });\n  }\n\n  /**\n   * Retrieves whether or not the windows are running React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @return {boolean}\n   */\n  getIsProfiling() {\n    return this.getState().isProfiling;\n  }\n\n  /**\n   * Sets the active (top-most) window.\n   *\n   * @param {WindowController | null} activeWindowController\n   */\n  setActiveWindowController(activeWindowController) {\n    if (\n      activeWindowController !== null &&\n      !(activeWindowController instanceof WindowController)\n    ) {\n      throw new TypeError(\"activeWindowController must be a WindowController\");\n    }\n\n    this.setState({ activeWindowController });\n  }\n\n  /**\n   * Retrieves the active (top-most) window controller.\n   *\n   * @return {WindowController | null}\n   */\n  getActiveWindowController() {\n    return this.getState().activeWindowController;\n  }\n\n  /**\n   * @typedef {import('./UIParadigmService').DESKTOP_PARADIGM} DESKTOP_PARADIGM\n   * @typedef {import('./UIParadigmService').MOBILE_PARADIGM} MOBILE_PARADIGM\n   *\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | AUTO_DETECT_PARADIGM} staticUIParadigm If set\n   * to null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(staticUIParadigm) {\n    this._uiParadigmService.setStaticUIParadigm(staticUIParadigm);\n  }\n}\n","import UIServiceCore from \"@core/classes/UIServiceCore\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport const EVT_NOTIFICATION = \"notification\";\n\n// TODO: Implement ability to store previous notifications so they can be retrieved\n\n/**\n * Handles management of UI notifications.\n */\nexport default class UINotificationService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Notification Service\");\n\n    this.setState({\n      notifications: [],\n    });\n  }\n\n  // TODO: Document\n  // TODO: Borrow API from Apple: https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/DisplayNotifications.html#//apple_ref/doc/uid/TP40016239-CH61-SW1\n  showNotification({ image, title, body, onClick, onClose = () => null }) {\n    // TODO: Capture notification time\n\n    this.setState({\n      // Add new notifications to end of stack\n      notifications: [\n        ...this.getState().notifications,\n        {\n          image,\n          title,\n          body,\n          onClick,\n          onClose,\n          uuid: uuidv4(),\n        },\n      ],\n    });\n  }\n\n  // TODO: Document\n  closeNotificationWithUUID(uuid) {\n    const next = this.getState().notifications.filter(\n      ({ uuid: prevUUID, onClose }) => {\n        const isKept = uuid !== prevUUID;\n\n        if (!isKept) {\n          // Call the onClose handler passed to showNotification\n          onClose();\n        }\n\n        return isKept;\n      }\n    );\n\n    this.setState({\n      notifications: next,\n    });\n  }\n}\n","import { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\n/**\n * Grabs the app registration ID from the current React Router location.\n *\n * @return {string | void}\n */\nexport default function useLocationAppRegistrationID() {\n  const location = useLocation();\n\n  const [appRegistrationID, setAppRegistrationID] = useState(null);\n\n  useEffect(() => {\n    // Remove leading forward slash (/) from location\n    const appRegistrationID = location.pathname?.substring(1);\n\n    setAppRegistrationID(appRegistrationID);\n  }, [location]);\n\n  return appRegistrationID;\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { PhantomState, EVT_UPDATED, EVT_BEFORE_DESTROY } from \"phantom-core\";\nimport { getClassName } from \"phantom-core\";\nimport persistentSpyAgentCollection from \"../persistentSpyAgentCollection\";\n\n// TODO: Document\nexport default class SpyAgent extends PhantomState {\n  /**\n   * Create a reusable signature.\n   *\n   * TODO: Document parameters\n   */\n  static createSpyAgentSignature(spiesOn, initialState) {\n    /** @type {Map<any, SpyAgent>} */\n    const spyAgentMap = new Map();\n\n    return (scope, updatedState = {}) => {\n      let spyAgent = spyAgentMap.get(scope);\n\n      if (\n        !spyAgent ||\n        spyAgent.getIsDestroying() ||\n        spyAgent.getIsDestroyed()\n      ) {\n        spyAgent = new SpyAgent(spiesOn, initialState);\n\n        spyAgentMap.set(scope, spyAgent);\n\n        // Remove from scope once entering shutdown phase\n        spyAgent.once(EVT_BEFORE_DESTROY, () => {\n          // Note: While this prev check shouldn't be necessary it provides\n          // double-assurance that we're not accidentally deleting a scoped\n          // instance that we shouldn't be\n          const prev = spyAgentMap.get(scope);\n          if (prev === spyAgent) {\n            spyAgentMap.delete(scope);\n          }\n        });\n      }\n\n      spyAgent.setState(updatedState);\n\n      return spyAgent;\n    };\n  }\n\n  constructor(spiesOn, initialState = {}) {\n    super(initialState);\n\n    this._spiesOn = spiesOn;\n    this._spiesOnClassName = getClassName(spiesOn);\n\n    persistentSpyAgentCollection.addChild(this);\n\n    // Obtain agent title from state\n    this.on(EVT_UPDATED, updatedState => {\n      const { address, url } = updatedState || {};\n\n      if (address || url) {\n        this.setTitle(address || url);\n      }\n    });\n\n    this.registerCleanupHandler(() => {\n      // FIXME: (jh) Ensure PhantomState itself prevents memory leaks on its\n      // own by resetting its state internally on cleanup\n      this.setState({});\n\n      persistentSpyAgentCollection.removeChild(this);\n    });\n  }\n\n  // TODO: Document\n  getSpiesOn() {\n    return this._spiesOn;\n  }\n\n  /**\n   * @return {string}\n   */\n  getSpiedOnClassName() {\n    return this._spiesOnClassName;\n  }\n}\n","import { PhantomCollection } from \"phantom-core\";\nimport SpyAgent from \"./registerSpyAgent/SpyAgent\";\n\n// TODO: Rename?\n// TODO: Document\nclass SpyAgentCollection extends PhantomCollection {\n  /**\n   * @param {SpyAgent} spyAgent SpyAgent instance\n   * @return {void}\n   */\n  addChild(spyAgent) {\n    if (!spyAgent instanceof SpyAgent) {\n      throw new TypeError(\"spyAgent is not a SpyAgent\");\n    }\n\n    return super.addChild(spyAgent);\n  }\n}\n\n// Use as a singleton\nexport default new SpyAgentCollection();\n","import SpyAgent from \"./SpyAgent\";\n\nconst nativeSpies = [];\n\n/**\n * Registers a higher-order function to track usage of lower-level APIs.\n *\n * TODO: Document params\n */\nexport default function registerSpyAgent(spiesOn, initialState, initFn) {\n  if (nativeSpies.includes(spiesOn)) {\n    throw new Error(\"Cannot add duplicate native spy\");\n  }\n\n  nativeSpies.push(spiesOn);\n\n  const signature = SpyAgent.createSpyAgentSignature(spiesOn, initialState);\n\n  initFn(signature);\n}\n\nexport { nativeSpies };\n","import registerSpyAgent, { nativeSpies } from \"./registerSpyAgent\";\n\nexport default registerSpyAgent;\nexport { nativeSpies };\n","import registerSpyAgent from \"../registerSpyAgent\";\n\nconst NativeWebSocket = window.WebSocket;\n\nif (NativeWebSocket) {\n  registerSpyAgent(\n    NativeWebSocket,\n    { address: null, isOpen: false, error: null },\n    invokeSpyAgent => {\n      /**\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n       */\n      class WebSocketSpy extends NativeWebSocket {\n        constructor(address, ...args) {\n          super(address, ...args);\n\n          // Initiate spy agent with initial state for this WebSocket instance\n          invokeSpyAgent(this, { address });\n\n          this.addEventListener(\"open\", () => {\n            // Register open state w/ spy agent\n            invokeSpyAgent(this, { isOpen: true, error: null });\n          });\n\n          // TODO: Inspect traffic?\n\n          this.addEventListener(\"close\", () => {\n            // Register close state w/ spy agent, then destruct the agent\n            invokeSpyAgent(this, { isOpen: false }).destroy();\n          });\n\n          this.addEventListener(\"error\", error => {\n            // Register error state w/ spy agent, then destruct the agent\n            invokeSpyAgent(this, { error }).destroy();\n          });\n        }\n      }\n\n      // Override the native WebSocket object\n      window.WebSocket = WebSocketSpy;\n    }\n  );\n}\n","import registerSpyAgent from \"../registerSpyAgent\";\n\nconst NativeWorker = window.Worker;\n\nif (NativeWorker) {\n  registerSpyAgent(\n    NativeWorker,\n    { url: null, isOpen: false, error: null },\n    invokeSpyAgent => {\n      /**\n       * @see hhttps://developer.mozilla.org/en-US/docs/Web/API/Worker\n       */\n      class WorkerSpy extends NativeWorker {\n        constructor(url, ...args) {\n          super(url, ...args);\n\n          // Initiate spy agent with initial state for this Worker instance\n          invokeSpyAgent(this, { url, isOpen: true });\n\n          this.addEventListener(\"error\", error => {\n            invokeSpyAgent(this, { error });\n          });\n\n          // TODO: Poll to determine if still open? We can determine if \"closed\n          // from the outside\" via wrapping terminate, but may need to poll if\n          // closing from the inside\n        }\n\n        /**\n         * @return {void}\n         */\n        terminate() {\n          super.terminate();\n\n          invokeSpyAgent(this, { isOpen: false }).destroy();\n        }\n      }\n\n      // Override the native Worker object\n      window.Worker = WorkerSpy;\n    }\n  );\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport persistentSpyAgentCollection from \"./persistentSpyAgentCollection\";\n\n// Register spies\nimport \"./spies/WebSocket.spy\";\nimport \"./spies/WebWorker.spy\";\n\nimport { nativeSpies } from \"./registerSpyAgent\";\n\n/**\n * IMPORTANT: For best results this service should be started up while ReShell\n * is \"booting\".\n */\nexport default class NativeSpyService extends UIServiceCore {\n  /**\n   * My spy service...\n   */\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Native JavaScript Spy Service\");\n\n    this.setState({ spyAgents: [] });\n\n    this._persistentSpyAgentCollection = persistentSpyAgentCollection;\n\n    this.proxyOn(this._persistentSpyAgentCollection, EVT_UPDATED, () => {\n      // TODO: Debounce (this could render a lot depending on how the spy is\n      // set up, esp. w/ WebSocket connections)\n\n      const spyAgents = this._persistentSpyAgentCollection.getChildren();\n\n      this.setState({ spyAgents });\n    });\n  }\n\n  // TODO: Document\n  getRegisteredSpies() {\n    return nativeSpies;\n  }\n\n  // TODO: Document\n  getSpyAgents() {\n    return this.getState().spyAgents;\n  }\n}\n","import NativeSpyService from \"./NativeSpyService\";\n\nexport default NativeSpyService;\n","import { EVT_UPDATED } from \"phantom-core\";\nimport { useEffect } from \"react\";\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\n// FIXME: (jh) Refactor [native] window title setting\nconst INITIAL_DOCUMENT_TITLE = document.title;\n\n// FIXME: (jh) [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n/**\n * Manages setting of the HTML document title and related effects when the\n * active window controller is changed.\n *\n * @param {WindowController | null} activeWindowController\n * @return {void}\n */\nexport default function useActiveWindowController(activeWindowController) {\n  if (\n    activeWindowController !== null &&\n    !(activeWindowController instanceof WindowController)\n  ) {\n    throw new TypeError(\"activeWindowController must be a WindowController\");\n  }\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  //\n  // FIXME: (jh) This can probably be removed now that the active window\n  // controller is managed by a service\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // FIXME: (jh) Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = INITIAL_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${INITIAL_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport const DesktopServiceContext = React.createContext({});\n\n/**\n * Provides the React app DesktopService UIServiceCore binding.\n */\nexport default function DesktopServiceProvider({ children }) {\n  const { serviceInstance: desktopService } = useServiceClass(DesktopService);\n\n  const desktopState = desktopService.getState();\n\n  useActiveWindowController(desktopState.activeWindowController);\n\n  return (\n    <DesktopServiceContext.Provider\n      value={{\n        ...desktopState,\n        setActiveWindowController: desktopService.setActiveWindowController,\n        setStaticUIParadigm: desktopService.setStaticUIParadigm,\n        setIsProfiling: desktopService.setIsProfiling,\n      }}\n    >\n      {children}\n    </DesktopServiceContext.Provider>\n  );\n}\n","import DesktopServiceProvider, {\n  DesktopServiceContext,\n} from \"./DesktopServiceProvider\";\n\nexport default DesktopServiceProvider;\nexport { DesktopServiceContext };\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","/**\n * FIXME: (jh) This video might provide some interesting insight for stacking\n * context or layout components:\n * @see https://www.youtube.com/watch?v=Xt1Cw4qM3Ec (Secret Mechanisms of CSS)\n */\n\nimport React, { useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n};\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nexport default function StackingContext({\n  className,\n  children,\n  isAccelerated = false,\n  onMount = () => null,\n  ...rest\n}) {\n  const refOnMount = useRef(onMount);\n\n  const refEl = useRef(null);\n\n  // Handle onMount and onDOMMatrix callbacks\n  useEffect(() => {\n    const el = refEl.current;\n\n    if (el) {\n      const onMount = refOnMount.current;\n\n      onMount(el);\n    }\n  }, []);\n\n  return (\n    <div\n      ref={refEl}\n      {...rest}\n      className={classNames(\n        styles[\"stacking-context\"],\n        isAccelerated && styles[\"accelerated\"],\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n}\n","import React, { useEffect } from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nexport const AppOrchestrationServiceContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationServiceProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const runningAppRegistrations =\n    appOrchestrationService.getRunningAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n\n  // Sort app registrations in place\n  //\n  // FIXME: (jh) It would be better to move this functionality into the\n  // collection itself; this also might not handle situations where updating\n  // a registration title during runtime will automatically re-apply the sort.\n  // Relevant issue: https://github.com/jzombie/pre-re-shell/issues/172\n  useEffect(() => {\n    appRegistrations\n      // Locale compare sort fix borrowed from: https://dev.to/charlesmwray/comment/l899\n      .sort((a, b) => {\n        return a.getTitle().localeCompare(\n          b.getTitle(),\n          // TODO: Replace hardcoding with dynamic variable\n          \"en\",\n          { sensitivity: \"base\" }\n        );\n      });\n  }, [appRegistrations]);\n\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n\n  // TODO: If enabling, this needs to be memoized (or contained within a\n  // phantom collection)\n  /*\n  const windowControllers = appRuntimes\n    .map(runtime => runtime.getWindowController())\n    // Don't include runtimes without window controllers\n    .filter(pred => pred);\n  */\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationWithID =\n    appOrchestrationService.activateAppRegistrationWithID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithID =\n    appOrchestrationService.getAppRegistrationTitleWithID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationServiceContext.Provider\n      value={{\n        runningAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        // windowControllers,\n        //\n        activateAppRegistration,\n        activateAppRegistrationWithID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationServiceContext.Provider>\n  );\n}\n","import AppOrchestrationServiceProvider, {\n  AppOrchestrationServiceContext,\n} from \"./AppOrchestrationServiceProvider\";\n\nexport default AppOrchestrationServiceProvider;\nexport { AppOrchestrationServiceContext };\n","/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {boolean} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(getIsOverflown);\n\n  refPrevIsOverflown.current = isOverflown;\n\n  // TODO: Replace w/ useUUID\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      // FIXME: (jh) Debounce? (even though it's called within\n      // requestAnimationFrame it probably doesn't need to check at 60+fps)\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","import { useEffect, useRef } from \"react\";\n\nimport useLocationAppRegistrationID from \"@hooks/useLocationAppRegistrationID\";\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppAutoStartService from \"@services/AppAutoStartService\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  const locationAppRegistrationID = useLocationAppRegistrationID();\n\n  const { serviceInstance: appAutoStartService } = useServiceClass(\n    AppAutoStartService,\n    false\n  );\n\n  // Automatically start\n  //\n  // TODO: Move this functionality to AppAutoStartService\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      refHasBegunAutoStart.current = true;\n\n      const prioritizedAutoStartAppRegistrations =\n        appAutoStartService.getPrioritizedAppAutoStartRegistrations();\n      for (const registration of prioritizedAutoStartAppRegistrations) {\n        activateAppRegistration(registration);\n      }\n\n      // IMPORTANT: The setImmediate call fixes an issue where deep-linked apps\n      // would not focus\n      setImmediate(() => {\n        if (locationAppRegistrationID) {\n          const locationAppRegistration = appRegistrations.find(\n            registration => registration.getID() === locationAppRegistrationID\n          );\n\n          if (locationAppRegistration) {\n            activateAppRegistration(locationAppRegistration);\n          }\n        }\n      });\n    }\n  }, [\n    locationAppRegistrationID,\n    appRegistrations,\n    activateAppRegistration,\n    appAutoStartService,\n  ]);\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};","/**\n * This file contains optional startup classes which are not required to start\n * up the desktop itself, but help augment some of its functionality.\n */\n\nimport NativeSpyService from \"@services/NativeSpyService\";\n\nconst STARTUP_SERVICE_CLASSES = [NativeSpyService];\n\nexport default STARTUP_SERVICE_CLASSES;\n","import { useEffect } from \"react\";\nimport startupServiceClasses from \"../../../startupServiceClasses\";\n\n// TODO: Document\nexport default function useUIServicesAutoStart(startServiceClass) {\n  useEffect(() => {\n    if (startServiceClass) {\n      for (const serviceClass of startupServiceClasses) {\n        startServiceClass(serviceClass);\n      }\n    }\n  }, [startServiceClass]);\n}\n"],"sourceRoot":""}