{"version":3,"sources":["utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","components/Cover/Cover.jsx","components/Cover/index.jsx","hooks/useServiceClass.js","hooks/useForceUpdate.js","services/ScreenService.js","services/UIParadigmService.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/index.jsx","core/providers/UIServicesProvider/UIServicesProvider.jsx","hooks/useLocationAppRegistrationID.js","hooks/useAnimation.js","hooks/usePreload.js","services/AppOrchestrationService/classes/AppRegistration.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","core/providers/AppOrchestrationProvider/AppOrchestrationProvider.jsx","core/providers/AppOrchestrationProvider/index.js","core/providers/DesktopProvider/hooks/useActiveWindowController.js","core/providers/DesktopProvider/DesktopProvider.jsx","core/providers/DesktopProvider/index.jsx","components/Animation/index.jsx","components/Animation/Animation.jsx","components/StackingContext/index.jsx","components/StackingContext/StackingContext.jsx","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","core/providers/AppOrchestrationProvider/useAppRuntimesAutoStart.js","components/Animation/Animation.module.css","components/Center/Center.module.css"],"names":["getIsElOverflown","element","innerOffsetHeight","offsetHeight","innerOffsetWidth","offsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","window","ResizeObserver","install","Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","isDetecting","refPrevIsOverflown","useRef","getIsOverflown","useCallback","setIsOverflown","current","uuid","useMemo","uuidv4","useEffect","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","requestSkippableAnimationFrame","observe","unmount","unobserve","classNames","styles","ref","Full","render","this","props","StackingContext","Component","React","forwardRef","Cover","forwardedRef","isVisible","useServiceClass","ServiceClass","startServiceClass","useServicesContext","serviceInstance","serviceState","setServiceState","_handleServiceUpdate","getState","on","EVT_UPDATED","off","useForceUpdate","refIsUnmount","setAlt","alt","ScreenService","args","setTitle","setState","screenWidth","screenHeight","_handleViewportResize","_detectScreenResolution","addEventListener","registerCleanupHandler","removeEventListener","getScreenResolution","width","height","innerWidth","innerHeight","UIServiceCore","DESKTOP_PARADIGM","MOBILE_PARADIGM","UIParadigmService","_screenService","paradigm","_handleParadigmAutoDetect","_detectParadigm","proxyOn","getParadigm","useContext","UIServicesContext","UIServicesProvider","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","Provider","value","services","getChildren","useLocationAppRegistrationID","location","useLocation","appRegistrationID","setAppRegistrationID","pathname","substring","useAnimation","domElement","animationName","animationDuration","animationDelay","onAnimationEnd","animationEngine","isDisabled","shouldRun","console","warn","refOnAnimationEnd","classes","classList","style","visibility","Error","BASE","contains","add","usePreload","resources","isPreloaded","_setIsPreloaded","progress","_setProgress","refResources","length","preload","Preload","onprogress","evt","oncomplete","fetch","_registrations","AppRegistration","appDescriptor","_appDescriptor","id","getAppDescriptor","getID","getTitle","title","getMenu","menu","getIsPinned","Boolean","isPinned","getIsPinnedToDock","isPinnedToDock","getIsAutoStart","isAutoStart","a","updateAppDescriptor","emit","appDescriptorOrID","destroy","PhantomCore","AppRegistrationCollection","addChild","appRegistration","TypeError","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","sort","b","aTitle","bTitle","reverse","PhantomCollection","AppRuntime","_appRegistration","data","proxyOnce","EVT_DESTROYED","getIsDestroying","_windowController","bringToTop","__INTERNAL__setWindowController","windowController","getWindowController","getRegistration","getRegistrationID","getEnvironment","process","AppRuntimeCollection","appRuntime","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","getAppRegistrationTitleWithDescriptorID","appDescriptorID","find","predicate","addOrUpdateAppRegistration","_launchAppRegistration","activateAppRegistration","getActiveAppRegistrations","includes","filter","runtime","forEach","activateAppRegistrationID","log","getAppRegistrationWithID","registration","Set","map","getAppRuntimesWithRegistrationID","AppOrchestrationContext","AppOrchestrationProvider","appOrchestrationService","activeAppRegistrations","appRegistrations","appRuntimes","useAppRuntimesAutoStart","DEFAULT_DOCUMENT_TITLE","document","DesktopContext","DesktopProvider","uiParadigmService","useActiveWindowController","activeWindowController","setActiveWindowController","forceDesktopUpdate","_handleUpdate","updatedState","undefined","_handleDestruct","once","Animation","preloadResources","tag","inline","disabled","_setDomElement","View","isAccelerated","onMount","onDOMMatrix","refOnMount","refOnDOMMatrix","refIsAccelerated","refEl","el","detectionTimeout","setTimeout","computedStyle","getComputedStyle","matrix","DOMMatrix","transform","is2D","clearTimeout","module","exports","refHasBegunAutoStart","locationAppRegistrationID","locationAppRegistration"],"mappings":"8KAIe,SAASA,iBAAiBC,GACvC,GAAIA,EAAS,CAGX,IAAMC,EAAoBD,EAAQE,aAC5BC,EAAmBH,EAAQI,YAE3BC,EAAaL,EAAQK,WAKrBC,EAAW,OAAGD,QAAH,IAAGA,OAAH,EAAGA,EAAYE,aAC1BC,EAAU,OAAGH,QAAH,IAAGA,OAAH,EAAGA,EAAYI,YAE/B,OAAIH,EAAcL,GAAqBO,EAAaL,EAMpD,OAAO,E,wCCfNO,OAAOC,gBACVC,oB,qDCTaC,ICeA,SAASA,OAAT,GAKX,IAJFC,EAIC,EAJDA,SACAC,EAGC,EAHDA,UAGC,IAFDC,mBAEC,SADEC,EACF,iBACD,EAA8BC,mBAAS,MAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KAEMC,EFEO,SAASC,qBAAqBtB,GAA8B,IAArBuB,IAAoB,yDAClEC,EAAqBC,iBAAO,MAK5BC,EAAiBC,uBACrB,kBAAM5B,iBAAiBC,KACvB,CAACA,IAGH,EAAsCkB,oBAAS,kBAAMQ,OAArD,mBAAOL,EAAP,KAAoBO,EAApB,KAEAJ,EAAmBK,QAAUR,EAE7B,IAAMS,EAAOC,kBAAQC,IAAQ,IAqE7B,OAnEAC,qBAAU,WACR,GAAIV,GAAevB,EAAS,CAC1B,IAAIkC,GAAgB,EAUdC,EAAmB,SAAnBA,mBACJ,IAAID,EAAJ,CAIA,IAAME,EAAkBZ,EAAmBK,QAErCQ,EAAkBX,IAEpBU,IAAoBC,GACtBT,EAAeS,KAIbC,EAAK,IAAI3B,gBAAe,WAW5B4B,IAA+BJ,EAAkBL,MAoBnD,OAjBAQ,EAAGE,QAAQxC,GACXsC,EAAGE,QAAQxC,EAAQK,YAgBZ,SAASoC,UACdP,GAAgB,EAEhBI,EAAGE,QAAQxC,GACXsC,EAAGI,UAAU1C,EAAQK,gBAIxB,CAACkB,EAAavB,EAAS0B,EAAgBI,IAEnCT,EEtFaC,CAAqBH,EAASH,GAElD,OACE,qBACED,UAAW4B,IACTC,IAAM,OACN5B,GAAeK,GAAeuB,IAAM,UACpC7B,GAJJ,SAOE,6CAAK8B,IAAKzB,GAAgBH,GAA1B,IAAgCF,UAAW6B,IAAO,cAAlD,SACG9B,S,0KC/BHgC,E,2KACJ,SAAAC,SACE,MAAyCC,KAAKC,MAAtCnC,EAAR,EAAQA,SAAUC,EAAlB,EAAkBA,UAAcE,EAAhC,iBAEA,OACE,cAACiC,EAAA,EAAD,2BACMjC,GADN,IAEEF,UAAW4B,IAAWC,IAAM,KAAU7B,GAFxC,SAIGD,S,MATUqC,aAeJL,IClBAA,O,mKCGAM,MAAMC,YAAW,SAASC,MAAT,EAE9BC,GACC,IAAD,IAFEC,iBAEF,SAFoB1C,EAEpB,EAFoBA,SAAwBG,GAE5C,EAF8BF,UAE9B,kBACA,OACE,cAAC+B,EAAA,EAAD,yBACED,IAAKU,GACDtC,GAFN,IAGEF,UAAW4B,IACTC,IAAM,MACLY,EAAmC,GAAvBZ,IAAO,eALxB,SAQG9B,QChBQwC,O,+HCYA,SAASG,gBAAgBC,GACtC,IAAQC,EAAsBC,cAAtBD,kBAGFE,EAAkB9B,mBACtB,kBAAM4B,EAAkBD,KACxB,CAACA,EAAcC,IAGjB,EAAwCzC,mBAAS,IAAjD,mBAAO4C,EAAP,KAAqBC,EAArB,KAoBA,OAjBA9B,qBAAU,WACR,IAAM+B,EAAuB,SAAvBA,uBAGJD,EAAgB,eAAKF,EAAgBI,cAQvC,OAJAD,IAEAH,EAAgBK,GAAGC,IAAaH,GAEzB,SAASvB,UACdoB,EAAgBO,IAAID,IAAaH,MAElC,CAACH,IAEG,CACLA,kBACAC,kB,qGC3CW,SAASO,iBAEtB,IAAMC,EAAe7C,kBAAO,GAC5BQ,qBAAU,WAGR,OAFAqC,EAAazC,SAAU,EAEhB,SAASY,UACd6B,EAAazC,SAAU,MAI3B,MAAmBX,oBAAS,GAAnBqD,EAAT,oBAMA,OAJoB5C,uBAAY,YAC7B2C,EAAazC,SAAW0C,GAAO,SAAAC,GAAG,OAAKA,OACvC,M,+KCVgBC,E,0EACnB,yBAAsB,IAAD,6DAANC,EAAM,yBAANA,EAAM,uBACnB,+BAASA,KAEJC,SAAS,kBAEd,EAAKC,SAAS,CACZC,YAAa,KACbC,aAAc,OAIhB,WAEE,IAAMC,EAAwB,SAAxBA,wBAAwB,OAAM,EAAKC,2BAGzCtE,OAAOuE,iBAAiB,SAAUF,GAElC,EAAKG,wBAAuB,WAC1BxE,OAAOyE,oBAAoB,SAAUJ,MAIvCA,IAZF,GAXmB,E,mEA8BrB,SAAAK,sBACE,MAAqDpC,KAAKiB,WAE1D,MAAO,CACLoB,MAHF,EAAQR,YAINS,OAJF,EAA4BR,gB,qCAa9B,SAAAE,0BACE,IAAMH,EAAcnE,OAAO6E,WACrBT,EAAepE,OAAO8E,YAE5BxC,KAAK4B,SAAS,CACZC,cACAC,qB,eAnDqCW,KCE9BC,EAAmB,UACnBC,EAAkB,SAKVC,E,kFACnB,6BAAsB,IAAD,iEAANlB,EAAM,yBAANA,EAAM,uBACnB,+BAASA,KAEJC,SAAS,8BAEd,EAAKkB,eAAiB,EAAKpC,gBAAgBgB,GAE3C,EAAKG,SAAS,CACZkB,SAAU,OAIZ,WACE,IAAMC,EAA4B,SAA5BA,4BAA4B,OAAM,EAAKC,mBAE7C,EAAKC,QAAQ,EAAKJ,eAAgB1B,KAAa,kBAC7C4B,OAIFA,IARF,GAZmB,E,+DA6BrB,SAAAG,cACE,OAAOlD,KAAKiB,WAAW6B,W,6BAQzB,SAAAE,kBACE,MAAsChD,KAAK6C,eAAe5B,WAAlDY,EAAR,EAAQA,YAAaC,EAArB,EAAqBA,aAEjBgB,EAAW,KAMbA,EAHAjB,EAtDwB,KAuDxBC,EAtDyB,IAwDda,EAEAD,EAGb1C,KAAK4B,SAAS,CACZkB,iB,mBAtDyCL,M,iCCf/C,wEAKe,SAAS7B,qBACtB,OAAOuC,qBAAWC,O,iCCNpB,iDAEeC,MAAf,G,kCCFA,yJASaD,EAAoBhD,IAAMkD,cAAc,IAMtC,SAASD,mBAAT,GAA2C,IAAbvF,EAAY,EAAZA,SACrCyF,EAAclC,cAEdmC,EAAoBzE,mBACxB,kBAAM0E,IAAYC,wBAClB,IAIFzE,qBAAU,WAKR,IAAM0E,EAA+B,SAA/BA,+BAIJC,GAAa,WACXL,QAcJ,OAVAC,EAAkBtC,GAChB2C,IACAF,GAGFH,EAAkBtC,GAChB4C,IACAH,GAGK,SAASlE,UACd+D,EAAkBpC,IAChByC,IACAF,GAGFH,EAAkBpC,IAChB0C,IACAH,MAGH,CAACJ,EAAaC,IAUjB,IAAM7C,EAAoBhC,uBACxB,SAAA+B,GAAY,OAAI8C,EAAkB7C,kBAAkBD,KACpD,CAAC8C,IAgBH,OACE,cAACJ,EAAkBW,SAAnB,CACEC,MAAO,CACLC,SAAUT,GAAqBA,EAAkBU,cACjDvD,qBAHJ,SAOG7C,O,4JCvFQ,SAASqG,+BACtB,IAAMC,EAAWC,cAEjB,EAAkDnG,mBAAS,MAA3D,mBAAOoG,EAAP,KAA0BC,EAA1B,KASA,OAPAtF,qBAAU,WAAO,IAAD,EAERqF,EAAiB,UAAGF,EAASI,gBAAZ,aAAG,EAAmBC,UAAU,GAEvDF,EAAqBD,KACpB,CAACF,IAEGE,I,iCCpBT,gEAIe,SAASI,aAAT,GAaX,IAZFC,EAYC,EAZDA,WACAC,EAWC,EAXDA,cAWC,IAPDC,yBAOC,MAPmB,KAOnB,MANDC,sBAMC,MANgB,KAMhB,EAJDC,EAIC,EAJDA,eAIC,IAHDC,uBAGC,MAHiB,cAGjB,MAFDC,kBAEC,aADDC,iBACC,SACgC,kBAAtBL,GACTM,QAAQC,KAAK,oDAGe,kBAAnBN,GACTK,QAAQC,KAAK,iDAGf,IAAMC,EAAoB5G,iBAAOsG,GAEjC9F,qBAAU,WACR,GAAIiG,GAAaP,EAAY,CAC3B,IAAIM,EAIG,CACL,IAAMK,EAAUX,EAAWY,UAe3B,GALAZ,EAAWa,MAAMC,WAAa,UAE9Bd,EAAWa,MAAMX,kBAAoBA,EACrCF,EAAWa,MAAMV,eAAiBA,EAM3B,gBAJCE,EAqBJ,MAAM,IAAIU,MAAJ,wCAA2CV,KAhBjD,WAGE,IAAMW,EAAO,oBAERL,EAAQM,SAASD,IACpBhB,EAAWY,UAAUM,IAAIF,GAGtBL,EAAQM,SAAS,YAAchB,IAClCD,EAAWY,UAAUM,IAAI,YAAcjB,GAV3C,GAmBJ,IAAMG,EAAiBM,EAAkBxG,QAKzC,OAFA8F,EAAW1C,iBAAiB,eAAgB8C,GAErC,SAAStF,UACdkF,EAAWxC,oBAAoB,eAAgB4C,IA/CjDJ,EAAWa,MAAMC,WAAa,aAmDjC,CACDT,EACAJ,EACAC,EACAC,EACAH,EACAM,EACAC,M,mHCjFW,SAASY,WAAWC,GACjC,MAAuC7H,oBAAS,GAAhD,mBAAO8H,EAAP,KAAoBC,EAApB,KACA,EAAiC/H,mBAAS,GAA1C,mBAAOgI,EAAP,KAAiBC,EAAjB,KAMMC,EAAe3H,iBAAOsH,GA0B5B,OAxBA9G,qBAAU,WACR,IAAM8G,EAAYK,EAAavH,QAE/B,GAAIkH,EAAUM,OAAQ,CACpB,IAAMC,EAAU,IAAIC,IAEpBD,EAAQE,WAAa,SAAAC,GACnBN,EAAaM,EAAIP,WAGnBI,EAAQI,WAAa,WACnBT,GAAgB,IAGlBK,EAAQK,MAAMZ,QAKdE,GAAgB,GAChBE,EAAa,OAEd,IAEI,CACLH,cACAE,c,8MCzCEU,EAAiB,GAYFC,E,8EA0DnB,yBAAYC,GAAgB,IAAD,4CAGzB,gBAGKC,eAAiBD,EAEtBF,EAAeE,EAAcE,IAA7B,eARyB,E,kEAc3B,SAAAC,mBACE,OAAOjH,KAAK+G,iB,mBAMd,SAAAG,QACE,OAAOlH,KAAK+G,eAAeC,K,sBAM7B,SAAAG,WACE,OAAOnH,KAAK+G,eAAeK,Q,qBAQ7B,SAAAC,UACE,OAAOrH,KAAK+G,eAAeO,O,yBAU7B,SAAAC,cACE,OAAOC,QAAQxH,KAAK+G,eAAeU,Y,+BAIrC,SAAAC,oBACE,OAAOF,QAAQxH,KAAK+G,eAAeY,kB,4BAIrC,SAAAC,iBACE,OAAOJ,QAAQxH,KAAK+G,eAAec,e,4DAMrC,4BAAAC,EAAA,6EACSlB,EAAe5G,KAAK+G,eAAeC,IAD5C,uJ,+FAOA,SAAAe,oBAAoBjB,GAClB9G,KAAK+G,eAAiBD,EAGtB9G,KAAKgI,KAAK7G,kB,yCAzHZ,oCAAkC2F,GAChC,IAAQE,EAAOF,EAAPE,GAUR,OAAIJ,EAAeI,IAEjBJ,EAAeI,GAAIe,oBAAoBjB,GAEhCF,EAAeI,IAEf,IAAIH,gBAAgBC,K,0EAc/B,kBAAmCmB,GAAnC,oFACMjB,EAAK,KAEPA,EAD2B,kBAAlBF,cACJmB,EAAkBjB,GAElBiB,GAGHrB,EAAeI,GARrB,yCASWJ,EAAeI,GAAIkB,WAT9B,kD,gGA5C2CC,KCVxBC,E,sRAEnB,SAAAC,SAASC,GACP,KAAMA,aAA2BzB,GAC/B,MAAM,IAAI0B,UAAU,6CAGtB,OAAO,wFAAeD,K,gCAOxB,SAAAE,mBAAmBF,GACjB,OAAOtI,KAAKqI,SAASC,K,mCAQvB,SAAAG,sBAAsBH,GACpB,OAAOtI,KAAK0I,YAAYJ,K,iCAM1B,SAAAK,sBAIE,OAAO3I,KAAKkE,cACT0E,MAAK,SAACd,EAAGe,GACR,IAAMC,EAAShB,EAAEX,WACX4B,EAASF,EAAE1B,WAEjB,OAAI2B,EAASC,EACJ,EACEA,EAASD,GACV,EAED,KAGVE,c,2BA/CgDC,qBCElCC,E,oEAMnB,oBAAYZ,GAAkB,IAAD,EAC3B,GAD2B,+BACrBA,aAA2BzB,GAC/B,MAAM,IAAI0B,UAAU,6CAFK,OAK3B,gBAEKY,iBAAmBb,EAGxB,EAAKrF,QAAQ,EAAKkG,iBAAkBhI,eAAa,SAAAiI,GAC/C,EAAKpB,KAAK7G,cAAaiI,MAIzB,EAAKC,UAAU,EAAKF,iBAAkBG,iBAAe,WAC9C,EAAKC,mBACR,EAAKrB,aAIT,EAAKsB,kBAAoB,KAEzB,EAAKtH,uBAAL,sBAA4B,4BAAA4F,EAAA,+DACrB,EAAKyB,mBACR,EAAKC,kBAAkBtB,UAGzB,EAAKsB,kBAAoB,YAIlB,EAAKL,iBATc,kDAvBD,E,uDAqC7B,SAAAM,aACE,GAAIzJ,KAAKwJ,kBACP,OAAOxJ,KAAKwJ,kBAAkBC,e,6CAMlC,SAAAC,gCAAgCC,GAG9B3J,KAAKwJ,kBAAoBG,I,iCAI3B,SAAAC,sBACE,OAAO5J,KAAKwJ,oB,6BAId,SAAAK,kBACE,OAAO7J,KAAKmJ,mB,+BAId,SAAAW,oBACE,OAAO9J,KAAKmJ,iBAAiBjC,U,8BAM/B,SAAAD,mBAAoB,IAAD,EACjB,iBAAOjH,KAAKmJ,wBAAZ,aAAO,EAAuBlC,qB,4BAKhC,SAAA8C,iBAEE,OAAOC,uI,YAnF6B7B,KCFnB8B,E,6PAEnB,SAAA5B,SAAS6B,GACP,KAAMA,aAAsBhB,GAC1B,MAAM,IAAIX,UAAU,mCAGtB,OAAO,mFAAe2B,K,2BAOxB,SAAAC,cAAcD,GACZ,OAAOlK,KAAKqI,SAAS6B,K,8BAQvB,SAAAE,iBAAiBF,GACf,OAAOlK,KAAK0I,YAAYwB,K,4BAM1B,SAAAG,iBACE,OAAOrK,KAAKkE,kB,sBA/BkC+E,qBCS7BqB,E,8FAEnB,mCAAsB,IAAD,uEAAN5I,EAAM,yBAANA,EAAM,uBACnB,+BAASA,KAEJC,SAAS,6BAEd,EAAK4I,2BAA6B,EAAKC,oBACrCpC,GAEF,EAAKqC,sBAAwB,EAAKD,oBAAoBP,GARnC,E,iGAkBrB,SAAAS,wCAAwCC,GACtC,IAAMrC,EAAkBtI,KAAKuK,2BAC1B5B,sBACAiC,MAAK,SAAAC,GAAS,OAAIA,EAAU3D,UAAYyD,KAE3C,GAAKrC,EAKH,OAAOA,EAAgBnB,WAJvBhC,QAAQC,KAAR,oDAC+CuF,M,wCAgBnD,SAAAG,2BAA2BhE,GACzB,IAAMwB,EACJzB,EAAgBiE,2BAA2BhE,GAG7C9G,KAAKuK,2BAA2B/B,mBAAmBF,K,oCAarD,SAAAyC,uBAAuBzC,GACrB,IAAM4B,EAAa,IAAIhB,EAAWZ,GAIlC,OAFAtI,KAAKyK,sBAAsBN,cAAcD,GAElCA,I,qCAST,SAAAc,wBAAwB1C,GACjBtI,KAAKiL,4BAA4BC,SAAS5C,GAQ7CtI,KAAKqK,iBACFc,QAAO,SAAAC,GAAO,OAAIA,EAAQvB,oBAAsBvB,KAChD+C,SAAQ,SAAAD,GAAO,OAAIA,EAAQ3B,gBAR9BzJ,KAAK+K,uBAAuBzC,K,uCAmBhC,SAAAgD,0BAA0BhH,GACxB,IAAMgE,EAAkBtI,KAAK2I,sBAAsBiC,MACjD,SAAAC,GAAS,OAAIA,EAAU3D,UAAY5C,KAGhCgE,EAGHtI,KAAKgL,wBAAwB1C,GAF7BtI,KAAKuL,IAAInG,KAAT,2CAAkDd,M,oEActD,iBAAsB4F,GAAtB,SAAApC,EAAA,wFACSoC,EAAWhC,WADpB,iD,wGAUA,SAAAS,sBACE,OAAO3I,KAAKuK,2BAA2B5B,wB,sCASzC,SAAA6C,yBAAyBlH,GACvB,OAAOtE,KAAK2I,sBAAsBiC,MAChC,SAAAa,GAAY,OAAIA,EAAavE,UAAY5C,O,uCAU7C,SAAA2G,4BACE,OAAO,YACF,IAAIS,IACL1L,KAAKqK,iBAAiBsB,KAAI,SAAAP,GAAO,OAAIA,EAAQvB,yB,4BAUnD,SAAAQ,iBACE,OAAOrK,KAAKyK,sBAAsBJ,mB,8CAUpC,SAAAuB,iCAAiCtH,GAC/B,OAAOtE,KAAKqK,iBAAiBc,QAC3B,SAAAjB,GAAU,OAAIA,EAAWJ,sBAAwBxF,S,yBA/KF7B,KCXtC6H,I,iBCGFuB,EAA0BzL,IAAMkD,cAAc,ICJ5CwI,IDSA,SAASA,yBAAT,GAAiD,IAAbhO,EAAY,EAAZA,SACxBiO,EAA4BtL,YACnD6J,GADMzJ,gBAIFmL,EACJD,EAAwBd,4BACpBgB,EAAmBF,EAAwBpD,sBAC3CuD,EAAcH,EAAwB1B,iBAQtCW,EACJe,EAAwBf,wBACpBM,EACJS,EAAwBT,0BACpBR,EACJiB,EAAwBjB,2BACpBJ,EACJqB,EAAwBrB,wCACpBkB,EACJG,EAAwBH,iCAO1B,OAFAO,YAAwBF,EAAkBjB,GAGxC,cAACa,EAAwB9H,SAAzB,CACEC,MAAO,CACLgI,yBACAC,mBACAC,cAGAlB,0BACAM,4BACAR,6BACAJ,0CACAkB,oCAXJ,SAcG9N,M,kHEpDDsO,EAAyBC,SAASjF,M,8BCA3BkF,EAAiBlM,IAAMkD,cAAc,ICNnCiJ,IDQA,SAASA,gBAAT,GAAwC,IAAbzO,EAAY,EAAZA,SACf0O,EACvB/L,YAAgBmC,KADV/B,gBAGR,EDAa,SAAS4L,4BACtB,MAA4DvO,mBAAS,MAArE,mBAAOwO,EAAP,KAA+BC,EAA/B,KAgBMC,EAAqBvL,cAwC3B,OAnCApC,qBAAU,WACR,IAAM4N,EAAgB,SAAhBA,cAAgBC,GAEfJ,EAEOI,QAAuCC,IAAvBD,EAAa1F,QACvCiF,SAASjF,MAAT,UAAoBsF,EAAuBvF,WAA3C,cAA2DiF,GAM3DQ,KARAP,SAASjF,MAAQgF,GAerB,GAFAS,IAEIH,EAAwB,CAE1B,IAAMM,EAAkB,SAAlBA,kBACJL,EAA0B,OAM5B,OAHAD,EAAuBxL,GAAGC,cAAa0L,GACvCH,EAAuBO,KAAK3D,gBAAe0D,GAEpC,SAASvN,UACdiN,EAAuBtL,IAAID,cAAa0L,GACxCH,EAAuBtL,IAAIkI,gBAAe0D,OAG7C,CAACN,EAAwBE,IAErB,CACLF,yBACAC,6BC1DAF,GADMC,EAAR,EAAQA,uBAAwBC,EAAhC,EAAgCA,0BAGhC,OACE,cAACL,EAAevI,SAAhB,CACEC,MAAO,CACL0I,yBACAC,4BAEA7J,SAAU0J,EAAkBtJ,eALhC,SAQGpF,M,qSExBQoP,ICIA,SAASA,UAAT,GAiBX,IAhBFnP,EAgBC,EAhBDA,UACAD,EAeC,EAfDA,SAGA8G,EAYC,EAZDA,cACAC,EAWC,EAXDA,kBACAC,EAUC,EAVDA,eAUC,IARDE,uBAQC,MARiB,cAQjB,MAPDmI,wBAOC,MAPkB,GAOlB,MANDpI,sBAMC,MANgB,kBAAM,MAMtB,MALDqI,WAKC,MALK,MAKL,MAJDC,cAIC,aAFDC,gBAEC,SADErP,EACF,iBACD,EAAqCC,mBAAS,MAA9C,mBAAOyG,EAAP,KAAmB4I,EAAnB,KAEQvH,EAAgBF,YAAWqH,GAA3BnH,YAERtB,YAAa,CACXC,aACAC,gBACAC,oBACAC,iBACAE,kBACAD,iBAKAE,WAAYqI,IAGd,IAAME,EAAOzO,mBAAQ,kBAAMqO,IAAK,CAACA,IAEjC,OAAKpH,EAKH,cAACwH,EAAD,2BACMvP,GADN,IAEE4B,IAAK0N,EACLxP,UAAW4B,IACTC,IAAM,UACNyN,EAASzN,IAAM,OAAa,KAC5B7B,GANJ,SASGD,KAbI,O,6KC3CIoC,IC2CA,SAASA,gBAAT,GAOX,IANFnC,EAMC,EANDA,UACAD,EAKC,EALDA,SAKC,IAJD2P,qBAIC,aAHDC,eAGC,MAHS,kBAAM,MAGf,MAFDC,mBAEC,MAFa,kBAAM,MAEnB,EADE1P,EACF,iBACK2P,EAAanP,iBAAOiP,GACpBG,EAAiBpP,iBAAOkP,GACxBG,EAAmBrP,iBAAOgP,GAE1BM,EAAQtP,iBAAO,MA0DrB,OAvDAQ,qBAAU,WACR,IAAM+O,EAAKD,EAAMlP,QAEjB,GAAImP,EAAI,CACN,IAAMN,EAAUE,EAAW/O,QACrB8O,EAAcE,EAAehP,QAC7B4O,EAAgBK,EAAiBjP,QAEnCoP,EAAmB,KAyCvB,OAvCIR,IAOFQ,EAAmBC,YAAW,WAC5B,IAAMC,EAAgBzQ,OAAO0Q,iBAAiBJ,GAGxCK,EAAS,IAAIC,UAAUH,EAAcI,WAevCF,EAAOG,MACTrJ,QAAQC,KACN,oEACA4I,GAIJL,EAAYU,KA/FS,MAmGzBX,EAAQM,GAED,SAASvO,UACdgP,aAAaR,OAGhB,IAGD,6CACEpO,IAAKkO,GACD9P,GAFN,IAGEF,UAAW4B,IACTC,IAAO,oBACP6N,GAAiB7N,IAAM,YACvB7B,GANJ,SASGD,O,oBC5HP4Q,EAAOC,QAAU,CAAC,mBAAmB,0CAA0C,YAAc,uC,oBCA7FD,EAAOC,QAAU,CAAC,KAAO,qB,oBCAzBD,EAAOC,QAAU,CAAC,MAAQ,qBAAqB,aAAa,4B,2ICS7C,SAASxC,wBACtBF,EACAjB,GAEA,IAAM4D,EAAuBnQ,kBAAO,GAE9BoQ,EAA4B1K,cAGlClF,qBAAU,WACR,GAAIgN,EAAiB5F,SAAWuI,EAAqB/P,QAAS,CAE5D+P,EAAqB/P,SAAU,EAF6B,oBAQjC,YAAIoN,GAC5Bd,QAAO,SAAAM,GAAY,OAAIA,EAAa7D,oBACpCoB,WAVyD,IAQ5D,2BAEc,CAAC,IAFJyC,EAEG,QACZT,EAAwBS,IAXkC,8BAgB5D7H,GAAa,WACX,GAAIiL,EAA2B,CAC7B,IAAMC,EAA0B7C,EAAiBrB,MAC/C,SAAAa,GAAY,OAAIA,EAAavE,UAAY2H,KAGvCC,GACF9D,EAAwB8D,UAK/B,CAACD,EAA2B5C,EAAkBjB,O,oDC/CnD0D,EAAOC,QAAU,CAAC,UAAY,6BAA6B,OAAS,4B,oBCApED,EAAOC,QAAU,CAAC,OAAS,uBAAuB,UAAY,0BAA0B,aAAa","file":"static/js/1.f8c900b6.chunk.js","sourcesContent":["/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {Object} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(() => getIsOverflown());\n\n  refPrevIsOverflown.current = isOverflown;\n\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(ServiceClass) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    const _handleServiceUpdate = () => {\n      // IMPORTANT: Must set shallow clone of state or attached components may\n      // not update\n      setServiceState({ ...serviceInstance.getState() });\n    };\n\n    // Capture initial state\n    _handleServiceUpdate();\n\n    serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n    return function unmount() {\n      serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n    };\n  }, [serviceInstance]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nexport { EVT_UPDATED };\n\n/**\n * UI service class for screen resolution detection.\n */\nexport default class ScreenService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Screen Service\");\n\n    this.setState({\n      screenWidth: null,\n      screenHeight: null,\n    });\n\n    // Monitor resolution changes\n    (() => {\n      // FIXME: (jh) Debounce?\n      const _handleViewportResize = () => this._detectScreenResolution();\n\n      // TODO: Use common handler instead\n      window.addEventListener(\"resize\", _handleViewportResize);\n\n      this.registerCleanupHandler(() => {\n        window.removeEventListener(\"resize\", _handleViewportResize);\n      });\n\n      // Capture initial size\n      _handleViewportResize();\n    })();\n  }\n\n  /**\n   * @return {{width: number, height: number}}\n   */\n  getScreenResolution() {\n    const { screenWidth: width, screenHeight: height } = this.getState();\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Detects the current screen resolution and sets it as state.\n   *\n   * @return {void}\n   */\n  _detectScreenResolution() {\n    const screenWidth = window.innerWidth;\n    const screenHeight = window.innerHeight;\n\n    this.setState({\n      screenWidth,\n      screenHeight,\n    });\n  }\n\n  // TODO: fetchMonitorRefreshRate (via request-skippable-animation-frame)\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nimport ScreenService from \"./ScreenService\";\n\nexport { EVT_UPDATED };\n\nconst DESKTOP_MINIMUM_WIDTH = 640;\nconst DESKTOP_MINIMUM_HEIGHT = 480;\n\nexport const DESKTOP_PARADIGM = \"desktop\";\nexport const MOBILE_PARADIGM = \"mobile\";\n\n/**\n * UI service class for desktop paradigm detection.\n */\nexport default class UIParadigmService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Paradigm Switching Service\");\n\n    this._screenService = this.useServiceClass(ScreenService);\n\n    this.setState({\n      paradigm: null,\n    });\n\n    // Monitor paradigm changes\n    (() => {\n      const _handleParadigmAutoDetect = () => this._detectParadigm();\n\n      this.proxyOn(this._screenService, EVT_UPDATED, () =>\n        _handleParadigmAutoDetect()\n      );\n\n      // Perform initial auto-detection\n      _handleParadigmAutoDetect();\n    })();\n  }\n\n  /**\n   * Retrieves the paradigm of the ReShell environment.\n   *\n   * @return {DESKTOP_PARADIGM | MOBILE_PARADIGM}\n   */\n  getParadigm() {\n    return this.getState().paradigm;\n  }\n\n  /**\n   * Detects the current desktop paradigm and sets it as state.\n   *\n   * @return {void}\n   */\n  _detectParadigm() {\n    const { screenWidth, screenHeight } = this._screenService.getState();\n\n    let paradigm = null;\n\n    if (\n      screenWidth < DESKTOP_MINIMUM_WIDTH ||\n      screenHeight < DESKTOP_MINIMUM_HEIGHT\n    ) {\n      paradigm = MOBILE_PARADIGM;\n    } else {\n      paradigm = DESKTOP_PARADIGM;\n    }\n\n    this.setState({\n      paradigm,\n    });\n  }\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\n/**\n * Grabs the app registration ID from the current React Router location.\n *\n * @return {string | void}\n */\nexport default function useLocationAppRegistrationID() {\n  const location = useLocation();\n\n  const [appRegistrationID, setAppRegistrationID] = useState(null);\n\n  useEffect(() => {\n    // Remove leading forward slash (/) from location\n    const appRegistrationID = location.pathname?.substring(1);\n\n    setAppRegistrationID(appRegistrationID);\n  }, [location]);\n\n  return appRegistrationID;\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} resources An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {Object} // TODO: Document return type\n */\nexport default function usePreload(resources) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the resources; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refResources = useRef(resources);\n\n  useEffect(() => {\n    const resources = refResources.current;\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * @return {string | number}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Document\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  // TODO: Document\n  getIsAutoStart() {\n    return Boolean(this._appDescriptor.isAutoStart);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // FIXME: (jh) The only way I could get this to sort alphabetically on\n    // Firefox was to build a reverse-sorted list, then reverse it again;\n    // Chrome was not affected by this\n    return this.getChildren()\n      .sort((a, b) => {\n        const aTitle = a.getTitle();\n        const bTitle = b.getTitle();\n\n        if (aTitle < bTitle) {\n          return 1;\n        } else if (bTitle > aTitle) {\n          return -1;\n        } else {\n          return 0;\n        }\n      })\n      .reverse();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, data => {\n      this.emit(EVT_UPDATED, data);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOnce(this._appRegistration, EVT_DESTROYED, () => {\n      if (!this.getIsDestroying()) {\n        this.destroy();\n      }\n    });\n\n    this._windowController = null;\n\n    this.registerCleanupHandler(async () => {\n      if (!this.getIsDestroying()) {\n        this._windowController.destroy();\n      }\n\n      this._windowController = null;\n\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration?.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * descriptor ID.\n   *\n   * @param {string} appDescriptorID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithDescriptorID(appDescriptorID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appDescriptorID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appDescriptorID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getActiveAppRegistrations().includes(appRegistration)) {\n      // Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      // TODO: Order by window manager stacking order (most recently used\n      // window in group should appear in top)\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the currently registered app with the given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRegistration | void}\n   */\n  getAppRegistrationWithID(appRegistrationID) {\n    return this.getAppRegistrations().find(\n      registration => registration.getID() === appRegistrationID\n    );\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * @return {AppRegistration[]}\n   */\n  getActiveAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","import React from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nexport const AppOrchestrationContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const activeAppRegistrations =\n    appOrchestrationService.getActiveAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n  /*\n  const windowControllers = appRuntimes\n    .map(runtime => runtime.getWindowController())\n    // Don't include runtimes without window controllers\n    .filter(pred => pred);\n  */\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationID =\n    appOrchestrationService.activateAppRegistrationID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithDescriptorID =\n    appOrchestrationService.getAppRegistrationTitleWithDescriptorID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationContext.Provider\n      value={{\n        activeAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        // windowControllers,\n        //\n        activateAppRegistration,\n        activateAppRegistrationID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithDescriptorID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationContext.Provider>\n  );\n}\n","import AppOrchestrationProvider, {\n  AppOrchestrationContext,\n} from \"./AppOrchestrationProvider\";\n\nexport default AppOrchestrationProvider;\nexport { AppOrchestrationContext };\n","import { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport { useEffect, useState } from \"react\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n// import useServicesContext from \"@hooks/useServicesContext\";\n// import AppOrchestrationService from \"../../AppRuntimesProvider/services/AppOrchestrationService\";\n\n// TODO: Refactor [native] window title setting\nconst DEFAULT_DOCUMENT_TITLE = document.title;\n\n// TODO: [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n// TODO: Document\nexport default function useActiveWindowController() {\n  const [activeWindowController, setActiveWindowController] = useState(null);\n  // const [backgroundVideoMediaStreamTrack, setBackgroundVideoMediaStreamTrack] = useState(null);\n\n  /*\n  const appOrchestrationService = useServiceClass(\n    AppOrchestrationService\n  );\n  */\n\n  // TODO: Remove\n  // TODO: Mirror active window controller w/ AppOrchestrationService (maybe have useActiveWindowController reflect orchestration state)\n  // const { services } = useServicesContext();\n  // console.log({ services });\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // TODO: Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = DEFAULT_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${DEFAULT_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      // Deactivate hook window controller state if destructed\n      const _handleDestruct = () => {\n        setActiveWindowController(null);\n      };\n\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n      activeWindowController.once(EVT_DESTROYED, _handleDestruct);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n        activeWindowController.off(EVT_DESTROYED, _handleDestruct);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n\n  return {\n    activeWindowController,\n    setActiveWindowController,\n  };\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport UIParadigmService from \"@services/UIParadigmService\";\n\nexport const DesktopContext = React.createContext({});\n\nexport default function DesktopProvider({ children }) {\n  const { serviceInstance: uiParadigmService } =\n    useServiceClass(UIParadigmService);\n\n  const { activeWindowController, setActiveWindowController } =\n    useActiveWindowController();\n\n  return (\n    <DesktopContext.Provider\n      value={{\n        activeWindowController,\n        setActiveWindowController,\n\n        paradigm: uiParadigmService.getParadigm(),\n      }}\n    >\n      {children}\n    </DesktopContext.Provider>\n  );\n}\n","import DesktopProvider, { DesktopContext } from \"./DesktopProvider\";\n\nexport default DesktopProvider;\nexport { DesktopContext };\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","import React, { useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\n// Amount of time, in milliseconds, to wait before trying to determine if a 2D\n// or 3D matrix\nconst MATRIX_DETECTION_DELAY = 100;\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n\n  /**\n   * Called, with the DOM Matrix, after acquisition from the stacking context.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix\n   */\n  onDOMMatrix: PropTypes.func,\n};\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nexport default function StackingContext({\n  className,\n  children,\n  isAccelerated = false,\n  onMount = () => null,\n  onDOMMatrix = () => null,\n  ...rest\n}) {\n  const refOnMount = useRef(onMount);\n  const refOnDOMMatrix = useRef(onDOMMatrix);\n  const refIsAccelerated = useRef(isAccelerated);\n\n  const refEl = useRef(null);\n\n  // Handle onMount and onDOMMatrix callbacks\n  useEffect(() => {\n    const el = refEl.current;\n\n    if (el) {\n      const onMount = refOnMount.current;\n      const onDOMMatrix = refOnDOMMatrix.current;\n      const isAccelerated = refIsAccelerated.current;\n\n      let detectionTimeout = null;\n\n      if (isAccelerated) {\n        // Handle 3D space detection and onDOMMatrix callback\n        //\n        // FIXME: (jh) Use of setTimeout fixes an issue where is2D didn't seem\n        // to be accurate on the first render, and possibly some subsequent\n        // render attempts.  I'm not positive this has fixed it for good and it\n        // might need to be investigated some more.\n        detectionTimeout = setTimeout(() => {\n          const computedStyle = window.getComputedStyle(el);\n\n          /** @see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix */\n          const matrix = new DOMMatrix(computedStyle.transform);\n\n          /**\n           * NOTE: Each matrix value will be a string, not a number\n           *\n           * @see https://zellwk.com/blog/css-translate-values-in-javascript/\n           **/\n          /*\n            const matrixValues = computedStyle.transform\n              .match(/matrix.*\\((.+)\\)/)[1]\n              .split(\", \");*/\n\n          // NOTE: (jh) It seems that the matrix can be 3D and still not be\n          // accelerated, so some further considerations may need to be made\n\n          if (matrix.is2D /* || matrixValues[14] === undefined*/) {\n            console.warn(\n              \"Unable to apply, or detect, added 3D space to accelerated element\",\n              el\n            );\n          }\n\n          onDOMMatrix(matrix);\n        }, MATRIX_DETECTION_DELAY);\n      }\n\n      onMount(el);\n\n      return function unmount() {\n        clearTimeout(detectionTimeout);\n      };\n    }\n  }, []);\n\n  return (\n    <div\n      ref={refEl}\n      {...rest}\n      className={classNames(\n        styles[\"stacking-context\"],\n        isAccelerated && styles[\"accelerated\"],\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","import { useEffect, useRef } from \"react\";\nimport useLocationAppRegistrationID from \"@hooks/useLocationAppRegistrationID\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  const locationAppRegistrationID = useLocationAppRegistrationID();\n\n  // Automatically start registrations with isAutoStart set to true\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      // Prevent auto-start sequence from happening more than once\n      refHasBegunAutoStart.current = true;\n\n      // FIXME: (jh) The reversed registrations seems to open apps in forward\n      // order, based on how they are defined in the desktop array.  I\n      // haven't done a lot of testing against this, so this may need to be\n      // redefined as necessary\n      for (const registration of [...appRegistrations]\n        .filter(registration => registration.getIsAutoStart())\n        .reverse()) {\n        activateAppRegistration(registration);\n      }\n\n      // IMPORTANT: The setImmediate call fixes an issue where deep-linked apps\n      // would not focus\n      setImmediate(() => {\n        if (locationAppRegistrationID) {\n          const locationAppRegistration = appRegistrations.find(\n            registration => registration.getID() === locationAppRegistrationID\n          );\n\n          if (locationAppRegistration) {\n            activateAppRegistration(locationAppRegistration);\n          }\n        }\n      });\n    }\n  }, [locationAppRegistrationID, appRegistrations, activateAppRegistration]);\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};"],"sourceRoot":""}