{"version":3,"sources":["components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","components/Cover/Cover.jsx","components/Cover/index.jsx","hooks/useServiceClass.js","hooks/useForceUpdate.js","services/ScreenService.js","services/UIParadigmService.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/index.jsx","core/providers/UIServicesProvider/UIServicesProvider.jsx","hooks/useLocationAppRegistrationID.js","hooks/useAnimation.js","hooks/usePreload.js","services/AppOrchestrationService/classes/AppRegistration.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","core/providers/AppOrchestrationProvider/AppOrchestrationProvider.jsx","core/providers/AppOrchestrationProvider/index.js","core/providers/DesktopProvider/hooks/useActiveWindowController.js","core/providers/DesktopProvider/DesktopProvider.jsx","core/providers/DesktopProvider/index.jsx","components/Animation/index.jsx","components/Animation/Animation.jsx","utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/StackingContext/index.jsx","components/StackingContext/StackingContext.jsx","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","core/providers/AppOrchestrationProvider/useAppRuntimesAutoStart.js","components/Animation/Animation.module.css","components/Center/Center.module.css"],"names":["Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","classNames","styles","ref","Full","render","this","props","StackingContext","Component","React","forwardRef","Cover","forwardedRef","isVisible","useServiceClass","ServiceClass","startServiceClass","useServicesContext","serviceInstance","useMemo","serviceState","setServiceState","useEffect","_handleServiceUpdate","getState","on","EVT_UPDATED","unmount","off","useForceUpdate","refIsUnmount","useRef","current","setAlt","useCallback","alt","ScreenService","args","setTitle","setState","screenWidth","screenHeight","_handleViewportResize","_detectScreenResolution","width","height","window","addEventListener","registerCleanupHandler","removeEventListener","getScreenResolution","innerWidth","innerHeight","UIServiceCore","DESKTOP_PARADIGM","MOBILE_PARADIGM","UIParadigmService","_screenService","uiParadigm","isAutoSet","_handleUIParadigmAutoDetect","_detectUIParadigm","proxyOn","setStaticUIParadigm","Error","getIsAutoSet","getUIParadigm","useContext","UIServicesContext","UIServicesProvider","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","Provider","value","services","getChildren","useLocationAppRegistrationID","location","useLocation","appRegistrationID","setAppRegistrationID","pathname","substring","useAnimation","domElement","animationName","animationDuration","animationDelay","onAnimationEnd","animationEngine","isDisabled","shouldRun","console","warn","refOnAnimationEnd","classes","classList","style","visibility","BASE","contains","add","usePreload","resources","isPreloaded","_setIsPreloaded","progress","_setProgress","refResources","length","preload","Preload","onprogress","evt","oncomplete","fetch","_registrations","AppRegistration","appDescriptor","_appDescriptor","id","getAppDescriptor","getID","getTitle","title","getMenu","menu","getIsPinned","Boolean","isPinned","getIsPinnedToDock","isPinnedToDock","getIsAutoStart","isAutoStart","a","updateAppDescriptor","emit","appDescriptorOrID","destroy","PhantomCore","AppRegistrationCollection","addChild","appRegistration","TypeError","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","sort","b","aTitle","bTitle","reverse","PhantomCollection","AppRuntime","_appRegistration","data","proxyOnce","EVT_DESTROYED","getIsDestroying","_windowController","bringToTop","__INTERNAL__setWindowController","windowController","getWindowController","getRegistration","getRegistrationID","getEnvironment","process","AppRuntimeCollection","appRuntime","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","getAppRegistrationTitleWithDescriptorID","appDescriptorID","find","predicate","addOrUpdateAppRegistration","_launchAppRegistration","activateAppRegistration","getActiveAppRegistrations","includes","filter","runtime","forEach","activateAppRegistrationID","log","getAppRegistrationWithID","registration","Set","map","getAppRuntimesWithRegistrationID","AppOrchestrationContext","AppOrchestrationProvider","appOrchestrationService","activeAppRegistrations","appRegistrations","appRuntimes","useAppRuntimesAutoStart","DEFAULT_DOCUMENT_TITLE","document","DesktopContext","DesktopProvider","isProfiling","setIsProfiling","uiParadigmService","useActiveWindowController","activeWindowController","setActiveWindowController","forceDesktopUpdate","_handleUpdate","updatedState","undefined","_handleDestruct","once","isUIParadigmAutoSet","Animation","preloadResources","tag","inline","disabled","_setDomElement","View","getIsElOverflown","element","innerOffsetHeight","offsetHeight","innerOffsetWidth","offsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","isDetecting","refPrevIsOverflown","getIsOverflown","setIsOverflown","uuid","uuidv4","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","ResizeObserver","requestSkippableAnimationFrame","observe","unobserve","install","isAccelerated","onMount","refOnMount","refEl","el","module","exports","refHasBegunAutoStart","locationAppRegistrationID","locationAppRegistration"],"mappings":"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","file":"static/js/0.83bca13d.chunk.js","sourcesContent":["import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(ServiceClass) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    const _handleServiceUpdate = () => {\n      // IMPORTANT: Must set shallow clone of state or attached components may\n      // not update\n      setServiceState({ ...serviceInstance.getState() });\n    };\n\n    // Capture initial state\n    _handleServiceUpdate();\n\n    serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n    return function unmount() {\n      serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n    };\n  }, [serviceInstance]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nexport { EVT_UPDATED };\n\n/**\n * UI service class for screen resolution detection.\n */\nexport default class ScreenService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Screen Service\");\n\n    this.setState({\n      screenWidth: null,\n      screenHeight: null,\n    });\n\n    // Monitor resolution changes\n    (() => {\n      // FIXME: (jh) Debounce?\n      const _handleViewportResize = () => {\n        const { width: screenWidth, height: screenHeight } =\n          this._detectScreenResolution();\n\n        this.setState({\n          screenWidth,\n          screenHeight,\n        });\n      };\n\n      // TODO: Use common handler instead\n      window.addEventListener(\"resize\", _handleViewportResize);\n\n      this.registerCleanupHandler(() => {\n        window.removeEventListener(\"resize\", _handleViewportResize);\n      });\n\n      // Capture initial size\n      _handleViewportResize();\n    })();\n  }\n\n  /**\n   * @return {{width: number, height: number}}\n   */\n  getScreenResolution() {\n    const { screenWidth: width, screenHeight: height } = this.getState();\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Detects the current screen resolution.\n   *\n   * @return {{width: number, height: number}}\n   */\n  _detectScreenResolution() {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  // TODO: fetchMonitorRefreshRate (via request-skippable-animation-frame)\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nimport ScreenService from \"./ScreenService\";\n\nexport { EVT_UPDATED };\n\nconst DESKTOP_MINIMUM_WIDTH = 640;\nconst DESKTOP_MINIMUM_HEIGHT = 480;\n\nexport const DESKTOP_PARADIGM = \"desktop\";\nexport const MOBILE_PARADIGM = \"mobile\";\n\n/**\n * UI service class for desktop paradigm detection.\n */\nexport default class UIParadigmService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Paradigm Service\");\n\n    this._screenService = this.useServiceClass(ScreenService);\n\n    this.setState({\n      uiParadigm: null,\n      isAutoSet: true,\n    });\n\n    // Monitor paradigm changes\n    (() => {\n      const _handleUIParadigmAutoDetect = () => {\n        // Skip if not auto set\n        if (!this.getState().isAutoSet) {\n          return;\n        }\n\n        this.setState({\n          uiParadigm: this._detectUIParadigm(),\n        });\n      };\n\n      this.proxyOn(this._screenService, EVT_UPDATED, () =>\n        _handleUIParadigmAutoDetect()\n      );\n\n      // Perform initial auto-detection\n      _handleUIParadigmAutoDetect();\n    })();\n  }\n\n  /**\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | null} uiParadigm If set to\n   * null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(uiParadigm) {\n    if (uiParadigm !== DESKTOP_PARADIGM && uiParadigm !== MOBILE_PARADIGM && uiParadigm !== null) {\n      throw new Error(`uiParadigm must be set to \"${DESKTOP_PARADIGM}\", \"${MOBILE_PARADIGM}\", or null`)\n    }\n\n    if (uiParadigm) {\n      this.setState({\n        uiParadigm,\n        // Skip auto-set\n        isAutoSet: false,\n      });\n    } else {\n      this.setState({\n        uiParadigm: this._detectUIParadigm(),\n        // Reset to auto-set\n        isAutoSet: true,\n      });\n    }\n  }\n\n  /**\n   * Retrieves if the UI paradigm is automatically set, otherwise being\n   * manually set.\n   *\n   * @return {boolean}\n   */\n  getIsAutoSet() {\n    return this.getState().isAutoSet;\n  }\n\n  /**\n   * Retrieves the paradigm of the ReShell environment.\n   *\n   * @return {DESKTOP_PARADIGM | MOBILE_PARADIGM}\n   */\n  getUIParadigm() {\n    return this.getState().uiParadigm;\n  }\n\n  /**\n   * Detects the current desktop paradigm.\n   *\n   * @return {boolean}\n   */\n  _detectUIParadigm() {\n    const { screenWidth, screenHeight } = this._screenService.getState();\n\n    let uiParadigm = DESKTOP_PARADIGM;\n\n    if (\n      screenWidth < DESKTOP_MINIMUM_WIDTH ||\n      screenHeight < DESKTOP_MINIMUM_HEIGHT\n    ) {\n      uiParadigm = MOBILE_PARADIGM;\n    }\n\n    return uiParadigm;\n  }\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\n/**\n * Grabs the app registration ID from the current React Router location.\n *\n * @return {string | void}\n */\nexport default function useLocationAppRegistrationID() {\n  const location = useLocation();\n\n  const [appRegistrationID, setAppRegistrationID] = useState(null);\n\n  useEffect(() => {\n    // Remove leading forward slash (/) from location\n    const appRegistrationID = location.pathname?.substring(1);\n\n    setAppRegistrationID(appRegistrationID);\n  }, [location]);\n\n  return appRegistrationID;\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} resources An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {Object} // TODO: Document return type\n */\nexport default function usePreload(resources) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the resources; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refResources = useRef(resources);\n\n  useEffect(() => {\n    const resources = refResources.current;\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * @return {string | number}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Document\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  // TODO: Document\n  getIsAutoStart() {\n    return Boolean(this._appDescriptor.isAutoStart);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // FIXME: (jh) The only way I could get this to sort alphabetically on\n    // Firefox was to build a reverse-sorted list, then reverse it again;\n    // Chrome was not affected by this\n    return this.getChildren()\n      .sort((a, b) => {\n        const aTitle = a.getTitle();\n        const bTitle = b.getTitle();\n\n        if (aTitle < bTitle) {\n          return 1;\n        } else if (bTitle > aTitle) {\n          return -1;\n        } else {\n          return 0;\n        }\n      })\n      .reverse();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, data => {\n      this.emit(EVT_UPDATED, data);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOnce(this._appRegistration, EVT_DESTROYED, () => {\n      if (!this.getIsDestroying()) {\n        this.destroy();\n      }\n    });\n\n    this._windowController = null;\n\n    this.registerCleanupHandler(async () => {\n      if (!this.getIsDestroying()) {\n        this._windowController.destroy();\n      }\n\n      this._windowController = null;\n\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration?.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * descriptor ID.\n   *\n   * @param {string} appDescriptorID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithDescriptorID(appDescriptorID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appDescriptorID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appDescriptorID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getActiveAppRegistrations().includes(appRegistration)) {\n      // Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      //\n      // TODO: Incorporate this logic:\n      // \"The user can also click an app’s Dock icon to bring all of that app’s\n      // windows forward; the most recently accessed app window becomes the key\n      // window.\"\n      // (Ref. \"Activating Windows\": https://developer.apple.com/design/human-interface-guidelines/macos/windows-and-views/window-anatomy/)\n      //\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the currently registered app with the given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRegistration | void}\n   */\n  getAppRegistrationWithID(appRegistrationID) {\n    return this.getAppRegistrations().find(\n      registration => registration.getID() === appRegistrationID\n    );\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * @return {AppRegistration[]}\n   */\n  getActiveAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","import React from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nexport const AppOrchestrationContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const activeAppRegistrations =\n    appOrchestrationService.getActiveAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n  /*\n  const windowControllers = appRuntimes\n    .map(runtime => runtime.getWindowController())\n    // Don't include runtimes without window controllers\n    .filter(pred => pred);\n  */\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationID =\n    appOrchestrationService.activateAppRegistrationID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithDescriptorID =\n    appOrchestrationService.getAppRegistrationTitleWithDescriptorID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationContext.Provider\n      value={{\n        activeAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        // windowControllers,\n        //\n        activateAppRegistration,\n        activateAppRegistrationID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithDescriptorID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationContext.Provider>\n  );\n}\n","import AppOrchestrationProvider, {\n  AppOrchestrationContext,\n} from \"./AppOrchestrationProvider\";\n\nexport default AppOrchestrationProvider;\nexport { AppOrchestrationContext };\n","import { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport { useEffect, useState } from \"react\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n// import useServicesContext from \"@hooks/useServicesContext\";\n// import AppOrchestrationService from \"../../AppRuntimesProvider/services/AppOrchestrationService\";\n\n// TODO: Refactor [native] window title setting\nconst DEFAULT_DOCUMENT_TITLE = document.title;\n\n// TODO: [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n// TODO: Document\nexport default function useActiveWindowController() {\n  const [activeWindowController, setActiveWindowController] = useState(null);\n  // const [backgroundVideoMediaStreamTrack, setBackgroundVideoMediaStreamTrack] = useState(null);\n\n  /*\n  const appOrchestrationService = useServiceClass(\n    AppOrchestrationService\n  );\n  */\n\n  // TODO: Remove\n  // TODO: Mirror active window controller w/ AppOrchestrationService (maybe have useActiveWindowController reflect orchestration state)\n  // const { services } = useServicesContext();\n  // console.log({ services });\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // TODO: Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = DEFAULT_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${DEFAULT_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      // Deactivate hook window controller state if destructed\n      const _handleDestruct = () => {\n        setActiveWindowController(null);\n      };\n\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n      activeWindowController.once(EVT_DESTROYED, _handleDestruct);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n        activeWindowController.off(EVT_DESTROYED, _handleDestruct);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n\n  return {\n    activeWindowController,\n    setActiveWindowController,\n  };\n}\n","import React, { useState } from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport UIParadigmService from \"@services/UIParadigmService\";\n\nexport const DesktopContext = React.createContext({});\n\nexport default function DesktopProvider({ children }) {\n  const [isProfiling, setIsProfiling] = useState(false);\n\n  const { serviceInstance: uiParadigmService } =\n    useServiceClass(UIParadigmService);\n\n  const { activeWindowController, setActiveWindowController } =\n    useActiveWindowController();\n\n  return (\n    <DesktopContext.Provider\n      value={{\n        activeWindowController,\n        setActiveWindowController,\n\n        uiParadigm: uiParadigmService.getUIParadigm(),\n        isUIParadigmAutoSet: uiParadigmService.getIsAutoSet(),\n        setStaticUIParadigm: uiParadigmService.setStaticUIParadigm,\n\n        isProfiling,\n        setIsProfiling,\n      }}\n    >\n      {children}\n    </DesktopContext.Provider>\n  );\n}\n","import DesktopProvider, { DesktopContext } from \"./DesktopProvider\";\n\nexport default DesktopProvider;\nexport { DesktopContext };\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {boolean} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(getIsOverflown);\n\n  refPrevIsOverflown.current = isOverflown;\n\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      // FIXME: (jh) Debounce? (even though it's called within\n      // requestAnimationFrame it probably doesn't need to check at 60+fps)\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","import React, { useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n};\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nexport default function StackingContext({\n  className,\n  children,\n  isAccelerated = false,\n  onMount = () => null,\n  ...rest\n}) {\n  const refOnMount = useRef(onMount);\n\n  const refEl = useRef(null);\n\n  // Handle onMount and onDOMMatrix callbacks\n  useEffect(() => {\n    const el = refEl.current;\n\n    if (el) {\n      const onMount = refOnMount.current;\n\n      onMount(el);\n    }\n  }, []);\n\n  return (\n    <div\n      ref={refEl}\n      {...rest}\n      className={classNames(\n        styles[\"stacking-context\"],\n        isAccelerated && styles[\"accelerated\"],\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","import { useEffect, useRef } from \"react\";\nimport useLocationAppRegistrationID from \"@hooks/useLocationAppRegistrationID\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  const locationAppRegistrationID = useLocationAppRegistrationID();\n\n  // Automatically start registrations with isAutoStart set to true\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      // Prevent auto-start sequence from happening more than once\n      refHasBegunAutoStart.current = true;\n\n      // FIXME: (jh) The reversed registrations seems to open apps in forward\n      // order, based on how they are defined in the desktop array.  I\n      // haven't done a lot of testing against this, so this may need to be\n      // redefined as necessary\n      for (const registration of [...appRegistrations]\n        .filter(registration => registration.getIsAutoStart())\n        .reverse()) {\n        activateAppRegistration(registration);\n      }\n\n      // IMPORTANT: The setImmediate call fixes an issue where deep-linked apps\n      // would not focus\n      setImmediate(() => {\n        if (locationAppRegistrationID) {\n          const locationAppRegistration = appRegistrations.find(\n            registration => registration.getID() === locationAppRegistrationID\n          );\n\n          if (locationAppRegistration) {\n            activateAppRegistration(locationAppRegistration);\n          }\n        }\n      });\n    }\n  }, [locationAppRegistrationID, appRegistrations, activateAppRegistration]);\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};"],"sourceRoot":""}