{"version":3,"sources":["components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","hooks/useServiceClass.js","components/Window/classes/WindowController.js","components/Cover/Cover.jsx","components/Cover/index.jsx","services/ScreenService.js","services/UIParadigmService.js","hooks/useForceUpdate.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","services/AppOrchestrationService/classes/AppRegistration.js","utils/getElSize.js","core/providers/UIServicesProvider/index.jsx","services/AppAutoStartService.js","utils/getElPosition.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/UIServicesProvider.jsx","services/DesktopService.js","services/UINotificationService.js","hooks/useLocationAppRegistrationID.js","hooks/useAnimation.js","hooks/usePreload.js","services/NativeSpyService/registerSpyAgent/SpyAgent.js","services/NativeSpyService/persistentSpyAgentCollection.js","services/NativeSpyService/registerSpyAgent/registerSpyAgent.js","services/NativeSpyService/registerSpyAgent/index.js","services/NativeSpyService/spies/WebSocket.spy.js","services/NativeSpyService/spies/WebWorker.spy.js","services/NativeSpyService/NativeSpyService.js","services/NativeSpyService/index.js","core/providers/DesktopServiceProvider/hooks/useActiveWindowController.js","core/providers/DesktopServiceProvider/DesktopServiceProvider.jsx","core/providers/DesktopServiceProvider/index.jsx","components/StackingContext/StackingContext.jsx","components/StackingContext/index.jsx","core/providers/AppOrchestrationServiceProvider/AppOrchestrationServiceProvider.jsx","core/providers/AppOrchestrationServiceProvider/index.js","components/Animation/index.jsx","components/Animation/Animation.jsx","utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/LoadingSpinner/index.jsx","components/LoadingSpinner/LoadingSpinner.jsx","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","core/providers/AppOrchestrationServiceProvider/useAppRuntimesAutoStart.js","components/Center/Center.module.css","components/Animation/Animation.module.css","components/LoadingSpinner/LoadingSpinner.module.css","core/startupServiceClasses.js","core/providers/UIServicesProvider/hooks/useUIServicesAutoStart.js"],"names":["Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","classNames","styles","ref","Full","render","this","props","StackingContext","Component","useServiceClass","ServiceClass","subscribeToUpdates","useServicesContext","startServiceClass","serviceInstance","useMemo","serviceState","setServiceState","useEffect","_handleServiceUpdate","getState","on","EVT_UPDATED","unmount","off","EVT_RENDER_PROFILED","EVT_RESIZED","EVT_MOVED","WindowController","initialState","onBringToTop","DEFAULT_STATE","isMaximized","isMinimized","PhantomState","mergeOptions","_appRuntime","_elWindow","_elWindowManager","_handleBringToTop","_emitDebouncedResized","debounce","bind","_emitDebouncedMoved","_centerHandler","_scatterHandler","a","clear","getIsDestroying","destroy","__INTERNAL__setCenterHandler","centerHandler","getIsMaximized","getIsMinimized","restore","sleep","__INTERNAL__setScatterHandler","scatterHandler","bringToTop","getIsActive","captureRenderProfile","arrRenderProfile","emit","__INTERNAL__attachWindowElement","el","getElWindow","__INTERNAL__attachWindowManagerElement","setAppRuntime","appRuntime","setTitle","getTitle","getAppRuntime","getAppRegistration","runtime","getRegistration","setSize","width","height","elWindow","requestSkippableAnimationFrame","undefined","style","_uuid","getSize","getElSize","log","warn","getWindowManagerSize","elWindowManager","setPosition","x","y","left","right","top","bottom","getPosition","getElPosition","getIsBorderDisabled","setState","partialNextState","TypeError","setIsMaximized","maximize","setIsMinimized","minimize","React","forwardRef","Cover","forwardedRef","isVisible","ScreenService","args","screenWidth","screenHeight","_handleViewportResize","_detectScreenResolution","addNativeEventListener","getScreenResolution","window","innerWidth","innerHeight","UIServiceCore","DESKTOP_PARADIGM","MOBILE_PARADIGM","AUTO_DETECT_PARADIGM","UIParadigmService","_screenService","uiParadigm","isAutoSet","_handleUIParadigmAutoDetect","_detectUIParadigm","proxyOn","setStaticUIParadigm","Error","getIsAutoSet","getUIParadigm","useForceUpdate","refIsUnmount","useRef","current","setAlt","useCallback","alt","AppRegistrationCollection","addChild","appRegistration","AppRegistration","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","getChildren","PhantomCollection","AppRuntime","appOrchestrationService","_appRegistration","_appOrchestrationService","data","proxyOnce","EVT_DESTROYED","_windowController","registerCleanupHandler","getActiveAppRuntime","__INTERNAL__setWindowController","windowController","getWindowController","getRegistrationID","getID","getAppDescriptor","getEnvironment","process","PhantomCore","AppRuntimeCollection","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","_desktopService","DesktopService","getWindowControllers","map","filter","getActiveAppRegistration","getActiveWindowController","getWindowControllerWithUUID","uuid","matchedWindowController","getUUID","getAppRegistrationTitleWithID","appRegistrationID","find","predicate","console","addOrUpdateAppRegistration","appDescriptor","_launchAppRegistration","activateAppRegistration","getRunningAppRegistrations","includes","forEach","activateAppRegistrationWithID","getAppRegistrationWithID","registration","Set","getIsAppRegistrationRunningWithID","Boolean","getAppRuntimesWithRegistrationID","_registrations","_appDescriptor","id","getAppDescriptorID","title","getMenu","menu","getIsPinned","isPinned","getIsPinnedToDock","isPinnedToDock","updateAppDescriptor","Object","keys","length","appDescriptorOrID","offsetWidth","offsetHeight","UIServicesProvider","KEY_SESSION_STORAGE_APP_AUTOSTART","AppAutoStartService","appAutoStartConfigs","_keyVaultService","KeyVaultService","_localStorageEngine","getSecureLocalStorageEngine","updatedState","nextAutoStartConfigs","setItem","fetchItem","then","cachedAutoStartConfigs","setDefaultAppAutoStartConfigs","getAppAutoStartConfigs","setAutoStartAppRegistration","priority","removeAutoStartAppRegistration","getPrioritizedAppAutoStartRegistrations","entries","sort","metadata_A","metadata_B","registrationID","offsetLeft","offsetTop","useContext","UIServicesContext","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","useUIServicesAutoStart","Provider","value","services","_uiParadigmService","_uiNotificationService","UINotificationService","isProfiling","activeWindowController","isUIParadigmAutoSet","_handleWindowControllerDestruct","setActiveWindowController","prevActiveWindowController","proxyOff","setIsProfiling","showNotification","body","getIsProfiling","staticUIParadigm","notifications","image","onClick","onClose","uuidv4","closeNotificationWithUUID","next","prevUUID","isKept","useLocationAppRegistrationID","location","useLocation","setAppRegistrationID","pathname","substring","useAnimation","domElement","animationName","animationDuration","animationDelay","onAnimationEnd","animationEngine","isDisabled","shouldRun","refOnAnimationEnd","classes","classList","visibility","BASE","contains","add","addEventListener","removeEventListener","usePreload","srcList","isPreloaded","_setIsPreloaded","progress","_setProgress","refSrcList","resources","Array","isArray","preload","Preload","onprogress","evt","oncomplete","fetch","SpyAgent","spiesOn","_spiesOn","_spiesOnClassName","getClassName","persistentSpyAgentCollection","address","url","getSpiesOn","getSpiedOnClassName","spyAgentMap","Map","scope","spyAgent","get","getIsDestroyed","set","once","EVT_BEFORE_DESTROY","delete","SpyAgentCollection","nativeSpies","registerSpyAgent","initFn","push","createSpyAgentSignature","NativeWebSocket","WebSocket","isOpen","error","invokeSpyAgent","WebSocketSpy","NativeWorker","Worker","WorkerSpy","terminate","NativeSpyService","spyAgents","_persistentSpyAgentCollection","getRegisteredSpies","getSpyAgents","INITIAL_DOCUMENT_TITLE","document","DesktopServiceContext","DesktopServiceProvider","desktopService","desktopState","useActiveWindowController","forceDesktopUpdate","_handleUpdate","isAccelerated","AppOrchestrationServiceContext","AppOrchestrationServiceProvider","runningAppRegistrations","appRegistrations","b","localeCompare","sensitivity","appRuntimes","useAppRuntimesAutoStart","Animation","preloadResources","tag","inline","disabled","_setDomElement","View","getIsElOverflown","element","innerOffsetHeight","innerOffsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","isDetecting","refPrevIsOverflown","getIsOverflown","setIsOverflown","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","ResizeObserver","observe","unobserve","install","LoadingSpinner","module","exports","refHasBegunAutoStart","locationAppRegistrationID","appAutoStartService","prioritizedAutoStartAppRegistrations","locationAppRegistration","STARTUP_SERVICE_CLASSES","startupServiceClasses","serviceClass"],"mappings":"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","file":"static/js/0.1841978d.chunk.js","sourcesContent":["import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\n// FIXME: Convert to function-based component (special note: may need to\n// forward refs for some other components)\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n * @property {boolean} subscribeToUpdates? [default = true] If true, will re-\n * render the hook when the service emits EVT_UPDATED.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(\n  ServiceClass,\n  subscribeToUpdates = true\n) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    if (subscribeToUpdates) {\n      const _handleServiceUpdate = () => {\n        // IMPORTANT: Must set shallow clone of state or attached components may\n        // not update\n        setServiceState({ ...serviceInstance.getState() });\n      };\n\n      // Capture initial state\n      _handleServiceUpdate();\n\n      serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n      return function unmount() {\n        serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n      };\n    }\n  }, [serviceInstance, subscribeToUpdates]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","import { PhantomState, EVT_UPDATED, EVT_DESTROYED, sleep } from \"phantom-core\";\nimport { debounce } from \"debounce\";\n\nimport getElPosition from \"@utils/getElPosition\";\nimport getElSize from \"@utils/getElSize\";\n\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// @see https://reactjs.org/docs/profiler.html\nexport const EVT_RENDER_PROFILED = \"render-profile\";\n\nexport const EVT_RESIZED = \"resized\";\nexport const EVT_MOVED = \"moved\";\n\n// Number of milliseconds to wait after a restore operation before running a\n// positioning effect such as scattering or centering. This is necessary in\n// order to allow all restore calculations (along with their CSS transitions,\n// etc.) to occur before trying to run the position effect calculations.\nconst POST_RESTORE_POSITION_EFFECT_TIMEOUT = 1000;\n\n// TODO: Implement ability to take snapshot (i.e. save to png, etc) for window previewing\n\n// TODO: Move into core directory?\n// TODO: Document\nexport default class WindowController extends PhantomState {\n  // TODO: Document\n  constructor(initialState = {}, { onBringToTop }) {\n    const DEFAULT_STATE = {\n      isMaximized: false,\n      isMinimized: false,\n    };\n\n    super(PhantomState.mergeOptions({ ...DEFAULT_STATE, ...initialState }));\n\n    this._appRuntime = null;\n\n    this._elWindow = null;\n    this._elWindowManager = null;\n\n    this._handleBringToTop = onBringToTop;\n\n    this._emitDebouncedResized = debounce(\n      this._emitDebouncedResized.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    this._emitDebouncedMoved = debounce(\n      this._emitDebouncedMoved.bind(this),\n      500,\n      // Ensure runs on trailing edge\n      false\n    );\n\n    // TODO: Retain last size / moved and enable reverting back to previous settings\n    // TODO: Enable percentage calculation and adjust when resizing viewport (this should prevent windows from being able to leave the viewport)\n\n    // TODO: Ensure these are unbound when controller is destructed (related issue: https://github.com/zenOSmosis/phantom-core/issues/68)\n    // (For manually triggering Chrome's built-in Garbage Collector, see: https://github.com/facebook/react/issues/22471)\n    this._centerHandler = null;\n    this._scatterHandler = null;\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    // TODO: Determine if in dirty state, prior to closing\n    // TODO: Replace w/ UIModal\n    // if (\n    // window.confirm(`Are you sure you wish to close \"${this.getTitle()}\"?`)\n    // ) {\n\n    return super.destroy(async () => {\n      // Clear any currently scheduled resize executions\n      this._emitDebouncedResized.clear();\n\n      if (this._appRuntime && !this._appRuntime.getIsDestroying()) {\n        await this._appRuntime.destroy();\n      }\n\n      this._appRuntime = null;\n      this._elWindow = null;\n      this._elWindowManager = null;\n    });\n\n    //}\n  }\n\n  // TODO: Document\n  __INTERNAL__setCenterHandler(centerHandler) {\n    this._centerHandler = centerHandler;\n  }\n\n  // TODO: Document\n  async center() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not center correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._centerHandler();\n    }\n  }\n\n  // TODO: Document\n  __INTERNAL__setScatterHandler(scatterHandler) {\n    this._scatterHandler = scatterHandler;\n  }\n\n  // TODO: Document\n  async scatter() {\n    if (this.getIsMaximized() || this.getIsMinimized()) {\n      this.restore();\n\n      // NOTE: Sleep is used to allow window time to restore and effects run,\n      // otherwise it may not scatter correctly\n      await sleep(POST_RESTORE_POSITION_EFFECT_TIMEOUT);\n    }\n\n    if (!this.getIsDestroying()) {\n      this._scatterHandler();\n    }\n  }\n\n  // TODO: Document\n  // TODO: Rename to bringToFront and / or activate\n  bringToTop() {\n    this._handleBringToTop(this);\n  }\n\n  // TODO: Document\n  getIsActive() {\n    return this._appRuntime.getIsActive();\n  }\n\n  // TODO: Document\n  // @see https://reactjs.org/docs/profiler.html\n  captureRenderProfile(arrRenderProfile) {\n    this.emit(EVT_RENDER_PROFILED, arrRenderProfile);\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowElement(el) {\n    this._elWindow = el;\n  }\n\n  /**\n   * Retrieves the DOM element which contains the ReShell window this\n   * controller is attached to.\n   *\n   * @return {HTMLDivElement}\n   */\n  getElWindow() {\n    return this._elWindow;\n  }\n\n  // TODO: Document\n  __INTERNAL__attachWindowManagerElement(el) {\n    this._elWindowManager = el;\n  }\n\n  /**\n   * Associates an AppRuntime instance with this window controller.\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  setAppRuntime(appRuntime) {\n    // TODO: Ensure appRuntime is an AppRuntime instance\n\n    this._appRuntime = appRuntime;\n\n    // TODO: Refactor title to app runtime passing (ensure it can work both ways)\n    this._appRuntime.setTitle(this.getTitle());\n  }\n\n  /**\n   * Retrieves the associated AppRuntime for this window controller.\n   *\n   * @return {AppRuntime | void}\n   */\n  getAppRuntime() {\n    return this._appRuntime;\n  }\n\n  // TODO: Document\n  getAppRegistration() {\n    const runtime = this.getAppRuntime();\n\n    if (runtime) {\n      return runtime.getRegistration();\n    }\n  }\n\n  // TODO: Document\n  setSize({ width, height }) {\n    // Skip if maximized\n    if (this.getIsMaximized()) {\n      return;\n    }\n\n    // IMPORTANT!: Do not update state on each iteration (if at all) because that would cause excessive re-rendering\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      // FIXME: (jh) Can these be applied as a single reflow?\n      // @see https://www.sitepoint.com/10-ways-minimize-reflows-improve-performance/\n\n      requestSkippableAnimationFrame(() => {\n        if (width !== undefined) {\n          elWindow.style.width = `${width}px`;\n        }\n        if (height !== undefined) {\n          elWindow.style.height = `${height}px`;\n        }\n\n        // Emit debounced EVT_RESIZED event\n        this._emitDebouncedResized();\n      }, `${this._uuid}-size`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedResized() {\n    this.emit(EVT_RESIZED);\n  }\n\n  /**\n   * Retrieves the window's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getSize() {\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      return getElSize(elWindow);\n    } else {\n      this.log.warn(\"Unable to acquire elWindow\");\n    }\n  }\n\n  /**\n   * Retrieves the window manager's size in pixels.\n   *\n   * @param {DOMElement} el\n   * @return {{width: number, height: number}}\n   */\n  getWindowManagerSize() {\n    const elWindowManager = this._elWindowManager;\n    if (elWindowManager) {\n      return getElSize(elWindowManager);\n    } else {\n      this.log.warn(\"Unable to acquire elWindowManager\");\n    }\n  }\n\n  // TODO: Document\n  setPosition({ x, y }) {\n    // Fixes issue where restoring using widow title bar (i.e. double-click or\n    // using window control button) would make window go to upper-left of\n    // screen\n    if (this.getIsMaximized()) {\n      return;\n    }\n\n    const elWindow = this._elWindow;\n    if (elWindow) {\n      /**\n       * FIXME: (jh) While using translate would be better here, it is buggier\n       * to use with some of the window animations (open / minimize / restore)\n       *\n       * However, if able to tie directly into matrix operations provided by\n       * accelerated StackingContext, it might improve acceleration even\n       * further\n       *\n       * Additional reading:\n       *    - [will-change] https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\n       *    - [animating the box model]: https://whistlr.info/2021/box-model-animation\n       */\n\n      requestSkippableAnimationFrame(() => {\n        if (x !== undefined) {\n          elWindow.style.left = `${x}px`;\n\n          // Delete opposing right style\n          delete elWindow.style.right;\n        }\n        if (y !== undefined) {\n          elWindow.style.top = `${y}px`;\n\n          // Delete opposing bottom style\n          delete elWindow.style.bottom;\n        }\n\n        // IMPORTANT!: Do not update state on each iteration (if at all)\n        // because that would cause excessive re-rendering\n        this._emitDebouncedMoved();\n      }, `${this._uuid}-position`);\n    }\n  }\n\n  // TODO: Document\n  _emitDebouncedMoved() {\n    this.emit(EVT_MOVED);\n  }\n\n  /**\n   * Retrieves the window's upper-left-hand corner position relative to its\n   * parent (the window manager).\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n   *\n   * @param {HTMLElement} el\n   * @return {{x: number, y: number}}\n   */\n  getPosition() {\n    const elWindow = this._elWindow;\n\n    if (elWindow) {\n      return getElPosition(elWindow);\n    }\n  }\n\n  // TODO: Document\n  getIsBorderDisabled() {\n    return this.getIsMaximized() || this.getIsMinimized();\n  }\n\n  /**\n   * Sets a partial next state for this window controller.\n   *\n   * TODO: States are currently deep-merged but may become shallow merged\n   * instead.\n   *\n   * @param {Object} partialNextState\n   * @emits EVT_UPDATED\n   * @return {void}\n   */\n  setState(partialNextState) {\n    if (typeof partialNextState !== \"object\") {\n      throw new TypeError(\"partialNextState is not an object\");\n    }\n\n    // Reset polar-opposite states\n    if (partialNextState.isMaximized) {\n      partialNextState.isMinimized = false;\n    } else if (partialNextState.isMinimized) {\n      partialNextState.isMaximized = false;\n    }\n\n    return super.setState(partialNextState);\n  }\n\n  /**\n   * @param {boolean} isMaximized\n   * @return {void}\n   */\n  setIsMaximized(isMaximized) {\n    return this.setState({ isMaximized });\n  }\n\n  // TODO: Document\n  maximize() {\n    return this.setIsMaximized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is maximized.\n   *\n   * @returns {boolean}\n   */\n  getIsMaximized() {\n    return this.getState().isMaximized;\n  }\n\n  /**\n   * Sets whether or not the window is minimized.\n   *\n   * @param {boolean} isMinimized\n   * @return {void}\n   */\n  setIsMinimized(isMinimized) {\n    return this.setState({ isMinimized });\n  }\n\n  // TODO: Document\n  minimize() {\n    return this.setIsMinimized(true);\n  }\n\n  /**\n   * Retrieves whether or not the window is minimized.\n   *\n   * @return {boolean}\n   */\n  getIsMinimized() {\n    return this.getState().isMinimized;\n  }\n\n  // TODO: Document\n  restore() {\n    // IMPORTANT: The maximized / minimized states need to be set at the same\n    // time here; don't call the individual methods directly\n    this.setState({\n      isMaximized: false,\n      isMinimized: false,\n    });\n  }\n}\n","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nexport { EVT_UPDATED };\n\n/**\n * UI service class for screen resolution detection.\n */\nexport default class ScreenService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Screen Service\");\n\n    this.setState({\n      screenWidth: null,\n      screenHeight: null,\n    });\n\n    // Monitor resolution changes\n    (() => {\n      // FIXME: (jh) Debounce?\n      const _handleViewportResize = () => {\n        const { width: screenWidth, height: screenHeight } =\n          this._detectScreenResolution();\n\n        this.setState({\n          screenWidth,\n          screenHeight,\n        });\n      };\n\n      this.addNativeEventListener(\"resize\", _handleViewportResize);\n\n      // Capture initial size\n      _handleViewportResize();\n    })();\n  }\n\n  /**\n   * @return {{width: number, height: number}}\n   */\n  getScreenResolution() {\n    const { screenWidth: width, screenHeight: height } = this.getState();\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Detects the current screen resolution.\n   *\n   * @return {{width: number, height: number}}\n   */\n  _detectScreenResolution() {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  // TODO: fetchMonitorRefreshRate (via request-skippable-animation-frame)\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\n\nimport ScreenService from \"./ScreenService\";\n\nexport { EVT_UPDATED };\n\nconst DESKTOP_MINIMUM_WIDTH = 640;\nconst DESKTOP_MINIMUM_HEIGHT = 480;\n\nexport const DESKTOP_PARADIGM = \"desktop\";\nexport const MOBILE_PARADIGM = \"mobile\";\nexport const AUTO_DETECT_PARADIGM = null;\n\n/**\n * UI service class for desktop paradigm detection.\n */\nexport default class UIParadigmService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Paradigm Service\");\n\n    this._screenService = this.useServiceClass(ScreenService);\n\n    // TODO: Retain preferred setting across page loads\n    this.setState({\n      uiParadigm: AUTO_DETECT_PARADIGM,\n      isAutoSet: true,\n    });\n\n    // Monitor paradigm changes\n    (() => {\n      const _handleUIParadigmAutoDetect = () => {\n        // Skip if not auto set\n        if (!this.getState().isAutoSet) {\n          return;\n        }\n\n        this.setState({\n          uiParadigm: this._detectUIParadigm(),\n        });\n      };\n\n      this.proxyOn(this._screenService, EVT_UPDATED, () =>\n        _handleUIParadigmAutoDetect()\n      );\n\n      // Perform initial auto-detection\n      _handleUIParadigmAutoDetect();\n    })();\n  }\n\n  /**\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | AUTO_DETECT_PARADIGM} uiParadigm If set to\n   * null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(uiParadigm) {\n    if (\n      uiParadigm !== DESKTOP_PARADIGM &&\n      uiParadigm !== MOBILE_PARADIGM &&\n      uiParadigm !== AUTO_DETECT_PARADIGM\n    ) {\n      throw new Error(\n        `uiParadigm must be set to \"${DESKTOP_PARADIGM}\", \"${MOBILE_PARADIGM}\", or null`\n      );\n    }\n\n    if (uiParadigm) {\n      this.setState({\n        uiParadigm,\n        // Skip auto-set\n        isAutoSet: false,\n      });\n    } else {\n      this.setState({\n        uiParadigm: this._detectUIParadigm(),\n        // Reset to auto-set\n        isAutoSet: true,\n      });\n    }\n  }\n\n  /**\n   * Retrieves if the UI paradigm is automatically set, otherwise being\n   * manually set.\n   *\n   * @return {boolean}\n   */\n  getIsAutoSet() {\n    return this.getState().isAutoSet;\n  }\n\n  /**\n   * Retrieves the paradigm of the ReShell environment.\n   *\n   * @return {DESKTOP_PARADIGM | MOBILE_PARADIGM}\n   */\n  getUIParadigm() {\n    return this.getState().uiParadigm;\n  }\n\n  /**\n   * Detects the current desktop paradigm.\n   *\n   * @return {boolean}\n   */\n  _detectUIParadigm() {\n    const { screenWidth, screenHeight } = this._screenService.getState();\n\n    let uiParadigm = DESKTOP_PARADIGM;\n\n    if (\n      screenWidth < DESKTOP_MINIMUM_WIDTH ||\n      screenHeight < DESKTOP_MINIMUM_HEIGHT\n    ) {\n      uiParadigm = MOBILE_PARADIGM;\n    }\n\n    return uiParadigm;\n  }\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * Usage:\n *  const forceUpdate = useForceUpdate()\n *\n * @return {Function} Force update function, guaranteed to have a stable\n * reference across renders.\n */\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // IMPORTANT: Don't sort these here unless the result can be memoized\n    return this.getChildren();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration, appOrchestrationService) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n    this._appOrchestrationService = appOrchestrationService;\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, data => {\n      this.emit(EVT_UPDATED, data);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOnce(this._appRegistration, EVT_DESTROYED, () => {\n      if (!this.getIsDestroying()) {\n        this.destroy();\n      }\n    });\n\n    this._windowController = null;\n\n    this.registerCleanupHandler(async () => {\n      if (!this.getIsDestroying()) {\n        this._windowController.destroy();\n      }\n\n      this._appRegistration = null;\n      this._appOrchestrationService = null;\n      this._windowController = null;\n\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  getIsActive() {\n    return this === this._appOrchestrationService.getActiveAppRuntime();\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration?.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n\n    this._desktopService = this.useServiceClass(DesktopService);\n  }\n\n  // TODO: Import WindowController type\n  /**\n   * Retrieves all of the window controllers for all of the running apps.\n   *\n   * @return {WindowController[]}\n   */\n  getWindowControllers() {\n    return this.getAppRuntimes()\n      .map(runtime => runtime.getWindowController())\n      .filter(windowController => windowController);\n  }\n\n  // TODO: Document\n  getActiveAppRegistration() {\n    return this.getActiveWindowController()?.getAppRegistration();\n  }\n\n  // TODO: Document\n  getActiveAppRuntime() {\n    return this.getActiveWindowController()?.getAppRuntime();\n  }\n\n  // TODO: Document\n  getActiveWindowController() {\n    return this._desktopService.getActiveWindowController();\n  }\n\n  // TODO: Import WindowController type\n  /**\n   * Retrieves the window controller with the given UUID.\n   *\n   * @param {uuid} string\n   * @return {WindowController | void}\n   */\n  getWindowControllerWithUUID(uuid) {\n    let matchedWindowController;\n\n    for (const windowController of this.getWindowControllers()) {\n      if (windowController.getUUID() === uuid) {\n        matchedWindowController = windowController;\n        break;\n      }\n    }\n\n    return matchedWindowController;\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithID(appRegistrationID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appRegistrationID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appRegistrationID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration, this);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getRunningAppRegistrations().includes(appRegistration)) {\n      // Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      //\n      // TODO: Incorporate this logic:\n      // \"The user can also click an apps Dock icon to bring all of that apps\n      // windows forward; the most recently accessed app window becomes the key\n      // window.\"\n      // (Ref. \"Activating Windows\": https://developer.apple.com/design/human-interface-guidelines/macos/windows-and-views/window-anatomy/)\n      //\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationWithID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the currently registered app with the given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRegistration | void}\n   */\n  getAppRegistrationWithID(appRegistrationID) {\n    return this.getAppRegistrations().find(\n      registration => registration.getID() === appRegistrationID\n    );\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * NOTE: This is not named \"getActiveAppRegistrations\" because the \"active\"\n   * connotes the top-most window.\n   *\n   * @return {AppRegistration[]}\n   */\n  getRunningAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves whether or not an AppRegistration with the given ID is running.\n   *\n   * @param {string} appRegistrationID\n   * @return {boolean}\n   */\n  getIsAppRegistrationRunningWithID(appRegistrationID) {\n    return Boolean(\n      this.getRunningAppRegistrations().find(\n        registration => registration.getID() === appRegistrationID\n      )\n    );\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    // TODO: Validate against proper type\n    if (!Object.keys(appDescriptor).length) {\n      throw new TypeError(\n        \"appDescriptor does not appear to be a valid application descriptor\"\n      );\n    }\n\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * Retrieves the app descriptor's ID.\n   *\n   * NOTE: [appRegistration]ID and appDescriptorID are synonymous here, however\n   * they should not be confused with UUID and shortUUID.\n   *\n   * @return {string}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * Alias for this.getID().\n   *\n   * NOTE: [appRegistration]ID and appDescriptorID are synonymous here, however\n   * they should not be confused with UUID and shortUUID.\n   *\n   * @alias <getAppDescriptorID>\n   */\n  getAppDescriptorID() {\n    return this.getID();\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Remove; manage via a service\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","/**\n * Retrieves the given element's size in pixels.\n *\n * @param {DOMElement} el\n * @return {{width: number, height: number}}\n */\nexport default function getElSize(el) {\n  const width = el.offsetWidth;\n  const height = el.offsetHeight;\n\n  return {\n    width,\n    height,\n  };\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport AppRegistration from \"./AppOrchestrationService/classes/AppRegistration\";\n\nimport KeyVaultService from \"@services/KeyVaultService\";\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\n/**\n * @typedef {{[key: string], priority: number}} AppAutoStartConfigs\n */\n\nconst KEY_SESSION_STORAGE_APP_AUTOSTART = \"app-autostart\";\n\n/**\n * Manages which applications should automatically start once ReShell loads.\n */\nexport default class AppAutoStartService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Auto Start Service\");\n\n    this.setState({\n      /** @type {AppAutoStartConfigs} */\n      appAutoStartConfigs: {},\n    });\n\n    this._appOrchestrationService = this.useServiceClass(\n      AppOrchestrationService\n    );\n\n    this._keyVaultService = this.useServiceClass(KeyVaultService);\n\n    this._localStorageEngine =\n      this._keyVaultService.getSecureLocalStorageEngine();\n    this.registerCleanupHandler(() => (this._localStorageEngine = null));\n\n    // Auto-cache auto start configs\n    this.on(EVT_UPDATED, updatedState => {\n      const nextAutoStartConfigs = updatedState.appAutoStartConfigs;\n\n      if (nextAutoStartConfigs !== undefined) {\n        this._localStorageEngine.setItem(\n          KEY_SESSION_STORAGE_APP_AUTOSTART,\n          nextAutoStartConfigs\n        );\n      }\n    });\n\n    // Auto-load from cache\n    //\n    // FIXME: (jh) I'm not positive if this could potentially lead to a race\n    // condition before setDefaultAppAutoStartConfig is externally called, or\n    // if the config is used in the useAppRuntimesAutoStart hook. This might\n    // need to be refactored.\n    this._localStorageEngine.fetchItem(KEY_SESSION_STORAGE_APP_AUTOSTART).then(\n      cachedAutoStartConfigs =>\n        cachedAutoStartConfigs &&\n        // TODO: Perform validation step\n        this.setState({ appAutoStartConfigs: cachedAutoStartConfigs })\n    );\n  }\n\n  /**\n   * Sets the default AppRegistrations and priorities, should they not already\n   * be available in the cache.\n   *\n   * @param {AppAutoStartConfigs} appAutoStartConfigs\n   * @return {void}\n   */\n  setDefaultAppAutoStartConfigs(appAutoStartConfigs) {\n    if (!Object.keys(this.getAppAutoStartConfigs()).length) {\n      // TODO: Perform validation step\n\n      this.setState({\n        appAutoStartConfigs,\n      });\n    }\n  }\n\n  /**\n   * Adds or updates the given AppRegistration and priority in the auto-start\n   * sequence.\n   *\n   * @param {AppRegistration} appRegistration\n   * @param {number} priority? [default=0] The higher the priority, the more\n   * preference the window is given in the window stack.\n   */\n  setAutoStartAppRegistration(appRegistration, priority = 0) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    const nextAutoStartConfigs = { ...this.getState().appAutoStartConfigs };\n    nextAutoStartConfigs[appRegistration.getAppDescriptorID()] = {\n      priority,\n    };\n\n    this.setState({\n      appAutoStartConfigs: nextAutoStartConfigs,\n    });\n  }\n\n  /**\n   * Removes the given AppRegistration from the auto-start.\n   *\n   * @param {AppRegistration} appRegistration\n   */\n  removeAutoStartAppRegistration(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    const nextAutoStartConfigs = { ...this.getState().appAutoStartConfigs };\n    delete nextAutoStartConfigs[appRegistration.getAppDescriptorID()];\n\n    this.setState({\n      appAutoStartConfigs: nextAutoStartConfigs,\n    });\n  }\n\n  /**\n   * Retrieves the auto-start configurations.\n   *\n   * @return {AutoStartConfigs}\n   */\n  getAppAutoStartConfigs() {\n    return this.getState().appAutoStartConfigs;\n  }\n\n  /**\n   * Retrieves a prioritized list of AppRegistration instances.\n   *\n   * @return {AppRegistration[]}\n   */\n  getPrioritizedAppAutoStartRegistrations() {\n    const prioritizedAppAutoStartConfigs = Object.entries(\n      this.getAppAutoStartConfigs()\n    )\n      .sort(\n        (\n          [registrationID_A, metadata_A = {}],\n          [registrationID_B, metadata_B = {}]\n        ) => {\n          if (metadata_A.priority < metadata_B.priority) {\n            return -1;\n          } else {\n            return 1;\n          }\n        }\n      )\n      .map(([registrationID]) =>\n        this._appOrchestrationService.getAppRegistrationWithID(registrationID)\n      )\n      .filter(registration => registration);\n\n    return prioritizedAppAutoStartConfigs;\n  }\n}\n","/**\n * Retrieves the given element's upper-left-hand corner position in pixels\n * relative to its parent.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop}\n *\n * @param {HTMLElement} el\n * @return {{x: number, y: number}}\n */\nexport default function getElPosition(el) {\n  return {\n    x: el.offsetLeft,\n    y: el.offsetTop,\n  };\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useUIServicesAutoStart from \"./hooks/useUIServicesAutoStart\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  // Startup auto-start services\n  useUIServicesAutoStart(startServiceClass);\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport UIParadigmService from \"./UIParadigmService\";\nimport UINotificationService from \"./UINotificationService\";\n\n/**\n * Manages state for the DesktopServiceProvider.\n */\nexport default class DesktopService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Desktop Service\");\n\n    this._uiParadigmService = this.useServiceClass(UIParadigmService);\n    this._uiNotificationService = this.useServiceClass(UINotificationService);\n\n    this.setState({\n      isProfiling: false,\n      activeWindowController: null,\n      uiParadigm: this._uiParadigmService.getUIParadigm(),\n      isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n    });\n\n    // Mirror UI paradigm service updates to local state\n    //\n    // FIXME: (jh) Perhaps get rid of UIParadigmService altogether; this\n    // shouldn't need to be mirrored like this\n    this._uiParadigmService.on(EVT_UPDATED, () => {\n      this.setState({\n        uiParadigm: this._uiParadigmService.getUIParadigm(),\n        isUIParadigmAutoSet: this._uiParadigmService.getIsAutoSet(),\n      });\n    });\n\n    // Auto-null activeWindowController state if the current one is destructed\n    //\n    // FIXME: (jh) This logic is a bit more complicated than it should be;\n    // perhaps PhantomCore could offer some way of doing state comparisons\n    // like dependencies do for React useEffect\n    (() => {\n      // Deactivate hook window controller state if destructed\n      const _handleWindowControllerDestruct = () => {\n        this.setActiveWindowController(null);\n      };\n\n      let prevActiveWindowController = null;\n\n      this.on(EVT_UPDATED, isProfiling => {\n        const activeWindowController = this.getActiveWindowController();\n\n        // Only run comparison if active window controller has changed\n        if (activeWindowController !== prevActiveWindowController) {\n          if (prevActiveWindowController) {\n            this.proxyOff(\n              prevActiveWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          if (activeWindowController) {\n            this.proxyOnce(\n              activeWindowController,\n              EVT_DESTROYED,\n              _handleWindowControllerDestruct\n            );\n          }\n\n          prevActiveWindowController = activeWindowController;\n        }\n      });\n    })();\n  }\n\n  /**\n   * Sets whether or not the windows should run React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @param {boolean} isProfiling\n   * @return {void}\n   */\n  setIsProfiling(isProfiling) {\n    this.setState({ isProfiling });\n\n    // FIXME: (jh) Show develop icon\n    this._uiNotificationService.showNotification({\n      title: `Desktop profiling ${isProfiling ? \"enabled\" : \"disabled\"}`,\n      body: `Desktop profiling has been ${\n        isProfiling ? \"enabled\" : \"disabled\"\n      }.`,\n    });\n  }\n\n  /**\n   * Retrieves whether or not the windows are running React.Profiler.\n   *\n   * @see {@link https://reactjs.org/docs/profiler.html}\n   *\n   * @return {boolean}\n   */\n  getIsProfiling() {\n    return this.getState().isProfiling;\n  }\n\n  /**\n   * Sets the active (top-most) window.\n   *\n   * @param {WindowController | null} activeWindowController\n   */\n  setActiveWindowController(activeWindowController) {\n    if (\n      activeWindowController !== null &&\n      !(activeWindowController instanceof WindowController)\n    ) {\n      throw new TypeError(\"activeWindowController must be a WindowController\");\n    }\n\n    this.setState({ activeWindowController });\n  }\n\n  /**\n   * Retrieves the active (top-most) window controller.\n   *\n   * @return {WindowController | null}\n   */\n  getActiveWindowController() {\n    return this.getState().activeWindowController;\n  }\n\n  /**\n   * @typedef {import('./UIParadigmService').DESKTOP_PARADIGM} DESKTOP_PARADIGM\n   * @typedef {import('./UIParadigmService').MOBILE_PARADIGM} MOBILE_PARADIGM\n   *\n   * @param {DESKTOP_PARADIGM | MOBILE_PARADIGM | AUTO_DETECT_PARADIGM} staticUIParadigm If set\n   * to null, auto-set will be re-enabled.\n   */\n  setStaticUIParadigm(staticUIParadigm) {\n    this._uiParadigmService.setStaticUIParadigm(staticUIParadigm);\n  }\n}\n","import UIServiceCore from \"@core/classes/UIServiceCore\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport const EVT_NOTIFICATION = \"notification\";\n\n// TODO: Implement ability to store previous notifications so they can be retrieved\n\n/**\n * Handles management of UI notifications.\n */\nexport default class UINotificationService extends UIServiceCore {\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"UI Notification Service\");\n\n    this.setState({\n      notifications: [],\n    });\n  }\n\n  // TODO: Document\n  // TODO: Borrow API from Apple: https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/DisplayNotifications.html#//apple_ref/doc/uid/TP40016239-CH61-SW1\n  showNotification({ image, title, body, onClick, onClose = () => null }) {\n    // TODO: Capture notification time\n\n    this.setState({\n      // Add new notifications to end of stack\n      notifications: [\n        ...this.getState().notifications,\n        {\n          image,\n          title,\n          body,\n          onClick,\n          onClose,\n          uuid: uuidv4(),\n        },\n      ],\n    });\n  }\n\n  // TODO: Document\n  closeNotificationWithUUID(uuid) {\n    const next = this.getState().notifications.filter(\n      ({ uuid: prevUUID, onClose }) => {\n        const isKept = uuid !== prevUUID;\n\n        if (!isKept) {\n          // Call the onClose handler passed to showNotification\n          onClose();\n        }\n\n        return isKept;\n      }\n    );\n\n    this.setState({\n      notifications: next,\n    });\n  }\n}\n","import { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\n/**\n * Grabs the app registration ID from the current React Router location.\n *\n * @return {string | void}\n */\nexport default function useLocationAppRegistrationID() {\n  const location = useLocation();\n\n  const [appRegistrationID, setAppRegistrationID] = useState(null);\n\n  useEffect(() => {\n    // Remove leading forward slash (/) from location\n    const appRegistrationID = location.pathname?.substring(1);\n\n    setAppRegistrationID(appRegistrationID);\n  }, [location]);\n\n  return appRegistrationID;\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} srcList An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {{isPreloaded: boolean, progress: number}}\n */\nexport default function usePreload(srcList) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the srcList; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refSrcList = useRef(srcList);\n\n  useEffect(() => {\n    const resources = refSrcList.current;\n\n    if (resources && !Array.isArray(resources)) {\n      throw new Error(\"usePreload resources should be an array\");\n    }\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import { PhantomState, EVT_UPDATED, EVT_BEFORE_DESTROY } from \"phantom-core\";\nimport { getClassName } from \"phantom-core\";\nimport persistentSpyAgentCollection from \"../persistentSpyAgentCollection\";\n\n// TODO: Document\nexport default class SpyAgent extends PhantomState {\n  /**\n   * Create a reusable signature.\n   *\n   * TODO: Document parameters\n   */\n  static createSpyAgentSignature(spiesOn, initialState) {\n    /** @type {Map<any, SpyAgent>} */\n    const spyAgentMap = new Map();\n\n    return (scope, updatedState = {}) => {\n      let spyAgent = spyAgentMap.get(scope);\n\n      if (\n        !spyAgent ||\n        spyAgent.getIsDestroying() ||\n        spyAgent.getIsDestroyed()\n      ) {\n        spyAgent = new SpyAgent(spiesOn, initialState);\n\n        spyAgentMap.set(scope, spyAgent);\n\n        // Remove from scope once entering shutdown phase\n        spyAgent.once(EVT_BEFORE_DESTROY, () => {\n          // Note: While this prev check shouldn't be necessary it provides\n          // double-assurance that we're not accidentally deleting a scoped\n          // instance that we shouldn't be\n          const prev = spyAgentMap.get(scope);\n          if (prev === spyAgent) {\n            spyAgentMap.delete(scope);\n          }\n        });\n      }\n\n      spyAgent.setState(updatedState);\n\n      return spyAgent;\n    };\n  }\n\n  constructor(spiesOn, initialState = {}) {\n    super(initialState);\n\n    this._spiesOn = spiesOn;\n    this._spiesOnClassName = getClassName(spiesOn);\n\n    persistentSpyAgentCollection.addChild(this);\n\n    // Obtain agent title from state\n    this.on(EVT_UPDATED, updatedState => {\n      const { address, url } = updatedState || {};\n\n      if (address || url) {\n        this.setTitle(address || url);\n      }\n    });\n\n    this.registerCleanupHandler(() => {\n      // FIXME: (jh) Ensure PhantomState itself prevents memory leaks on its\n      // own by resetting its state internally on cleanup\n      this.setState({});\n\n      persistentSpyAgentCollection.removeChild(this);\n    });\n  }\n\n  // TODO: Document\n  getSpiesOn() {\n    return this._spiesOn;\n  }\n\n  /**\n   * @return {string}\n   */\n  getSpiedOnClassName() {\n    return this._spiesOnClassName;\n  }\n}\n","import { PhantomCollection } from \"phantom-core\";\nimport SpyAgent from \"./registerSpyAgent/SpyAgent\";\n\n// TODO: Rename?\n// TODO: Document\nclass SpyAgentCollection extends PhantomCollection {\n  /**\n   * @param {SpyAgent} spyAgent SpyAgent instance\n   * @return {void}\n   */\n  addChild(spyAgent) {\n    if (!spyAgent instanceof SpyAgent) {\n      throw new TypeError(\"spyAgent is not a SpyAgent\");\n    }\n\n    return super.addChild(spyAgent);\n  }\n}\n\n// Use as a singleton\nexport default new SpyAgentCollection();\n","import SpyAgent from \"./SpyAgent\";\n\nconst nativeSpies = [];\n\n/**\n * Registers a higher-order function to track usage of lower-level APIs.\n *\n * TODO: Document params\n */\nexport default function registerSpyAgent(spiesOn, initialState, initFn) {\n  if (nativeSpies.includes(spiesOn)) {\n    throw new Error(\"Cannot add duplicate native spy\");\n  }\n\n  nativeSpies.push(spiesOn);\n\n  const signature = SpyAgent.createSpyAgentSignature(spiesOn, initialState);\n\n  initFn(signature);\n}\n\nexport { nativeSpies };\n","import registerSpyAgent, { nativeSpies } from \"./registerSpyAgent\";\n\nexport default registerSpyAgent;\nexport { nativeSpies };\n","import registerSpyAgent from \"../registerSpyAgent\";\n\nconst NativeWebSocket = window.WebSocket;\n\nif (NativeWebSocket) {\n  registerSpyAgent(\n    NativeWebSocket,\n    { address: null, isOpen: false, error: null },\n    invokeSpyAgent => {\n      /**\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n       */\n      class WebSocketSpy extends NativeWebSocket {\n        constructor(address, ...args) {\n          super(address, ...args);\n\n          // Initiate spy agent with initial state for this WebSocket instance\n          invokeSpyAgent(this, { address });\n\n          this.addEventListener(\"open\", () => {\n            // Register open state w/ spy agent\n            invokeSpyAgent(this, { isOpen: true, error: null });\n          });\n\n          // TODO: Inspect traffic?\n\n          this.addEventListener(\"close\", () => {\n            // Register close state w/ spy agent, then destruct the agent\n            invokeSpyAgent(this, { isOpen: false }).destroy();\n          });\n\n          this.addEventListener(\"error\", error => {\n            // Register error state w/ spy agent, then destruct the agent\n            invokeSpyAgent(this, { error }).destroy();\n          });\n        }\n      }\n\n      // Override the native WebSocket object\n      window.WebSocket = WebSocketSpy;\n    }\n  );\n}\n","import registerSpyAgent from \"../registerSpyAgent\";\n\nconst NativeWorker = window.Worker;\n\nif (NativeWorker) {\n  registerSpyAgent(\n    NativeWorker,\n    { url: null, isOpen: false, error: null },\n    invokeSpyAgent => {\n      /**\n       * @see hhttps://developer.mozilla.org/en-US/docs/Web/API/Worker\n       */\n      class WorkerSpy extends NativeWorker {\n        constructor(url, ...args) {\n          super(url, ...args);\n\n          // Initiate spy agent with initial state for this Worker instance\n          invokeSpyAgent(this, { url, isOpen: true });\n\n          this.addEventListener(\"error\", error => {\n            invokeSpyAgent(this, { error });\n          });\n\n          // TODO: Poll to determine if still open? We can determine if \"closed\n          // from the outside\" via wrapping terminate, but may need to poll if\n          // closing from the inside\n        }\n\n        /**\n         * @return {void}\n         */\n        terminate() {\n          super.terminate();\n\n          invokeSpyAgent(this, { isOpen: false }).destroy();\n        }\n      }\n\n      // Override the native Worker object\n      window.Worker = WorkerSpy;\n    }\n  );\n}\n","import UIServiceCore, { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport persistentSpyAgentCollection from \"./persistentSpyAgentCollection\";\n\n// Register spies\nimport \"./spies/WebSocket.spy\";\nimport \"./spies/WebWorker.spy\";\n\nimport { nativeSpies } from \"./registerSpyAgent\";\n\n/**\n * IMPORTANT: For best results this service should be started up while ReShell\n * is \"booting\".\n */\nexport default class NativeSpyService extends UIServiceCore {\n  /**\n   * My spy service...\n   */\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"Native JavaScript Spy Service\");\n\n    this.setState({ spyAgents: [] });\n\n    this._persistentSpyAgentCollection = persistentSpyAgentCollection;\n\n    this.proxyOn(this._persistentSpyAgentCollection, EVT_UPDATED, () => {\n      // TODO: Debounce (this could render a lot depending on how the spy is\n      // set up, esp. w/ WebSocket connections)\n\n      const spyAgents = this._persistentSpyAgentCollection.getChildren();\n\n      this.setState({ spyAgents });\n    });\n  }\n\n  // TODO: Document\n  getRegisteredSpies() {\n    return nativeSpies;\n  }\n\n  // TODO: Document\n  getSpyAgents() {\n    return this.getState().spyAgents;\n  }\n}\n","import NativeSpyService from \"./NativeSpyService\";\n\nexport default NativeSpyService;\n","import { EVT_UPDATED } from \"phantom-core\";\nimport { useEffect } from \"react\";\nimport WindowController from \"@components/Window/classes/WindowController\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\n// FIXME: (jh) Refactor [native] window title setting\nconst INITIAL_DOCUMENT_TITLE = document.title;\n\n// FIXME: (jh) [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n/**\n * Manages setting of the HTML document title and related effects when the\n * active window controller is changed.\n *\n * @param {WindowController | null} activeWindowController\n * @return {void}\n */\nexport default function useActiveWindowController(activeWindowController) {\n  if (\n    activeWindowController !== null &&\n    !(activeWindowController instanceof WindowController)\n  ) {\n    throw new TypeError(\"activeWindowController must be a WindowController\");\n  }\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  //\n  // FIXME: (jh) This can probably be removed now that the active window\n  // controller is managed by a service\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // FIXME: (jh) Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = INITIAL_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${INITIAL_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport DesktopService from \"@services/DesktopService\";\n\nexport const DesktopServiceContext = React.createContext({});\n\n/**\n * Provides the React app DesktopService UIServiceCore binding.\n */\nexport default function DesktopServiceProvider({ children }) {\n  const { serviceInstance: desktopService } = useServiceClass(DesktopService);\n\n  const desktopState = desktopService.getState();\n\n  useActiveWindowController(desktopState.activeWindowController);\n\n  return (\n    <DesktopServiceContext.Provider\n      value={{\n        ...desktopState,\n        setActiveWindowController: desktopService.setActiveWindowController,\n        setStaticUIParadigm: desktopService.setStaticUIParadigm,\n        setIsProfiling: desktopService.setIsProfiling,\n      }}\n    >\n      {children}\n    </DesktopServiceContext.Provider>\n  );\n}\n","import DesktopServiceProvider, {\n  DesktopServiceContext,\n} from \"./DesktopServiceProvider\";\n\nexport default DesktopServiceProvider;\nexport { DesktopServiceContext };\n","/**\n * FIXME: (jh) This video might provide some interesting insight for stacking\n * context or layout components:\n * @see https://www.youtube.com/watch?v=Xt1Cw4qM3Ec (Secret Mechanisms of CSS)\n */\n\nimport React from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nconst StackingContext = React.forwardRef(\n  ({ className, children, isAccelerated = false, ...rest }, ref) => {\n    return (\n      <div\n        ref={ref}\n        {...rest}\n        className={classNames(\n          styles[\"stacking-context\"],\n          isAccelerated && styles[\"accelerated\"],\n          className\n        )}\n      >\n        {children}\n      </div>\n    );\n  }\n);\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n};\n\nexport default StackingContext;\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","import React, { useEffect } from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nexport const AppOrchestrationServiceContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationServiceProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const runningAppRegistrations =\n    appOrchestrationService.getRunningAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n\n  // Sort app registrations in place\n  //\n  // FIXME: (jh) It would be better to move this functionality into the\n  // collection itself; this also might not handle situations where updating\n  // a registration title during runtime will automatically re-apply the sort.\n  // Relevant issue: https://github.com/jzombie/pre-re-shell/issues/172\n  useEffect(() => {\n    appRegistrations\n      // Locale compare sort fix borrowed from: https://dev.to/charlesmwray/comment/l899\n      .sort((a, b) => {\n        return a.getTitle().localeCompare(\n          b.getTitle(),\n          // TODO: Replace hardcoding with dynamic variable\n          \"en\",\n          { sensitivity: \"base\" }\n        );\n      });\n  }, [appRegistrations]);\n\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n\n  // TODO: If enabling, this needs to be memoized (or contained within a\n  // phantom collection)\n  /*\n  const windowControllers = appRuntimes\n    .map(runtime => runtime.getWindowController())\n    // Don't include runtimes without window controllers\n    .filter(pred => pred);\n  */\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationWithID =\n    appOrchestrationService.activateAppRegistrationWithID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithID =\n    appOrchestrationService.getAppRegistrationTitleWithID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationServiceContext.Provider\n      value={{\n        runningAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        // windowControllers,\n        //\n        activateAppRegistration,\n        activateAppRegistrationWithID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationServiceContext.Provider>\n  );\n}\n","import AppOrchestrationServiceProvider, {\n  AppOrchestrationServiceContext,\n} from \"./AppOrchestrationServiceProvider\";\n\nexport default AppOrchestrationServiceProvider;\nexport { AppOrchestrationServiceContext };\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\n// TODO: Document\n// TODO: Add prop-types\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  // i.e. \"1s\"\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"request-skippable-animation-frame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {boolean} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(getIsOverflown);\n\n  refPrevIsOverflown.current = isOverflown;\n\n  // TODO: Replace w/ useUUID\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      // FIXME: (jh) Debounce? (even though it's called within\n      // requestAnimationFrame it probably doesn't need to check at 60+fps)\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","import LoadingSpinner from \"./LoadingSpinner\";\n\nexport default LoadingSpinner;\n","import styles from \"./LoadingSpinner.module.css\";\n\n// @see https://loading.io/css/\nexport default function LoadingSpinner() {\n  return (\n    <div className={styles[\"lds-spinner\"]}>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n    </div>\n  );\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","import { useEffect, useRef } from \"react\";\n\nimport useLocationAppRegistrationID from \"@hooks/useLocationAppRegistrationID\";\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppAutoStartService from \"@services/AppAutoStartService\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  const locationAppRegistrationID = useLocationAppRegistrationID();\n\n  const { serviceInstance: appAutoStartService } = useServiceClass(\n    AppAutoStartService,\n    false\n  );\n\n  // Automatically start\n  //\n  // TODO: Move this functionality to AppAutoStartService\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      refHasBegunAutoStart.current = true;\n\n      const prioritizedAutoStartAppRegistrations =\n        appAutoStartService.getPrioritizedAppAutoStartRegistrations();\n      for (const registration of prioritizedAutoStartAppRegistrations) {\n        activateAppRegistration(registration);\n      }\n\n      // IMPORTANT: The setImmediate call fixes an issue where deep-linked apps\n      // would not focus\n      setImmediate(() => {\n        if (locationAppRegistrationID) {\n          const locationAppRegistration = appRegistrations.find(\n            registration => registration.getID() === locationAppRegistrationID\n          );\n\n          if (locationAppRegistration) {\n            activateAppRegistration(locationAppRegistration);\n          }\n        }\n      });\n    }\n  }, [\n    locationAppRegistrationID,\n    appRegistrations,\n    activateAppRegistration,\n    appAutoStartService,\n  ]);\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"lds-spinner\":\"LoadingSpinner_lds-spinner__DjRnb\"};","/**\n * This file contains optional startup classes which are not required to start\n * up the desktop itself, but help augment some of its functionality.\n */\n\nimport NativeSpyService from \"@services/NativeSpyService\";\n\nconst STARTUP_SERVICE_CLASSES = [NativeSpyService];\n\nexport default STARTUP_SERVICE_CLASSES;\n","import { useEffect } from \"react\";\nimport startupServiceClasses from \"../../../startupServiceClasses\";\n\n// TODO: Document\nexport default function useUIServicesAutoStart(startServiceClass) {\n  useEffect(() => {\n    if (startServiceClass) {\n      for (const serviceClass of startupServiceClasses) {\n        startServiceClass(serviceClass);\n      }\n    }\n  }, [startServiceClass]);\n}\n"],"sourceRoot":""}