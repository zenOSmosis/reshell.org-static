{"version":3,"sources":["utils/getIsElOverflown.js","hooks/useOverflowDetection.js","components/Center/index.jsx","components/Center/Center.jsx","components/Full/Full.jsx","components/Full/index.jsx","components/Cover/Cover.jsx","components/Cover/index.jsx","hooks/useServiceClass.js","utils/requestSkippableAnimationFrame.js","hooks/useForceUpdate.js","hooks/useServicesContext.js","core/providers/UIServicesProvider/index.jsx","core/providers/UIServicesProvider/UIServicesProvider.jsx","hooks/useAnimation.js","hooks/usePreload.js","services/AppOrchestrationService/classes/AppRegistration.js","services/AppOrchestrationService/classes/AppRegistrationCollection.js","services/AppOrchestrationService/classes/AppRuntime.js","services/AppOrchestrationService/classes/AppRuntimeCollection.js","services/AppOrchestrationService/AppOrchestrationService.js","services/AppOrchestrationService/index.js","core/providers/AppOrchestrationProvider/AppOrchestrationProvider.jsx","core/providers/AppOrchestrationProvider/index.js","core/providers/AppOrchestrationProvider/useAppRuntimesAutoStart.js","core/providers/DesktopProvider/hooks/useActiveWindowController.js","core/providers/DesktopProvider/classes/BackgroundAssetCollection.js","core/providers/DesktopProvider/DesktopProvider.jsx","core/providers/DesktopProvider/index.jsx","core/providers/DesktopProvider/hooks/useBackgroundAssetCollection.js","components/Animation/index.jsx","components/Animation/Animation.jsx","components/StackingContext/index.jsx","components/StackingContext/StackingContext.jsx","components/StackingContext/StackingContext.module.css","components/Full/Full.module.css","components/Cover/Cover.module.css","components/Animation/Animation.module.css","components/Center/Center.module.css"],"names":["getIsElOverflown","element","innerOffsetHeight","offsetHeight","innerOffsetWidth","offsetWidth","parentNode","outerHeight","clientHeight","outerWidth","clientWidth","window","ResizeObserver","install","Center","children","className","canOverflow","rest","useState","innerEl","setInnerEl","isOverflown","useOverflowDetection","isDetecting","refPrevIsOverflown","useRef","getIsOverflown","useCallback","setIsOverflown","current","uuid","useMemo","uuidv4","useEffect","_isUnmounting","checkIsOverflown","prevIsOverflown","nextIsOverflown","ro","requestSkippableAnimationFrame","observe","unmount","unobserve","classNames","styles","ref","Full","render","this","props","StackingContext","Component","React","forwardRef","Cover","forwardedRef","isVisible","useServiceClass","ServiceClass","startServiceClass","useServicesContext","serviceInstance","serviceState","setServiceState","_handleServiceUpdate","getState","on","EVT_UPDATED","off","addFrameHandler","frameGroups","isRunning","idx","_batchRunner","groupNames","Object","keys","pending","length","groupName","frameFunc","priority","requestAnimationFrame","useForceUpdate","refIsUnmount","setAlt","alt","useContext","UIServicesContext","UIServicesProvider","createContext","forceUpdate","_uiServiceManager","ReShellCore","getUIServiceManager","_handleServiceAddedOrRemoved","setImmediate","EVT_CHILD_INSTANCE_ADDED","EVT_CHILD_INSTANCE_REMOVED","Provider","value","services","getChildren","useAnimation","domElement","animationName","animationDuration","animationDelay","onAnimationEnd","animationEngine","isDisabled","shouldRun","console","warn","refOnAnimationEnd","classes","classList","style","visibility","Error","BASE","contains","add","addEventListener","removeEventListener","usePreload","resources","isPreloaded","_setIsPreloaded","progress","_setProgress","refResources","preload","Preload","onprogress","evt","oncomplete","fetch","_registrations","AppRegistration","appDescriptor","_appDescriptor","id","getAppDescriptor","getID","getTitle","title","getMenu","menu","getIsPinned","Boolean","isPinned","getIsPinnedToDock","isPinnedToDock","getIsAutoStart","isAutoStart","a","updateAppDescriptor","emit","appDescriptorOrID","destroy","PhantomCore","AppRegistrationCollection","addChild","appRegistration","TypeError","addAppRegistration","removeAppRegistration","removeChild","getAppRegistrations","sort","b","aTitle","bTitle","reverse","PhantomCollection","AppRuntime","_appRegistration","registerShutdownHandler","proxyOn","EVT_DESTROYED","_windowController","bringToTop","__INTERNAL__setWindowController","windowController","getWindowController","getRegistration","getRegistrationID","getEnvironment","process","AppRuntimeCollection","appRuntime","addAppRuntime","removeAppRuntime","getAppRuntimes","AppOrchestrationService","args","setTitle","_appRegistrationCollection","bindCollectionClass","_appRuntimeCollection","getAppRegistrationTitleWithDescriptorID","appDescriptorID","find","predicate","addOrUpdateAppRegistration","_launchAppRegistration","activateAppRegistration","getActiveAppRegistrations","includes","filter","runtime","forEach","activateAppRegistrationID","appRegistrationID","log","Set","map","getAppRuntimesWithRegistrationID","UIServiceCore","AppOrchestrationContext","AppOrchestrationProvider","appOrchestrationService","activeAppRegistrations","appRegistrations","appRuntimes","useAppRuntimesAutoStart","refHasBegunAutoStart","registration","DEFAULT_DOCUMENT_TITLE","document","BackgroundAssetCollection","addBackgroundAsset","backgroundAsset","removeBackgroundAsset","getBackgroundAssets","DesktopContext","DesktopProvider","useActiveWindowController","activeWindowController","setActiveWindowController","forceDesktopUpdate","_handleUpdate","updatedState","undefined","_handleDestruct","once","useBackgroundAssetCollection","assetCollection","setAssetCollection","backgroundAssets","setBackgroundAssets","Animation","preloadResources","tag","inline","disabled","_setDomElement","View","isAccelerated","onMount","onDOMMatrix","refOnMount","refOnDOMMatrix","refIsAccelerated","refEl","el","setTimeout","computedStyle","getComputedStyle","matrix","DOMMatrix","transform","is2D","module","exports"],"mappings":"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","file":"static/js/0.ebef1279.chunk.js","sourcesContent":["/**\n * @param {DOMElement}\n * @return {boolean} Whether or not the element is overflowing its parent.\n */\nexport default function getIsElOverflown(element) {\n  if (element) {\n    // Height / width of the inner element, including padding and borders\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    const innerOffsetHeight = element.offsetHeight;\n    const innerOffsetWidth = element.offsetWidth;\n\n    const parentNode = element.parentNode;\n\n    // Height / width of the outer element, including padding but excluding\n    // borders, margins, and scrollbars\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\n    const outerHeight = parentNode?.clientHeight;\n    const outerWidth = parentNode?.clientWidth;\n\n    if (outerHeight < innerOffsetHeight || outerWidth < innerOffsetWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport getIsElOverflown from \"@utils/getIsElOverflown\";\nimport requestSkippableAnimationFrame from \"@utils/requestSkippableAnimationFrame\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Fix issue on iOS 13 where ResizeObserver isn't available.\n */\nimport { install } from \"resize-observer\";\nif (!window.ResizeObserver) {\n  install();\n}\n\n/**\n * Determines if the given element is overflowing its container.\n *\n * Note: Some ideas were taken from these links, however the final solution\n * was not found within.\n * @see https://stackoverflow.com/questions/9333379/check-if-an-elements-content-is-overflowing\n * @see https://github.com/wojtekmaj/detect-element-overflow/blob/main/src/index.js\n *\n * @param {HTMLElement} element\n * @param {Object} isDetecting? [optional; default = true] Whether or not the\n * hook should detect overflow.\n * @return {boolean}\n */\nexport default function useOverflowDetection(element, isDetecting = true) {\n  const refPrevIsOverflown = useRef(null);\n\n  /**\n   * @return {boolean} Whether or not the element is overflowing its parent.\n   */\n  const getIsOverflown = useCallback(\n    () => getIsElOverflown(element),\n    [element]\n  );\n\n  const [isOverflown, setIsOverflown] = useState(() => getIsOverflown());\n\n  refPrevIsOverflown.current = isOverflown;\n\n  const uuid = useMemo(uuidv4, []);\n\n  useEffect(() => {\n    if (isDetecting && element) {\n      let _isUnmounting = false;\n\n      /**\n       * Handles checking of overflown, comparing it with previous state, and\n       * determining if the hook state should be updated.\n       *\n       * Sets hook state once detection has been performed.\n       *\n       * @return {void}\n       */\n      const checkIsOverflown = () => {\n        if (_isUnmounting) {\n          return;\n        }\n\n        const prevIsOverflown = refPrevIsOverflown.current;\n\n        const nextIsOverflown = getIsOverflown();\n\n        if (prevIsOverflown !== nextIsOverflown) {\n          setIsOverflown(nextIsOverflown);\n        }\n      };\n\n      const ro = new ResizeObserver((/* entries */) => {\n        /**\n         * IMPORTANT: requestSkippableAnimationFrame is used here to prevent\n         * possible \"resize-observer loop limit exceeded error.\"\n         *\n         * \"This error means that ResizeObserver was not able to deliver all\n         * observations within a single animation frame. It is benign (your site\n         * will not break).\"\n         *\n         * @see https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n         */\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n\n      ro.observe(element);\n      ro.observe(element.parentNode);\n\n      /*\n      const mo = new MutationObserver(() => {\n        requestSkippableAnimationFrame(checkIsOverflown, uuid);\n      });\n      */\n\n      // FIXME: (jh) Re-enable?\n      /*\n      mo.observe(element, {\n        childList: true,\n        subtree: true,\n      });\n      */\n\n      return function unmount() {\n        _isUnmounting = true;\n\n        ro.observe(element);\n        ro.unobserve(element.parentNode);\n        // mo.disconnect();\n      };\n    }\n  }, [isDetecting, element, getIsOverflown, uuid]);\n\n  return isOverflown;\n}\n","import Center from \"./Center\";\n\nexport default Center;\n","import React, { useState } from \"react\";\n\nimport classNames from \"classnames\";\nimport styles from \"./Center.module.css\";\n\nimport useOverflowDetection from \"@hooks/useOverflowDetection\";\n\nimport PropTypes from \"prop-types\";\n\nCenter.propTypes = {\n  /**\n   * Whether or not content can overflow when the Center content overflows it\n   * outer wrapper.\n   */\n  canOverflow: PropTypes.bool,\n};\n\nexport default function Center({\n  children,\n  className,\n  canOverflow = false,\n  ...rest\n}) {\n  const [innerEl, setInnerEl] = useState(null);\n\n  const isOverflown = useOverflowDetection(innerEl, canOverflow);\n\n  return (\n    <div\n      className={classNames(\n        styles[\"center\"],\n        canOverflow && isOverflown && styles[\"overflown\"],\n        className\n      )}\n    >\n      <div ref={setInnerEl} {...rest} className={styles[\"inner-wrap\"]}>\n        {children}\n      </div>\n    </div>\n  );\n}\n","import React, { Component } from \"react\";\nimport StackingContext from \"../StackingContext\";\nimport classNames from \"classnames\";\nimport styles from \"./Full.module.css\";\n\nclass Full extends Component {\n  render() {\n    const { children, className, ...rest } = this.props;\n\n    return (\n      <StackingContext\n        {...rest}\n        className={classNames(styles[\"full\"], className)}\n      >\n        {children}\n      </StackingContext>\n    );\n  }\n}\n\nexport default Full;\n","import Full from './Full';\n\nexport default Full;","import React from \"react\";\nimport Full from \"../Full\";\nimport classNames from \"classnames\";\nimport styles from \"./Cover.module.css\";\n\nexport default React.forwardRef(function Cover(\n  { isVisible = true, children, className, ...rest },\n  forwardedRef\n) {\n  return (\n    <Full\n      ref={forwardedRef}\n      {...rest}\n      className={classNames(\n        styles[\"cover\"],\n        !isVisible ? styles[\"no-display\"] : \"\"\n      )}\n    >\n      {children}\n    </Full>\n  );\n});\n","import Cover from './Cover';\n\nexport default Cover;","import { EVT_UPDATED } from \"@core/classes/UIServiceCore\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport useServicesContext from \"./useServicesContext\";\n\n/**\n * @typedef {Object} UseServiceClassReturn\n * @property {PhantomServiceCore} serviceInstance Instantiated\n * PhantomServiceCore extension.\n * @property {Object} serviceState Current state of the instantiated service\n * class.\n *\n * @param {PhantomServiceCore} ServiceClass Non-instantiated\n * PhantomServiceCore extension.\n */\nexport default function useServiceClass(ServiceClass) {\n  const { startServiceClass } = useServicesContext();\n\n  // Automatically start the service\n  const serviceInstance = useMemo(\n    () => startServiceClass(ServiceClass),\n    [ServiceClass, startServiceClass]\n  );\n\n  const [serviceState, setServiceState] = useState({});\n\n  // Bind service EVT_UPDATE events to hook state\n  useEffect(() => {\n    const _handleServiceUpdate = () => {\n      // IMPORTANT: Must set shallow clone of state or attached components may\n      // not update\n      setServiceState({ ...serviceInstance.getState() });\n    };\n\n    serviceInstance.on(EVT_UPDATED, _handleServiceUpdate);\n\n    return function unmount() {\n      serviceInstance.off(EVT_UPDATED, _handleServiceUpdate);\n    };\n  }, [serviceInstance]);\n\n  return {\n    serviceInstance,\n    serviceState,\n  };\n}\n","// TODO: Implement ability to delete pending frame group\n\nconst addFrameHandler = (() => {\n  /** @type {Object.Array<frameFunc: function, priority: number>} */\n  const frameGroups = {};\n\n  let isRunning = false;\n\n  let idx = -1;\n\n  function _batchRunner(/* timestamp */) {\n    isRunning = true;\n\n    ++idx;\n\n    const groupNames = Object.keys(frameGroups);\n\n    const lenGroupNames = groupNames.length;\n    let pending = lenGroupNames;\n\n    for (const groupName of groupNames) {\n      const [frameFunc, priority] = frameGroups[groupName];\n\n      if (!(idx % priority)) {\n        frameFunc();\n\n        delete frameGroups[groupName];\n\n        --pending;\n      }\n    }\n\n    // Don't run if there is no more work to do\n    if (pending) {\n      // Loop\n      window.requestAnimationFrame(_batchRunner);\n    } else {\n      isRunning = false;\n    }\n  }\n\n  return function addFrameHandler(groupName, frameFunc, priority) {\n    frameGroups[groupName] = [frameFunc, priority];\n\n    if (!isRunning) {\n      _batchRunner();\n    }\n  };\n})();\n\n/**\n * Extends requestAnimationFrame with skippable frame batching operations.\n *\n * @param {function} frameFunc The function to execute when the screen renders\n * @param {string} groupName The group which the function should reside in\n * @param {number} priority An integer greater or equal to 1; where 1 will\n * render the last frameFunc in the group on every render frame, and higher\n * numbers will render every nth frame\n */\nexport default function requestSkippableAnimationFrame(\n  frameFunc,\n  groupName,\n  priority = 3\n) {\n  // FIXME: (jh) Determine if these checks have a significant performance\n  // impact\n  /*\n  if (!groupName) {\n    throw new ReferenceError(\n      \"groupName is not found on requestSkippableAnimationFrame caller\"\n    );\n  }\n\n  priority = parseInt(priority, 10);\n  if (priority < 1 || priority > 10) {\n    throw new RangeError(\"priority must be an integer greater or equal to 1\");\n  }\n  */\n\n  addFrameHandler(groupName, frameFunc, priority);\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  // Prevent state from trying to be set after unmounted\n  const refIsUnmount = useRef(false);\n  useEffect(() => {\n    refIsUnmount.current = false;\n\n    return function unmount() {\n      refIsUnmount.current = true;\n    };\n  });\n\n  const [, setAlt] = useState(false);\n\n  const forceUpdate = useCallback(() => {\n    !refIsUnmount.current && setAlt(alt => !alt);\n  }, []);\n\n  return forceUpdate;\n}\n","import { useContext } from \"react\";\nimport { UIServicesContext } from \"../core/providers/UIServicesProvider\";\n\n// TODO: Move to @core/hooks\n\nexport default function useServicesContext() {\n  return useContext(UIServicesContext);\n}\n","import UIServicesProvider, { UIServicesContext } from \"./UIServicesProvider\";\n\nexport default UIServicesProvider;\nexport { UIServicesContext };\n","import React, { useCallback, useEffect, useMemo } from \"react\";\nimport ReShellCore from \"@core/classes/ReShellCore\";\nimport {\n  EVT_CHILD_INSTANCE_ADDED,\n  EVT_CHILD_INSTANCE_REMOVED,\n} from \"@core/classes/UIServiceManager\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n\nexport const UIServicesContext = React.createContext({});\n\n/**\n * Provides the React app with PhantomCore-based UIServiceManager /\n * UIServiceCore binding.\n */\nexport default function UIServicesProvider({ children }) {\n  const forceUpdate = useForceUpdate();\n\n  const _uiServiceManager = useMemo(\n    () => ReShellCore.getUIServiceManager(),\n    []\n  );\n\n  // Manage _uiServiceManager event bindings\n  useEffect(() => {\n    // Force UI to update when a service has been added or removed\n    //\n    // IMPORTANT: Collection EVT_UPDATED is not mapped here, and is handled\n    // elsewhere, as we don't want the entire UI to update every time\n    const _handleServiceAddedOrRemoved = () => {\n      // IMPORTANT: This fixes re-render attempts while a child component is\n      // being updated (i.e. WindowManager currently is instantiating services\n      // during the render cycle)\n      setImmediate(() => {\n        forceUpdate();\n      });\n    };\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_ADDED,\n      _handleServiceAddedOrRemoved\n    );\n\n    _uiServiceManager.on(\n      EVT_CHILD_INSTANCE_REMOVED,\n      _handleServiceAddedOrRemoved\n    );\n\n    return function unmount() {\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_ADDED,\n        _handleServiceAddedOrRemoved\n      );\n\n      _uiServiceManager.off(\n        EVT_CHILD_INSTANCE_REMOVED,\n        _handleServiceAddedOrRemoved\n      );\n    };\n  }, [forceUpdate, _uiServiceManager]);\n\n  /**\n   * Starts the service with the given ServiceClass.\n   *\n   * If it is already started, subsequent attempts will be ignored.\n   *\n   * @param {UIServiceCore}\n   * @return {void}\n   */\n  const startServiceClass = useCallback(\n    ServiceClass => _uiServiceManager.startServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n\n  /**\n   * Destructs the service instance with the given ServiceClass.\n   *\n   * @param {UIServiceCore}\n   * @return {Promise<void>}\n   */\n  /*\n  const stopServiceClass = useCallback(\n    async ServiceClass => _uiServiceManager.stopServiceClass(ServiceClass),\n    [_uiServiceManager]\n  );\n  */\n\n  return (\n    <UIServicesContext.Provider\n      value={{\n        services: _uiServiceManager && _uiServiceManager.getChildren(),\n        startServiceClass,\n        // stopServiceClass,\n      }}\n    >\n      {children}\n    </UIServicesContext.Provider>\n  );\n}\n","import { useEffect, useRef } from \"react\";\nimport \"animate.css\";\n\n// TODO: Document\nexport default function useAnimation({\n  domElement,\n  animationName,\n  // FIXME: Duration and delay are currently passed as strings because that's\n  // what the underlying CSS requires, but they should probably also accept\n  // integers representing milliseconds.\n  animationDuration = \"1s\",\n  animationDelay = \"0s\",\n  // TODO: Ensure onAnimationEnd is triggered on Windows if animations are turned off\n  onAnimationEnd,\n  animationEngine = \"animate.css\",\n  isDisabled = false,\n  shouldRun = true,\n}) {\n  if (typeof animationDuration !== \"string\") {\n    console.warn('animationDuration should be a string (i.e. \"1s\")');\n  }\n\n  if (typeof animationDelay !== \"string\") {\n    console.warn('animationDelay should be a string (i.e. \"0s\")');\n  }\n\n  const refOnAnimationEnd = useRef(onAnimationEnd);\n\n  useEffect(() => {\n    if (shouldRun && domElement) {\n      if (isDisabled) {\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n      } else {\n        const classes = domElement.classList;\n\n        // Unhide the element\n        //\n        // IMPORTANT: This fixes an issue where text might appear to pop before\n        // transition is applied. It should be used in conjunction with opacity\n        // being set to 0, initially, as the Animation component does.\n        //\n        // TODO: Can this be used as an exported property instead of directly\n        // manipulating here?\n        domElement.style.visibility = \"visible\";\n\n        domElement.style.animationDuration = animationDuration;\n        domElement.style.animationDelay = animationDelay;\n\n        switch (animationEngine) {\n          /**\n           * @see https://animate.style animate.css\n           */\n          case \"animate.css\":\n            (() => {\n              // TODO: Implement optional animation engine\n              // animate.css\n              const BASE = \"animate__animated\";\n\n              if (!classes.contains(BASE)) {\n                domElement.classList.add(BASE);\n              }\n\n              if (!classes.contains(\"animate__\" + animationName)) {\n                domElement.classList.add(\"animate__\" + animationName);\n              }\n            })();\n            break;\n\n          default:\n            throw new Error(`Unsupported animation engine: ${animationEngine}`);\n        }\n\n        const onAnimationEnd = refOnAnimationEnd.current;\n\n        // TODO: Also handle removing of effect from class list, so we can re-use it, if necessary\n        domElement.addEventListener(\"animationend\", onAnimationEnd);\n\n        return function unmount() {\n          domElement.removeEventListener(\"animationend\", onAnimationEnd);\n        };\n      }\n    }\n  }, [\n    animationEngine,\n    animationName,\n    animationDuration,\n    animationDelay,\n    domElement,\n    isDisabled,\n    shouldRun,\n  ]);\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport Preload from \"preload-it\";\n\n/**\n * Pre-loads resources, as a React hook.\n *\n * @param {string[]} resources An array of URLs to preload. Note that these are\n * cached and the list cannot be changed without re-instantiating the hook.\n * @return {Object} // TODO: Document return type\n */\nexport default function usePreload(resources) {\n  const [isPreloaded, _setIsPreloaded] = useState(false);\n  const [progress, _setProgress] = useState(0);\n\n  // Cache the resources; This fixes an issue where passing in a non-memoized\n  // array could cause the following useEffect to trigger more than once.\n  //\n  // Issue was discovered when images would preload multiple times in Firefox.\n  const refResources = useRef(resources);\n\n  useEffect(() => {\n    const resources = refResources.current;\n\n    if (resources.length) {\n      const preload = new Preload();\n\n      preload.onprogress = evt => {\n        _setProgress(evt.progress);\n      };\n\n      preload.oncomplete = (/* items */) => {\n        _setIsPreloaded(true);\n      };\n\n      preload.fetch(resources);\n\n      // FIXME: (jh) Retry fetch if browser is offline, then comes online again\n    } else {\n      // No resources to load; proceed\n      _setIsPreloaded(true);\n      _setProgress(100);\n    }\n  }, []);\n\n  return {\n    isPreloaded,\n    progress,\n  };\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// AppRegistration cache\nconst _registrations = {};\n\n// TODO: Include ability to register preload resources, to preload when runtime is initiated\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Include ability to retain window sizes and positions after\n// modification (not sure if that should be here or in AppRuntime)\n\n// TODO: Include ability to test condition before applying registration(?)\n\n// TODO: Document\n// A reference node for the desktop to determine what should be listed in program menus\nexport default class AppRegistration extends PhantomCore {\n  // TODO: Validate appDescriptor\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Registers, or updates, the given AppRegistration cache.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {AppRegistration}\n   * @return {void}\n   */\n  static addOrUpdateAppRegistration(appDescriptor) {\n    const { id } = appDescriptor;\n\n    // Registrations may be updated when in development mode, and updating the\n    // source code to a registered application. In most cases, the following\n    // code block will run before the respective application is updated /\n    // re-rendered.\n    //\n    // TODO: Implement some message-bus functionality to let other instances\n    // know of updated registrations (i.e. so this can be piped up to UI\n    // notification)\n    if (_registrations[id]) {\n      // Automatically update the registration\n      _registrations[id].updateAppDescriptor(appDescriptor);\n\n      return _registrations[id];\n    } else {\n      return new AppRegistration(appDescriptor);\n    }\n  }\n\n  // TODO: Move this handling directly into AppRegistrationCollection (do not\n  // call from anywhere else)\n  /**\n   * Unregisters the given AppRegistration from the cache.\n   *\n   * This will remove the application from the applications menu.\n   *\n   * @param {AppRegistration | string}\n   * @return {void}\n   */\n  static async removeAppRegistration(appDescriptorOrID) {\n    let id = null;\n    if (typeof appDescriptor === \"object\") {\n      id = appDescriptorOrID.id;\n    } else {\n      id = appDescriptorOrID;\n    }\n\n    if (_registrations[id]) {\n      return _registrations[id].destroy();\n    }\n  }\n\n  // TODO: Document\n  constructor(appDescriptor) {\n    // TODO: Validate appDescriptor before trying to use\n\n    super();\n\n    // TODO: Document type\n    this._appDescriptor = appDescriptor;\n\n    _registrations[appDescriptor.id] = this;\n  }\n\n  /**\n   * @return {Object}\n   */\n  getAppDescriptor() {\n    return this._appDescriptor;\n  }\n\n  /**\n   * @return {string | number}\n   */\n  getID() {\n    return this._appDescriptor.id;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTitle() {\n    return this._appDescriptor.title;\n  }\n\n  /**\n   * TODO: Document\n   *\n   * @return {Object | void}\n   */\n  getMenu() {\n    return this._appDescriptor.menu;\n  }\n\n  /**\n   * TODO: Rename (clarify pin type)\n   *\n   * Returns whether or not the application is pinned to the desktop menu.\n   *\n   * @return {boolean}\n   */\n  getIsPinned() {\n    return Boolean(this._appDescriptor.isPinned);\n  }\n\n  // TODO: Document\n  getIsPinnedToDock() {\n    return Boolean(this._appDescriptor.isPinnedToDock);\n  }\n\n  // TODO: Document\n  getIsAutoStart() {\n    return Boolean(this._appDescriptor.isAutoStart);\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async destroy() {\n    delete _registrations[this._appDescriptor.id];\n\n    return super.destroy();\n  }\n\n  // TODO: Document\n  updateAppDescriptor(appDescriptor) {\n    this._appDescriptor = appDescriptor;\n\n    // TODO: Only emit if something changed\n    this.emit(EVT_UPDATED);\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRegistrationCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    return super.addChild(appRegistration);\n  }\n\n  /**\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  addAppRegistration(appRegistration) {\n    return this.addChild(appRegistration);\n  }\n\n  /**\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  removeAppRegistration(appRegistration) {\n    return this.removeChild(appRegistration);\n  }\n\n  /**\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    // FIXME: (jh) The only way I could get this to sort alphabetically on\n    // Firefox was to build a reverse-sorted list, then reverse it again;\n    // Chrome was not affected by this\n    return this.getChildren()\n      .sort((a, b) => {\n        const aTitle = a.getTitle();\n        const bTitle = b.getTitle();\n\n        if (aTitle < bTitle) {\n          return 1;\n        } else if (bTitle > aTitle) {\n          return -1;\n        } else {\n          return 0;\n        }\n      })\n      .reverse();\n  }\n}\n","import PhantomCore, { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport AppRegistration from \"./AppRegistration\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Include ability to load preload resources, with states representing before / after preloading\n// TODO: Include ability to register splash screen, while preloading\n\n// TODO: Document\nexport default class AppRuntime extends PhantomCore {\n  // TODO: Implement ability to inherit base environment here\n  // TODO: Implement ability to fork?\n  // TODO: Implement ability to set initial environment\n\n  // TODO: Document\n  constructor(appRegistration) {\n    if (!(appRegistration instanceof AppRegistration)) {\n      throw new TypeError(\"appRegistration is not an AppRegistration\");\n    }\n\n    super();\n\n    this._appRegistration = appRegistration;\n\n    this.registerShutdownHandler(() => {\n      // IMPORTANT: We only want to remove the registration, but don't want to\n      // destruct the registration itself, as it should be reused\n      delete this._appRegistration;\n    });\n\n    // Emit EVT_UPDATED out runtime when the registration updates\n    this.proxyOn(this._appRegistration, EVT_UPDATED, () => {\n      this.emit(EVT_UPDATED);\n    });\n\n    // Destruct runtime when registration destructs\n    this.proxyOn(this._appRegistration, EVT_DESTROYED, () => {\n      this.destroy();\n    });\n\n    this._windowController = null;\n\n    this.registerShutdownHandler(async () => {\n      await this._windowController.destroy();\n    });\n  }\n\n  // TODO: Document\n  bringToTop() {\n    if (this._windowController) {\n      return this._windowController.bringToTop();\n    }\n  }\n\n  // TODO: Document\n  // Internally called by the window manager\n  __INTERNAL__setWindowController(windowController) {\n    // TODO: Verify windowController is a WindowController\n\n    this._windowController = windowController;\n  }\n\n  // TODO: Document\n  getWindowController() {\n    return this._windowController;\n  }\n\n  // TODO: Document\n  getRegistration() {\n    return this._appRegistration;\n  }\n\n  // TODO: Document\n  getRegistrationID() {\n    return this._appRegistration.getID();\n  }\n\n  // TODO: Rename to getDescriptor? For instance, getRegistration isn't called\n  // getAppRegistration; standardize on either name, but keep it consistent.\n  // TODO: Document\n  getAppDescriptor() {\n    return this._appRegistration.getAppDescriptor();\n  }\n\n  // TODO: Implement setEnvironment\n\n  getEnvironment() {\n    // TODO: Mix with runtime environment\n    return process.env;\n  }\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nimport AppRuntime from \"./AppRuntime\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n// TODO: Document\nexport default class AppRuntimeCollection extends PhantomCollection {\n  // TODO: Document\n  addChild(appRuntime) {\n    if (!(appRuntime instanceof AppRuntime)) {\n      throw new TypeError(\"appRuntime is not an AppRuntime\");\n    }\n\n    return super.addChild(appRuntime);\n  }\n\n  /**\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  addAppRuntime(appRuntime) {\n    return this.addChild(appRuntime);\n  }\n\n  /**\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {void}\n   */\n  removeAppRuntime(appRuntime) {\n    return this.removeChild(appRuntime);\n  }\n\n  /**\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this.getChildren();\n  }\n}\n","import UIServiceCore, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"@core/classes/UIServiceCore\";\n\nimport AppRegistration from \"./classes/AppRegistration\";\nimport AppRegistrationCollection from \"./classes/AppRegistrationCollection\";\n\nimport AppRuntime from \"./classes/AppRuntime\";\nimport AppRuntimeCollection from \"./classes/AppRuntimeCollection\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\n/**\n * Manages the collection, starting, and stopping of AppRuntime instances.\n */\nexport default class AppOrchestrationService extends UIServiceCore {\n  // TODO: Document\n  constructor(...args) {\n    super(...args);\n\n    this.setTitle(\"App Orchestration Service\");\n\n    this._appRegistrationCollection = this.bindCollectionClass(\n      AppRegistrationCollection\n    );\n    this._appRuntimeCollection = this.bindCollectionClass(AppRuntimeCollection);\n  }\n\n  /**\n   * Retrieves the app registration title associated with the given app\n   * descriptor ID.\n   *\n   * @param {string} appDescriptorID\n   * @return {string | void}\n   */\n  getAppRegistrationTitleWithDescriptorID(appDescriptorID) {\n    const appRegistration = this._appRegistrationCollection\n      .getAppRegistrations()\n      .find(predicate => predicate.getID() === appDescriptorID);\n\n    if (!appRegistration) {\n      console.warn(\n        `Could not locate appRegistration with id: ${appDescriptorID}`\n      );\n    } else {\n      return appRegistration.getTitle();\n    }\n  }\n\n  /**\n   * Registers, or updates, the AppRegistration cache with the given app\n   * descriptor.\n   *\n   * This is used primarily for applications menu population.\n   *\n   * @param {Object} // TODO: Document AppDescriptor type\n   * @return {void}\n   */\n  addOrUpdateAppRegistration(appDescriptor) {\n    const appRegistration =\n      AppRegistration.addOrUpdateAppRegistration(appDescriptor);\n\n    // TODO: Will this actually update the registration?\n    this._appRegistrationCollection.addAppRegistration(appRegistration);\n  }\n\n  // TODO: Implement removeAppRegistration (this._appRegistrationCollection.removeAppRegistration)\n\n  // TODO: Ensure app registration is either not already active, or that it\n  // supports multiple windows before trying to start multiple instances\n  /**\n   * Provides core launching capability for the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {AppRuntime}\n   */\n  _launchAppRegistration(appRegistration) {\n    const appRuntime = new AppRuntime(appRegistration);\n\n    this._appRuntimeCollection.addAppRuntime(appRuntime);\n\n    return appRuntime;\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, the given AppRegistration.\n   *\n   * @param {AppRegistration} appRegistration\n   * @return {void}\n   */\n  activateAppRegistration(appRegistration) {\n    if (!this.getActiveAppRegistrations().includes(appRegistration)) {\n      // TODO: Open app w/ registration\n      this._launchAppRegistration(appRegistration);\n    } else {\n      // Move grouped windows to top\n      // TODO: Order by window manager stacking order (most recently used\n      // window in group should appear in top)\n      // TODO: Refactor into window manager?\n      this.getAppRuntimes()\n        .filter(runtime => runtime.getRegistration() === appRegistration)\n        .forEach(runtime => runtime.bringToTop());\n    }\n  }\n\n  /**\n   * Activates (i.e. brings to front), or launches, an AppRegistration with the\n   * given ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {void}\n   */\n  activateAppRegistrationID(appRegistrationID) {\n    const appRegistration = this.getAppRegistrations().find(\n      predicate => predicate.getID() === appRegistrationID\n    );\n\n    if (!appRegistration) {\n      this.log.warn(`Unknown appRegistration with id: ${appRegistrationID}`);\n    } else {\n      this.activateAppRegistration(appRegistration);\n    }\n  }\n\n  /**\n   * NOTE: This is purely a convenience method; it oes not have to be called\n   * directly on this service if destructing the AppRuntime instance directly.\n   *\n   *\n   * @param {AppRuntime} appRuntime\n   * @return {Promise<void>}\n   */\n  async closeAppRuntime(appRuntime) {\n    return appRuntime.destroy();\n  }\n\n  /**\n   * Retrieves the currently registered apps, used to populate application\n   * menus.\n   *\n   * @return {AppRegistration[]}\n   */\n  getAppRegistrations() {\n    return this._appRegistrationCollection.getAppRegistrations();\n  }\n\n  /**\n   * Retrieves the current AppRegistration instances associated with running\n   * AppRuntime instances.\n   *\n   * @return {AppRegistration[]}\n   */\n  getActiveAppRegistrations() {\n    return [\n      ...new Set(\n        this.getAppRuntimes().map(runtime => runtime.getRegistration())\n      ),\n    ];\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances.\n   *\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimes() {\n    return this._appRuntimeCollection.getAppRuntimes();\n  }\n\n  /**\n   * Retrieves the currently running AppRuntime instances with the given app\n   * registration ID.\n   *\n   * @param {string} appRegistrationID\n   * @return {AppRuntime[]}\n   */\n  getAppRuntimesWithRegistrationID(appRegistrationID) {\n    return this.getAppRuntimes().filter(\n      appRuntime => appRuntime.getRegistrationID() === appRegistrationID\n    );\n  }\n}\n","import AppOrchestrationService, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"./AppOrchestrationService\";\n\nexport default AppOrchestrationService;\nexport { EVT_UPDATED, EVT_DESTROYED };\n","import React from \"react\";\n\nimport useServiceClass from \"@hooks/useServiceClass\";\n\nimport AppOrchestrationService from \"@services/AppOrchestrationService\";\n\nimport useAppRuntimesAutoStart from \"./useAppRuntimesAutoStart\";\n\nexport const AppOrchestrationContext = React.createContext({});\n\n/**\n * Provides the React application with ReShell app orchestration servicing.\n */\nexport default function AppOrchestrationProvider({ children }) {\n  const { serviceInstance: appOrchestrationService } = useServiceClass(\n    AppOrchestrationService\n  );\n\n  const activeAppRegistrations =\n    appOrchestrationService.getActiveAppRegistrations();\n  const appRegistrations = appOrchestrationService.getAppRegistrations();\n  const appRuntimes = appOrchestrationService.getAppRuntimes();\n\n  const activateAppRegistration =\n    appOrchestrationService.activateAppRegistration;\n  const activateAppRegistrationID =\n    appOrchestrationService.activateAppRegistrationID;\n  const addOrUpdateAppRegistration =\n    appOrchestrationService.addOrUpdateAppRegistration;\n  const getAppRegistrationTitleWithDescriptorID =\n    appOrchestrationService.getAppRegistrationTitleWithDescriptorID;\n  const getAppRuntimesWithRegistrationID =\n    appOrchestrationService.getAppRuntimesWithRegistrationID;\n\n  // Handles auto-start of apps which are set to automatically launch\n  //\n  // FIXME: (jh) Refactor using a different approach\n  useAppRuntimesAutoStart(appRegistrations, activateAppRegistration);\n\n  return (\n    <AppOrchestrationContext.Provider\n      value={{\n        activeAppRegistrations,\n        appRegistrations,\n        appRuntimes,\n        //\n        activateAppRegistration,\n        activateAppRegistrationID,\n        addOrUpdateAppRegistration,\n        getAppRegistrationTitleWithDescriptorID,\n        getAppRuntimesWithRegistrationID,\n      }}\n    >\n      {children}\n    </AppOrchestrationContext.Provider>\n  );\n}\n","import AppOrchestrationProvider, {\n  AppOrchestrationContext,\n} from \"./AppOrchestrationProvider\";\n\nexport default AppOrchestrationProvider;\nexport { AppOrchestrationContext };\n","import { useEffect, useRef } from \"react\";\n\n/**\n * Handles auto-start of apps which are set to automatically launch.\n *\n * @param {AppRegistration[]}\n * @param {func} activateAppRegistration\n * @return {void}\n */\nexport default function useAppRuntimesAutoStart(\n  appRegistrations,\n  activateAppRegistration\n) {\n  const refHasBegunAutoStart = useRef(false);\n\n  // Automatically start registrations with isAutoStart set to true\n  useEffect(() => {\n    if (appRegistrations.length && !refHasBegunAutoStart.current) {\n      // Prevent auto-start sequence from happening more than once\n      refHasBegunAutoStart.current = true;\n\n      // FIXME: (jh) The reversed registrations seems to open apps in forward\n      // order, based on how they are defined in the desktop array.  I\n      // haven't done a lot of testing against this, so this may need to be\n      // redefined as necessary\n      for (const registration of [...appRegistrations]\n        .filter(registration => registration.getIsAutoStart())\n        .reverse()) {\n        activateAppRegistration(registration);\n      }\n    }\n  }, [appRegistrations, activateAppRegistration]);\n}\n","import { EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\nimport { useEffect, useState } from \"react\";\n\nimport useForceUpdate from \"@hooks/useForceUpdate\";\n// import useServicesContext from \"@hooks/useServicesContext\";\n// import AppOrchestrationService from \"../../AppRuntimesProvider/services/AppOrchestrationService\";\n\n// TODO: Refactor [native] window title setting\nconst DEFAULT_DOCUMENT_TITLE = document.title;\n\n// TODO: [consider using active element to help determine active controller in certain situations]\n// https://github.com/facebook/react/blob/main/packages/react-dom/src/client/getActiveElement.js\n\n// TODO: Document\nexport default function useActiveWindowController() {\n  const [activeWindowController, setActiveWindowController] = useState(null);\n  // const [backgroundVideoMediaStreamTrack, setBackgroundVideoMediaStreamTrack] = useState(null);\n\n  /*\n  const appOrchestrationService = useServiceClass(\n    AppOrchestrationService\n  );\n  */\n\n  // TODO: Remove\n  // TODO: Mirror active window controller w/ AppOrchestrationService (maybe have useActiveWindowController reflect orchestration state)\n  // const { services } = useServicesContext();\n  // console.log({ services });\n\n  // IMPORTANT! This should not be called often as it will force the entire app\n  // to re-render\n  const forceDesktopUpdate = useForceUpdate();\n\n  // FIXME: (jh) The useEffect won't run if the active window title has\n  // changed; forceDesktopUpdate is currently required to make it work,\n  // however the goal is to not have DesktopProvider re-render often\n  useEffect(() => {\n    const _handleUpdate = updatedState => {\n      // TODO: Refactor [native] window title setting\n      if (!activeWindowController) {\n        document.title = DEFAULT_DOCUMENT_TITLE;\n      } else if (!updatedState || updatedState.title !== undefined) {\n        document.title = `${activeWindowController.getTitle()} | ${DEFAULT_DOCUMENT_TITLE}`;\n\n        // Force the entire app to re-render so that the active menu does\n        // FIXME: (jh) This shouldn't require a forced update of the entire\n        // app; Dock / misc. items should listen to active window controller,\n        // or its related AppRuntime, itself\n        forceDesktopUpdate();\n      }\n    };\n\n    // Perform initial update to set document title, if exists\n    _handleUpdate();\n\n    if (activeWindowController) {\n      // Deactivate hook window controller state if destructed\n      const _handleDestruct = () => {\n        setActiveWindowController(null);\n      };\n\n      activeWindowController.on(EVT_UPDATED, _handleUpdate);\n      activeWindowController.once(EVT_DESTROYED, _handleDestruct);\n\n      return function unmount() {\n        activeWindowController.off(EVT_UPDATED, _handleUpdate);\n        activeWindowController.off(EVT_DESTROYED, _handleDestruct);\n      };\n    }\n  }, [activeWindowController, forceDesktopUpdate]);\n\n  return {\n    activeWindowController,\n    setActiveWindowController,\n  };\n}\n","import { PhantomCollection, EVT_UPDATED, EVT_DESTROYED } from \"phantom-core\";\n\nexport { EVT_UPDATED, EVT_DESTROYED };\n\nexport default class BackgroundAssetCollection extends PhantomCollection {\n  // TODO: Document\n  addBackgroundAsset(backgroundAsset) {\n    return this.addChild(backgroundAsset);\n  }\n\n  // TODO: Document\n  removeBackgroundAsset(backgroundAsset) {\n    return this.removeChild(backgroundAsset);\n  }\n\n  // TODO: Document\n  getBackgroundAssets() {\n    return this.getChildren();\n  }\n}\n","import React from \"react\";\n\nimport useActiveWindowController from \"./hooks/useActiveWindowController\";\nimport useBackgroundAssetCollection from \"./hooks/useBackgroundAssetCollection\";\n\nexport const DesktopContext = React.createContext({});\n\nexport default function DesktopProvider({ children }) {\n  const { activeWindowController, setActiveWindowController } =\n    useActiveWindowController();\n  const { backgroundAssets, addBackgroundAsset, removeBackgroundAsset } =\n    useBackgroundAssetCollection();\n\n  return (\n    <DesktopContext.Provider\n      value={{\n        activeWindowController,\n        setActiveWindowController,\n\n        backgroundAssets,\n        addBackgroundAsset,\n        removeBackgroundAsset,\n      }}\n    >\n      {children}\n    </DesktopContext.Provider>\n  );\n}\n","import DesktopProvider, { DesktopContext } from \"./DesktopProvider\";\n\nexport default DesktopProvider;\nexport { DesktopContext };\n","import { useCallback, useEffect, useState } from \"react\";\nimport BackgroundAssetCollection, {\n  EVT_UPDATED,\n  EVT_DESTROYED,\n} from \"../classes/BackgroundAssetCollection\";\n\nexport default function useBackgroundAssetCollection() {\n  const [assetCollection, setAssetCollection] = useState(null);\n  const [backgroundAssets, setBackgroundAssets] = useState([]);\n\n  useEffect(() => {\n    const assetCollection = new BackgroundAssetCollection();\n\n    setAssetCollection(assetCollection);\n\n    assetCollection.once(EVT_DESTROYED, () => {\n      setAssetCollection(null);\n    });\n\n    setBackgroundAssets(assetCollection.getBackgroundAssets());\n    assetCollection.on(EVT_UPDATED, () =>\n      setBackgroundAssets(assetCollection.getBackgroundAssets())\n    );\n\n    return function unmount() {\n      assetCollection.destroy();\n    };\n  }, []);\n\n  // TODO: Document\n  const addBackgroundAsset = useCallback(\n    backgroundAsset => assetCollection.addBackgroundAsset(backgroundAsset),\n    [assetCollection]\n  );\n\n  // TODO: Document\n  const removeBackgroundAsset = useCallback(\n    backgroundAsset => assetCollection.removeBackgroundAsset(backgroundAsset),\n    [assetCollection]\n  );\n\n  return {\n    backgroundAssets,\n    addBackgroundAsset,\n    removeBackgroundAsset,\n  };\n}\n","import Animation from \"./Animation\";\n\nexport default Animation;\n","import React, { useMemo, useState } from \"react\";\nimport usePreload from \"@hooks/usePreload\";\nimport useAnimation from \"@hooks/useAnimation\";\nimport classNames from \"classnames\";\nimport styles from \"./Animation.module.css\";\n\nexport default function Animation({\n  className,\n  children,\n\n  // TODO: Rename to effect name\n  animationName,\n  animationDuration,\n  animationDelay,\n\n  animationEngine = \"animate.css\",\n  preloadResources = [],\n  onAnimationEnd = () => null,\n  tag = \"div\",\n  inline = false,\n\n  disabled = false,\n  ...rest\n}) {\n  const [domElement, _setDomElement] = useState(null);\n\n  const { isPreloaded } = usePreload(preloadResources);\n\n  useAnimation({\n    domElement,\n    animationName,\n    animationDuration,\n    animationDelay,\n    animationEngine,\n    onAnimationEnd,\n\n    // NOTE (jh): I don't really like this, but the alternative is putting\n    // isDisabled property on <Animation disabled /> and I don't like that\n    // either\n    isDisabled: disabled,\n  });\n\n  const View = useMemo(() => tag, [tag]);\n\n  if (!isPreloaded) {\n    return null;\n  }\n\n  return (\n    <View\n      {...rest}\n      ref={_setDomElement}\n      className={classNames(\n        styles[\"animation\"],\n        inline ? styles[\"inline\"] : null,\n        className\n      )}\n    >\n      {children}\n    </View>\n  );\n}\n","import StackingContext from \"./StackingContext\";\n\nexport default StackingContext;\n","import React, { useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport styles from \"./StackingContext.module.css\";\n\nimport PropTypes from \"prop-types\";\n\n// Amount of time, in milliseconds, to wait before trying to determine if a 2D\n// or 3D matrix\nconst MATRIX_DETECTION_DELAY = 100;\n\nStackingContext.propTypes = {\n  /**\n   * Whether or not the stacking context should be GPU accelerated\n   *\n   * [default = false]\n   **/\n  isAccelerated: PropTypes.bool,\n\n  /**\n   * Called, with the DOM element of the stacking context after it renders to\n   * the DOM.\n   **/\n  onMount: PropTypes.func,\n\n  /**\n   * Called, with the DOM Matrix, after acquisition from the stacking context.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix\n   */\n  onDOMMatrix: PropTypes.func,\n};\n\n/**\n * Description from MDN Web Docs: The stacking context is a three-dimensional\n * conceptualization of HTML elements along an imaginary z-axis relative to the\n * user, who is assumed to be facing the viewport or the webpage. HTML elements\n * occupy this space in priority order based on element attributes.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n *\n * NOTE: This component contains some small trickery to try to GPU accelerate\n * the component and its children.  By default, this functionality is not\n * utilized and it is recommended to only use it for various components of the\n * web app, instead of the entire thing.\n */\nexport default function StackingContext({\n  className,\n  children,\n  isAccelerated = false,\n  onMount = () => null,\n  onDOMMatrix = () => null,\n  ...rest\n}) {\n  const refOnMount = useRef(onMount);\n  const refOnDOMMatrix = useRef(onDOMMatrix);\n  const refIsAccelerated = useRef(isAccelerated);\n\n  const refEl = useRef(null);\n\n  // Handle onMount and onDOMMatrix callbacks\n  useEffect(() => {\n    const el = refEl.current;\n\n    if (el) {\n      const onMount = refOnMount.current;\n      const onDOMMatrix = refOnDOMMatrix.current;\n      const isAccelerated = refIsAccelerated.current;\n\n      if (isAccelerated) {\n        // Handle 3D space detection and onDOMMatrix callback\n        //\n        // FIXME: (jh) Use of setTimeout fixes an issue where is2D didn't seem\n        // to be accurate on the first render, and possibly some subsequent\n        // render attempts.  I'm not positive this has fixed it for good and it\n        // might need to be investigated some more.\n        setTimeout(() => {\n          const computedStyle = window.getComputedStyle(el);\n\n          /** @see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix */\n          const matrix = new DOMMatrix(computedStyle.transform);\n\n          /**\n           * NOTE: Each matrix value will be a string, not a number\n           *\n           * @see https://zellwk.com/blog/css-translate-values-in-javascript/\n           **/\n          /*\n            const matrixValues = computedStyle.transform\n              .match(/matrix.*\\((.+)\\)/)[1]\n              .split(\", \");*/\n\n          // NOTE: (jh) It seems that the matrix can be 3D and still not be\n          // accelerated, so some further considerations may need to be made\n\n          if (matrix.is2D /* || matrixValues[14] === undefined*/) {\n            console.warn(\n              \"Unable to apply, or detect, added 3D space to accelerated element\",\n              el\n            );\n          }\n\n          onDOMMatrix(matrix);\n        }, MATRIX_DETECTION_DELAY);\n      }\n\n      onMount(el);\n    }\n  }, []);\n\n  return (\n    <div\n      ref={refEl}\n      {...rest}\n      className={classNames(\n        styles[\"stacking-context\"],\n        isAccelerated && styles[\"accelerated\"],\n        className\n      )}\n    >\n      {children}\n    </div>\n  );\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"stacking-context\":\"StackingContext_stacking-context__3KDjJ\",\"accelerated\":\"StackingContext_accelerated__E4pfU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"full\":\"Full_full__3xUwm\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__3qNO7\",\"no-display\":\"Cover_no-display__vixgE\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"animation\":\"Animation_animation__1HH_d\",\"inline\":\"Animation_inline__3Lb1U\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"center\":\"Center_center__PZFg8\",\"overflown\":\"Center_overflown__LMy0-\",\"inner-wrap\":\"Center_inner-wrap__2OIMV\"};"],"sourceRoot":""}